# generated by datamodel-codegen:
#   filename:  cc_openapi_v2_1.json
#   timestamp: 2025-03-21T20:58:41+00:00

from __future__ import annotations

from datetime import date
from enum import Enum
from typing import List, Optional, Union

from pydantic import (
    BaseModel,
    ConfigDict,
    EmailStr,
    Field,
    RootModel,
    confloat,
    conint,
    constr,
)


class InternalStatus(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    status_term: constr(min_length=1) = Field(
        ...,
        alias='statusTerm',
        description='The carrier status to indicate if it can be used within MasterMind. The status will determine if certain operations in the TMS system can use the carrier record.',
    )
    reason_code_term: Optional[str] = Field(
        None,
        alias='reasonCodeTerm',
        description='Explains further why the carrier record is in the current internal status.',
    )
    notes: Optional[str] = Field(
        None, description='Free-form note about the internal status.'
    )


class TypeTerm(Enum):
    carrier = 'carrier'
    factor = 'factor'
    vendor = 'vendor'
    fleet = 'fleet'


class RemittanceGroupingTerm(Enum):
    route = 'Route'


class RemittanceGroupingTerm1(RootModel[None]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: None = Field(
        None,
        description='This will designate how remittance payments will be grouped (i.e. by route).',
    )


class VoucherSettings(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    payment_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='paymentTerm',
        description='The payment terms of a carrier (e.g., Net 20, Net 30, etc).',
    )
    payment_method_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='paymentMethodTerm',
        description="The carrier's preferred payment method (i.e. check, EFT).",
    )
    currency_code_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='currencyCodeTerm',
        description="The carrier's payment currency (i.e. USD, CAN, etc.).",
    )
    voucher_method_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='voucherMethodTerm',
        description="The delivery method for the carrier's voucher (i.e. Email, Print).",
    )
    remittance_to_carrier_code: Optional[str] = Field(
        None,
        alias='remittanceToCarrierCode',
        description='The external code of a separate carrier that should be referenced for remittance payments.',
    )
    remittance_to_email: Optional[EmailStr] = Field(
        None,
        alias='remittanceToEmail',
        description='The email address to use for remittance payments.',
    )
    remittance_grouping_term: Optional[
        Union[RemittanceGroupingTerm, RemittanceGroupingTerm1]
    ] = Field(
        None,
        alias='remittanceGroupingTerm',
        description='This will designate how remittance payments will be grouped (i.e. by route).',
    )


class Organization(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined UUID referencing the organization.'
    )
    name: Optional[constr(min_length=1)] = Field(
        None, description='The name of the organization.'
    )
    hierarchy_code: Optional[constr(min_length=1)] = Field(
        None,
        alias='hierarchyCode',
        description='The internally defined hierarchy code referencing the organization.',
    )


class Organization1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined UUID referencing the organization.'
    )
    name: constr(min_length=1) = Field(..., description='The name of the organization.')
    hierarchy_code: Optional[constr(min_length=1)] = Field(
        None,
        alias='hierarchyCode',
        description='The internally defined hierarchy code referencing the organization.',
    )


class Organization2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined UUID referencing the organization.'
    )
    name: Optional[constr(min_length=1)] = Field(
        None, description='The name of the organization.'
    )
    hierarchy_code: constr(min_length=1) = Field(
        ...,
        alias='hierarchyCode',
        description='The internally defined hierarchy code referencing the organization.',
    )


class Address(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The type of address for the carrier (i.e. Billing, Remittance).',
    )
    street1: constr(min_length=1) = Field(
        ..., description='The street name and number of the address.'
    )
    street2: Optional[str] = Field(
        None, description='The optional 2nd line of the street.'
    )
    city: constr(min_length=1) = Field(..., description='The city of the address.')
    state: constr(min_length=1) = Field(..., description='The state of the address.')
    country: constr(min_length=1) = Field(
        ..., description='The country of the address.'
    )
    postal_code: constr(min_length=1) = Field(
        ..., alias='postalCode', description='The postal code of the address.'
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description='Indicates if the address is the main address. Only one address can be the main address.',
    )


class InstantMessenger(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The type of instant messaging system being used for the contact (Skype, Zoom, etc).',
    )
    user_name: constr(min_length=1) = Field(
        ...,
        alias='userName',
        description="The carrier contact's instant-messaging username. If a service type is indicated then a username must be provided.",
    )


class Contact(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The type of carrier contact would be displayed (e.g., Billing, Claims, Dispatch, etc).',
    )
    name: constr(min_length=1) = Field(
        ...,
        description="This is where a carrier contact's first and last name will be displayed.",
    )
    email_address: Optional[EmailStr] = Field(
        None,
        alias='emailAddress',
        description='The email address of the carrier contact. Will be used to identify recipient of manual/automatic tendering, billing information, etc.',
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None, alias='phoneNumber', description='The carrier contact phone number.'
    )
    extension: Optional[str] = Field(
        None, description='The phone extension for the carrier contact.'
    )
    fax_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(None, alias='faxNumber', description='The carrier contact fax number.')
    is_main: Optional[bool] = Field(
        None,
        alias='isMain',
        description='This indicates if the contact is the main contact for the carrier record.',
    )
    instant_messenger: Optional[InstantMessenger] = Field(
        None,
        alias='instantMessenger',
        description='Instant messenger object for the carrier contact.',
    )


class Identifier(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The carrier identifier `Type`. Expects a value based on `Carrier Identifier Type` configuration.',
    )
    value: constr(min_length=1) = Field(
        ..., description='The uniqueID for the identifier (alpha or numerical).'
    )
    link: Optional[str] = Field(
        None, description='The corresponding URL for the type of carrier identifier.'
    )


class Insurance(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description="This is where the carrier's insurance type will be displayed. Required field within carrier record before assigning a carrier.",
    )
    effective_date: date = Field(
        ...,
        alias='effectiveDate',
        description="This is where the policy start date of carrier's insurance policy would be displayed. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.",
    )
    expiration_date: date = Field(
        ...,
        alias='expirationDate',
        description="This is where the policy end date of carrier's insurance policy would be displayed. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.",
    )
    identification: constr(min_length=1) = Field(
        ...,
        description="This is where a carrier's insurance policy number would be displayed.",
    )
    insurer: constr(min_length=1) = Field(
        ...,
        description="This is where a carrier's underwrite company name would be displayed.",
    )
    limit: conint(ge=1) = Field(
        ...,
        description="This is where a carrier's insurance coverage amount would be displayed.",
    )
    producer: constr(min_length=1) = Field(
        ...,
        description="This is where a carrier's insurance agent name would be displayed.",
    )
    exemptions: Optional[str] = Field(
        None,
        description='This is where a user would free form text any application exemptions (High Value Overrides, etc).',
    )
    cancellation_date: Optional[date] = Field(
        None,
        alias='cancellationDate',
        description="This is where the carrier's insurance cancellation date is indicated.",
    )
    insurers_am_best_rating_type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='insurersAmBestRatingTypeTerm',
        description='The AM best rating of the insurance company used by the carrier (i.e. A, A+, B-, C, etc).',
    )


class Rep(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of rep based on their job duties. Data Dictionary Term.',
    )
    employee_code: constr(min_length=1) = Field(
        ...,
        alias='employeeCode',
        description="A unique ID exposed on the UI that can be searched within the TMS. This can also be used a reference ID to a client's legacy system where B2B integrations are in place.",
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description="This is where a user can indicate an individual carrier rep's alignment to a carrier (Carrier reps can `Sponsor` a carrier and would be displayed as `Main`).  Only 1 main user allowed.",
    )
    is_load: Optional[bool] = Field(
        None, alias='isLoad', description='Indicates if the carrier rep handles loads.'
    )
    mode_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='modeTerm',
        description='The transportation mode the carrier rep handles (i.e. Truck, Rail, etc).',
    )
    size_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='sizeTerm',
        description='The load size the carrier rep handles (i.e. FTL, LTL).',
    )
    direction_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='directionTerm',
        description='The direction of loads the rep handles (i.e. Inbound).',
    )


class Certification(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ..., alias='typeTerm', description='The type of certification (i.e. Hazmat).'
    )
    expiration_date: Optional[date] = Field(
        None,
        alias='expirationDate',
        description='This is where the expiration date of the certification would be displayed. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.',
    )
    notes: Optional[str] = Field(
        None, description='Any notes associated with the certification.'
    )


class Service(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The type of special service the carrier can offer.',
    )
    notes: Optional[str] = Field(
        None, description='Any notes associated with the special service.'
    )


class ElectronicTracking(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The type of electronic tracking system being used by the carrier (i.e. Truckstop, MacroPoint).',
    )
    method_term: constr(min_length=1) = Field(
        ...,
        alias='methodTerm',
        description='The method of tracking for the electronic system (i.e. Driver Cell, ELD).',
    )


class Geography(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: constr(min_length=1) = Field(
        ..., description='The country the carrier is operating.'
    )
    states: List[constr(min_length=1)] = Field(
        ..., description='The states of the country the carrier is operating.'
    )


class GeographySettings(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    intrastates: Optional[List[constr(min_length=1)]] = Field(
        None,
        description='A list of states where the carrier can only do intrastate business.',
    )
    geographies: Optional[List[Geography]] = Field(
        None,
        description='An object of geography the carrier can do business. Must provide country and state if geographies are being tracked for the carrier.',
    )


class TypeTerm1(Enum):
    phone = 'phone'
    email = 'email'
    web = 'web'


class TypeTerm2(RootModel[None]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: None = Field(
        None, description='The type of manual tracking method (i.e. Email, Phone, Web).'
    )


class ManualTracking(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: Optional[Union[TypeTerm1, TypeTerm2]] = Field(
        None,
        alias='typeTerm',
        description='The type of manual tracking method (i.e. Email, Phone, Web).',
    )
    information: Optional[str] = Field(
        None,
        description='The corresponding information related to the manual tracking type.',
    )


class CarriersPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=2) = Field(
        ...,
        description='A unique ID exposed on the UI that can be searched throughout the TMS.',
    )
    website: Optional[str] = Field(
        None, description="This will indicate the carrier's website."
    )
    name: constr(min_length=1) = Field(
        ...,
        description='A name exposed on the UI that can be searched throughout the TMS.',
    )
    dba_name: Optional[str] = Field(
        None,
        alias='dbaName',
        description="This is where a carrier's `doing business as` name will be displayed. Often used within carrier names registered with the DOT.",
    )
    internal_status: Optional[InternalStatus] = Field(
        None,
        alias='internalStatus',
        description='Tracks the internal MasterMind status of the carrier.',
    )
    type_term: TypeTerm = Field(
        ...,
        alias='typeTerm',
        description='The type of carrier (carrier, vendor, etc.).',
    )
    dot_number: Optional[str] = Field(
        None,
        alias='dotNumber',
        description="The carrier's DOT number for tracking purposes.",
    )
    level_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='levelTerm',
        description="This is where a carrier's `Tier` would be displayed (based on service, fleet size, insurance coverage, etc. - key value types client defined upon implementation).",
    )
    mc_number: Optional[str] = Field(
        None,
        alias='mcNumber',
        description="The carrier's MC number for tracking purposes.",
    )
    notes: Optional[str] = Field(
        None,
        description='This is where free form text entered by a user will be displayed.',
    )
    opportunity_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='opportunityTerm',
        description="This is where a carrier's `Opportunity` level will be displayed. Opportunity determined by fleet size, insurance coverage, loads booked by carrier rep, etc. (client defined). Value based on `Carrier Opportunity` value configuration.",
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='phoneNumber',
        description='This is where a carrier phone number would be displayed under general information.',
    )
    scac_number: Optional[str] = Field(
        None,
        alias='scacNumber',
        description='This is where a carrier SCAC would be displayed in the TMS.',
    )
    parent_carrier_code: Optional[str] = Field(
        None,
        alias='parentCarrierCode',
        description='This is the parent company of the carrier, if needed for payment.',
    )
    voucher_settings: Optional[VoucherSettings] = Field(
        None,
        alias='voucherSettings',
        description='An object with the carrier voucher preferences when receiving payment.',
    )
    organization: Optional[Union[Organization, Organization1, Organization2]] = Field(
        None,
        description='The organization record the carrier record is associated with.',
    )
    addresses: List[Address] = Field(
        ...,
        description='A collection of addresses associated with the carrier. At least one address is required.',
        min_length=1,
    )
    contacts: Optional[List[Contact]] = Field(
        None,
        description='A collection of contacts associated with the carrier. Contacts are not required.',
    )
    identifiers: Optional[List[Identifier]] = Field(
        None,
        description='A collection of keys associated with the carrier to identify them throughout the TMS. Identifiers are not required.',
    )
    insurances: Optional[List[Insurance]] = Field(
        None,
        description='A collection of insurance coverages that are maintained by the carrier. Insurance is not required for carrier creation only booking.',
    )
    reps: Optional[List[Rep]] = Field(
        None, description='A collection of employees associated with the carrier.'
    )
    certifications: Optional[List[Certification]] = Field(
        None, description='A collection of certifications and expiration dates.'
    )
    services: Optional[List[Service]] = Field(
        None,
        description='A collection of special services the carrier offers such as drayage or retail.',
    )
    electronic_tracking: Optional[ElectronicTracking] = Field(
        None,
        alias='electronicTracking',
        description='The electronic tracking method associated with the carrier.',
    )
    geography_settings: Optional[GeographySettings] = Field(
        None,
        alias='geographySettings',
        description='The types of geographies the carrier can do business.',
    )
    manual_tracking: Optional[ManualTracking] = Field(
        None,
        alias='manualTracking',
        description="A collection of manual tracking methods a carrier is using to track the carrier's drivers or assets during a route.",
    )
    main_compliance_email: Optional[str] = Field(
        None,
        alias='mainComplianceEmail',
        description='The main compliance email for the carrier.',
    )
    authorized_division_terms: Optional[List[str]] = Field(
        None,
        alias='authorizedDivisionTerms',
        description='The divisions authorized to utilize the carrier.',
    )
    is_bin_qualified: Optional[bool] = Field(
        None,
        alias='isBinQualified',
        description='When a load is booked via 3rd party, the BIN functionality will place a lock on the load in MasterMind, book the carrier in MasterMind, and send the carrier a rate confirmation.',
    )
    rating_based_on_term: Optional[str] = Field(
        None,
        alias='ratingBasedOnTerm',
        description='The setting that determines which date is used when matching to carrier cost quotes.',
    )


class InternalStatus1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    status_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='statusTerm',
        description='The carrier status to indicate if it can be used within MasterMind. The status will determine if certain operations in the TMS system can use the carrier record.',
    )
    reason_code_term: Optional[str] = Field(
        None,
        alias='reasonCodeTerm',
        description='Explains further why the carrier record is in the current internal status.',
    )
    notes: Optional[str] = Field(
        None, description='Free-form note about the internal status.'
    )


class TypeTerm3(Enum):
    phone = 'phone'
    email = 'email'
    web = 'web'


class ManualTracking1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: Optional[TypeTerm3] = Field(
        None,
        alias='typeTerm',
        description='The type of manual tracking method (i.e. Email, Phone, Web).',
    )
    information: Optional[str] = Field(
        None,
        description='The corresponding information related to the manual tracking type.',
    )


class TypeTerm4(Enum):
    carrier = 'carrier'
    factor = 'factor'
    vendor = 'vendor'
    fleet = 'fleet'


class RemittanceGroupingTerm2(Enum):
    route = 'Route'


class RemittanceGroupingTerm3(RootModel[None]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: None = Field(
        None,
        description='This will designate how remittance payments will be grouped (i.e. by route).',
    )


class VoucherSettings1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    payment_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='paymentTerm',
        description='The payment terms of a carrier (e.g., Net 20, Net 30, etc).',
    )
    payment_method_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='paymentMethodTerm',
        description="The carrier's preferred payment method (i.e. check, EFT).",
    )
    currency_code_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='currencyCodeTerm',
        description="The carrier's payment currency (i.e. USD, CAN, etc.).",
    )
    voucher_method_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='voucherMethodTerm',
        description="The delivery method for the carrier's voucher (i.e. Email, Print).",
    )
    remittance_to_carrier_code: Optional[str] = Field(
        None,
        alias='remittanceToCarrierCode',
        description='The external code of a separate carrier that should be referenced for remittance payments.',
    )
    remittance_to_email: Optional[EmailStr] = Field(
        None,
        alias='remittanceToEmail',
        description='The email address to use for remittance payments.',
    )
    remittance_grouping_term: Optional[
        Union[RemittanceGroupingTerm2, RemittanceGroupingTerm3]
    ] = Field(
        None,
        alias='remittanceGroupingTerm',
        description='This will designate how remittance payments will be grouped (i.e. by route).',
    )


class Address1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined unique identifier for a address record.',
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this address should be destroyed.',
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='The type of address for the carrier (i.e. Billing, Remittance).',
    )
    street1: Optional[constr(min_length=1)] = Field(
        None, description='The street name and number of the address.'
    )
    street2: Optional[str] = Field(
        None, description='The optional 2nd line of the street.'
    )
    city: Optional[constr(min_length=1)] = Field(
        None, description='The city of the address.'
    )
    state: Optional[constr(min_length=1)] = Field(
        None, description='The state of the address.'
    )
    country: Optional[constr(min_length=1)] = Field(
        None, description='The country of the address.'
    )
    postal_code: Optional[constr(min_length=1)] = Field(
        None, alias='postalCode', description='The postal code of the address.'
    )
    is_main: Optional[bool] = Field(
        None,
        alias='isMain',
        description='Indicates if the address is the main address. Only one address can be the main address.',
    )


class InstantMessenger1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='The type of instant messaging system being used for the contact (Skype, Zoom, etc).',
    )
    user_name: Optional[constr(min_length=1)] = Field(
        None,
        alias='userName',
        description="The carrier contact's instant-messaging username. If a service type is indicated then a username must be provided.",
    )


class Contact1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined unique identifier for a contact record.',
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this contact should be destroyed.',
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='The type of carrier contact would be displayed (e.g., Billing, Claims, Dispatch, etc).',
    )
    name: Optional[constr(min_length=1)] = Field(
        None,
        description="This is where a carrier contact's first and last name will be displayed.",
    )
    email_address: Optional[EmailStr] = Field(
        None,
        alias='emailAddress',
        description='The email address of the carrier contact. Will be used to identify recipient of manual/automatic tendering, billing information, etc.',
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None, alias='phoneNumber', description='The carrier contact phone number.'
    )
    extension: Optional[str] = Field(
        None, description='The phone extension for the carrier contact.'
    )
    fax_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(None, alias='faxNumber', description='The carrier contact fax number.')
    is_main: Optional[bool] = Field(
        None,
        alias='isMain',
        description='This indicates if the contact is the main contact for the carrier record.',
    )
    instant_messenger: Optional[InstantMessenger1] = Field(
        None,
        alias='instantMessenger',
        description='Instant messenger object for the carrier contact.',
    )


class Identifier1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined unique identifier for a identifier record.',
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this identifier should be destroyed.',
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='The carrier identifier `Type`. Expects a value based on `Carrier Identifier Type` configuration.',
    )
    value: Optional[constr(min_length=1)] = Field(
        None, description='The uniqueID for the identifier (alpha or numerical).'
    )
    link: Optional[str] = Field(
        None, description='The corresponding URL for the type of carrier identifier.'
    )


class Insurance1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined unique identifier for a insurance record.',
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this insurance should be destroyed.',
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description="This is where the carrier's insurance type will be displayed. Required field within carrier record before assigning a carrier.",
    )
    effective_date: Optional[date] = Field(
        None,
        alias='effectiveDate',
        description="This is where the policy start date of carrier's insurance policy would be displayed. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.",
    )
    expiration_date: Optional[date] = Field(
        None,
        alias='expirationDate',
        description="This is where the policy end date of carrier's insurance policy would be displayed. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.",
    )
    identification: Optional[constr(min_length=1)] = Field(
        None,
        description="This is where a carrier's insurance policy number would be displayed (UniqueID).",
    )
    insurer: Optional[constr(min_length=1)] = Field(
        None,
        description="This is where a carrier's underwrite company name would be displayed.",
    )
    limit: Optional[conint(ge=1, le=2147483647999)] = Field(
        None,
        description="This is where a carrier's insurance coverage amount would be displayed.",
    )
    producer: Optional[constr(min_length=1)] = Field(
        None,
        description="This is where a carrier's insurance agent name would be displayed.",
    )
    exemptions: Optional[str] = Field(
        None,
        description='This is where a user would free form text any application exemptions (High Value Overrides, etc).',
    )
    cancellation_date: Optional[date] = Field(
        None,
        alias='cancellationDate',
        description="This is where the carrier's insurance cancellation date is indicated.",
    )
    insurers_am_best_rating_type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='insurersAmBestRatingTypeTerm',
        description='The AM best rating of the insurance company used by the carrier (i.e. A, A+, B-, C, etc).',
    )


class Rep1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined unique identifier for a rep record.'
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this rep should be destroyed.',
    )
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The type of rep based on their job duties. Data Dictionary Term.',
    )
    employee_code: Optional[constr(min_length=1)] = Field(
        None,
        alias='employeeCode',
        description="A unique ID exposed on the UI that can be searched within the TMS. This can also be used a reference ID to a client's legacy system where B2B integrations are in place.",
    )
    is_main: Optional[bool] = Field(
        None,
        alias='isMain',
        description="This is where a user can indicate an individual carrier rep's alignment to a carrier (Carrier reps can `Sponsor` a carrier and would be displayed as `Main`).  Only 1 main user allowed.",
    )
    is_load: Optional[bool] = Field(
        None, alias='isLoad', description='Indicates if the carrier rep handles loads.'
    )
    mode_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='modeTerm',
        description='The transportation mode the carrier rep handles (i.e. Truck, Rail, etc).',
    )
    size_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='sizeTerm',
        description='The load size the carrier rep handles (i.e. FTL, LTL).',
    )
    direction_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='directionTerm',
        description='The direction of loads the rep handles (i.e. Inbound).',
    )


class Certification1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined unique identifier for a certification record.',
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this certification should be destroyed.',
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None, alias='typeTerm', description='The type of certification (i.e. Hazmat).'
    )
    expiration_date: Optional[date] = Field(
        None,
        alias='expirationDate',
        description='This is where the expiration date of the certification would be displayed. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.',
    )
    notes: Optional[str] = Field(
        None, description='Any notes associated with the certification.'
    )


class Service1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined unique identifier for a service record.',
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this service should be destroyed.',
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='The type of special service the carrier can offer.',
    )
    notes: Optional[str] = Field(
        None, description='Any notes associated with the special service.'
    )


class ElectronicTracking1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='The type of electronic tracking system being used by the carrier (i.e. Truckstop, MacroPoint).',
    )
    method_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='methodTerm',
        description='The method of tracking for the electronic system (i.e. Driver Cell, ELD).',
    )


class GeographySettings1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    intrastates: Optional[List[constr(min_length=1)]] = Field(
        None,
        description='A list of states where the carrier can only do intrastate business.',
    )
    geographies: Optional[List[Geography]] = Field(
        None,
        description='An object of geography the carrier can do business. Must provide country and state if geographies are being tracked for the carrier.',
    )


class CarriersCarrierCodePATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: Optional[str] = Field(
        None,
        description='A name exposed on the UI that can be searched throughout the TMS.',
    )
    dba_name: Optional[str] = Field(
        None,
        alias='dbaName',
        description="This is where a carrier's `doing business as` name will be displayed. Often used within carrier names registered with the DOT.",
    )
    website: Optional[str] = Field(
        None, description="This will indicate the carrier's website."
    )
    internal_status: Optional[InternalStatus1] = Field(
        None,
        alias='internalStatus',
        description='Tracks the internal MasterMind status of the carrier.',
    )
    manual_tracking: Optional[ManualTracking1] = Field(
        None,
        alias='manualTracking',
        description="A collection of manual tracking methods a carrier is using to track the carrier's drivers or assets during a route.",
    )
    main_compliance_email: Optional[str] = Field(
        None,
        alias='mainComplianceEmail',
        description='The main compliance email for the carrier.',
    )
    authorized_division_terms: Optional[List[str]] = Field(
        None,
        alias='authorizedDivisionTerms',
        description='The divisions authorized to utilize the carrier.',
    )
    type_term: Optional[TypeTerm4] = Field(
        None,
        alias='typeTerm',
        description='The type of carrier (carrier, vendor, etc.).',
    )
    dot_number: Optional[str] = Field(
        None,
        alias='dotNumber',
        description="The carrier's DOT number for tracking purposes.",
    )
    level_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='levelTerm',
        description="This is where a carrier's `Tier` would be displayed (based on service, fleet size, insurance coverage, etc. - key value types client defined upon implementation).",
    )
    mc_number: Optional[str] = Field(
        None,
        alias='mcNumber',
        description="The carrier's MC number for tracking purposes.",
    )
    notes: Optional[str] = Field(
        None,
        description='This is where free form text entered by a user will be displayed.',
    )
    opportunity_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='opportunityTerm',
        description="This is where a carrier's `Opportunity` level will be displayed. Opportunity determined by fleet size, insurance coverage, loads booked by carrier rep, etc. (client defined). Value based on `Carrier Opportunity` value configuration.",
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='phoneNumber',
        description='This is where a carrier phone number would be displayed under general information.',
    )
    scac_number: Optional[str] = Field(
        None,
        alias='scacNumber',
        description='This is where a carrier SCAC would be displayed in the TMS.',
    )
    parent_carrier_code: Optional[str] = Field(
        None,
        alias='parentCarrierCode',
        description='This is the parent company of the carrier, if needed for payment.',
    )
    is_bin_qualified: Optional[bool] = Field(
        None,
        alias='isBinQualified',
        description='When a load is booked via 3rd party, the BIN functionality will place a lock on the load in MasterMind, book the carrier in MasterMind, and send the carrier a rate confirmation.',
    )
    voucher_settings: Optional[VoucherSettings1] = Field(
        None,
        alias='voucherSettings',
        description='An object with the carrier voucher preferences when receiving payment.',
    )
    addresses: Optional[List[Address1]] = Field(
        None,
        description='A collection of addresses associated with the carrier. At least one address is required.',
    )
    contacts: Optional[List[Contact1]] = Field(
        None,
        description='A collection of contacts associated with the carrier. Contacts are not required.',
    )
    identifiers: Optional[List[Identifier1]] = Field(
        None,
        description='A collection of keys associated with the carrier to identify them throughout the TMS. Identifiers are not required.',
    )
    insurances: Optional[List[Insurance1]] = Field(
        None,
        description='A collection of insurance coverages that are maintained by the carrier. Insurance is not required for carrier creation only booking.',
    )
    reps: Optional[List[Rep1]] = Field(
        None, description='A collection of employees associated with the carrier.'
    )
    certifications: Optional[List[Certification1]] = Field(
        None, description='A collection of certifications and expiration dates.'
    )
    services: Optional[List[Service1]] = Field(
        None, description='A collection of special services the carrier offers.'
    )
    electronic_tracking: Optional[ElectronicTracking1] = Field(
        None,
        alias='electronicTracking',
        description='The electronic tracking method associated with the carrier.',
    )
    geography_settings: Optional[GeographySettings1] = Field(
        None,
        alias='geographySettings',
        description='The types of geographies the carrier can do business.',
    )
    rating_based_on_term: Optional[str] = Field(
        None,
        alias='ratingBasedOnTerm',
        description='The setting that determines which date is used when matching to carrier cost quotes.',
    )


class CarriersCarrierCodeaddressesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The type of address for the carrier (i.e. Billing, Remittance).',
    )
    street1: constr(min_length=1) = Field(
        ..., description='The street name and number of the address.'
    )
    street2: Optional[str] = Field(
        None, description='The optional 2nd line of the street.'
    )
    city: constr(min_length=1) = Field(..., description='The city of the address.')
    state: constr(min_length=1) = Field(..., description='The state of the address.')
    country: constr(min_length=1) = Field(
        ..., description='The country of the address.'
    )
    postal_code: constr(min_length=1) = Field(
        ..., alias='postalCode', description='The postal code of the address.'
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description='Indicates if the address is the main address. Only one address can be the main address.',
    )


class CarriersCarrierCodeaddressesAddressIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The type of address for the carrier (i.e. Billing, Remittance).',
    )
    street1: constr(min_length=1) = Field(
        ..., description='The street name and number of the address.'
    )
    street2: Optional[str] = Field(
        None, description='The optional 2nd line of the street.'
    )
    city: constr(min_length=1) = Field(..., description='The city of the address.')
    state: constr(min_length=1) = Field(..., description='The state of the address.')
    country: constr(min_length=1) = Field(
        ..., description='The country of the address.'
    )
    postal_code: constr(min_length=1) = Field(
        ..., alias='postalCode', description='The postal code of the address.'
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description='Indicates if the address is the main address. Only one address can be the main address.',
    )


class CarriersCarrierCodecertificationsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ..., alias='typeTerm', description='The type of certification (i.e. Hazmat).'
    )
    expiration_date: Optional[date] = Field(
        None,
        alias='expirationDate',
        description='This is where the expiration date of the certification would be displayed. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.',
    )
    notes: Optional[str] = Field(
        None, description='Any notes associated with the certification.'
    )


class CarriersCarrierCodecertificationsCertificationIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ..., alias='typeTerm', description='The type of certification (i.e. Hazmat).'
    )
    expiration_date: Optional[date] = Field(
        None,
        alias='expirationDate',
        description='This is where the expiration date of the certification would be displayed. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.',
    )
    notes: Optional[str] = Field(
        None, description='Any notes associated with the certification.'
    )


class InstantMessenger2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The type of instant messaging system being used for the contact (Skype, Zoom, etc).',
    )
    user_name: constr(min_length=1) = Field(
        ...,
        alias='userName',
        description="The carrier contact's instant-messaging username. If a service type is indicated then a username must be provided.",
    )


class CarriersCarrierCodecontactsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The type of carrier contact would be displayed (e.g., Billing, Claims, Dispatch, etc).',
    )
    name: constr(min_length=1) = Field(
        ...,
        description="This is where a carrier contact's first and last name will be displayed.",
    )
    email_address: Optional[EmailStr] = Field(
        None,
        alias='emailAddress',
        description='The email address of the carrier contact. Will be used to identify recipient of manual/automatic tendering, billing information, etc.',
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None, alias='phoneNumber', description='The carrier contact phone number.'
    )
    extension: Optional[str] = Field(
        None, description='The phone extension for the carrier contact.'
    )
    fax_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(None, alias='faxNumber', description='The carrier contact fax number.')
    is_main: Optional[bool] = Field(
        None,
        alias='isMain',
        description='This indicates if the contact is the main contact for the carrier record.',
    )
    instant_messenger: Optional[InstantMessenger2] = Field(
        None,
        alias='instantMessenger',
        description='Instant messenger object for the carrier contact.',
    )


class CarriersCarrierCodecontactsContactIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The type of carrier contact would be displayed (e.g., Billing, Claims, Dispatch, etc).',
    )
    name: constr(min_length=1) = Field(
        ...,
        description="This is where a carrier contact's first and last name will be displayed.",
    )
    email_address: Optional[EmailStr] = Field(
        None,
        alias='emailAddress',
        description='The email address of the carrier contact. Will be used to identify recipient of manual/automatic tendering, billing information, etc.',
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None, alias='phoneNumber', description='The carrier contact phone number.'
    )
    extension: Optional[str] = Field(
        None, description='The phone extension for the carrier contact.'
    )
    fax_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(None, alias='faxNumber', description='The carrier contact fax number.')
    is_main: Optional[bool] = Field(
        None,
        alias='isMain',
        description='This indicates if the contact is the main contact for the carrier record.',
    )
    instant_messenger: Optional[InstantMessenger2] = Field(
        None,
        alias='instantMessenger',
        description='Instant messenger object for the carrier contact.',
    )


class Location(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city: constr(min_length=1) = Field(
        ..., description='The city of the origin location.'
    )
    state: constr(min_length=2, max_length=2) = Field(
        ..., description='The state of the origin location.'
    )
    postal_code: Optional[str] = Field(
        None, alias='postalCode', description='The postal code of the origin location.'
    )
    country: constr(min_length=2, max_length=2) = Field(
        ..., description='The country of the origin location.'
    )


class Facility(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally-defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally-defined code for the facility.'
    )


class Origin(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    location: Optional[Location] = Field(
        None, description='The location of the origin information.'
    )
    facility: Optional[Facility] = Field(
        None, description='The facility of the origin.'
    )


class Location1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city: constr(min_length=1) = Field(
        ..., description='The city of the destination location.'
    )
    state: constr(min_length=2, max_length=2) = Field(
        ..., description='The state of the destination location.'
    )
    postal_code: Optional[str] = Field(
        None,
        alias='postalCode',
        description='The postal code of the destination location.',
    )
    country: constr(min_length=2, max_length=2) = Field(
        ..., description='The country of the destination location.'
    )


class PreferredState(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    state: constr(min_length=2, max_length=2) = Field(
        ..., description='The state of the destination states.'
    )
    country: constr(min_length=2, max_length=2) = Field(
        ..., description='The country of the destination states.'
    )


class Destination(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    location: Optional[Location1] = Field(
        None, description='The location of the destination information.'
    )
    facility: Optional[Facility] = Field(
        None, description='The facility of the destination.'
    )
    preferred_states: Optional[List[PreferredState]] = Field(
        None,
        alias='preferredStates',
        description='The destination states of the capacity.',
    )


class DestinationState(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: constr(min_length=2, max_length=2) = Field(
        ..., description='The country of the destination states.'
    )
    state: constr(min_length=2, max_length=2) = Field(
        ..., description='The states of the destination states.'
    )


class UnitTerm(Enum):
    ft = 'ft'
    in_ = 'in'
    m = 'm'
    km = 'km'
    mi = 'mi'


class OriginDeadhead(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    unit_term: UnitTerm = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement of the origin dead head.',
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value of the origin dead head.'
    )


class DestinationDeadhead(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    unit_term: UnitTerm = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement if the destination dead head.',
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value of the destination dead head.'
    )


class Driver(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    driver_name: constr(min_length=1) = Field(
        ..., alias='driverName', description='The name of the driver.'
    )
    mobile_phone: constr(
        pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$',
        min_length=1,
    ) = Field(
        ..., alias='mobilePhone', description='The mobile phone number of the driver.'
    )


class Tractor(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    number: Optional[str] = Field(None, description='The number of the Tractor.')


class Carrier(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    drivers: Optional[List[Driver]] = Field(
        None, description='The driver of the carrier with the carrier type of carrier.'
    )
    tractor: Optional[Tractor] = Field(None, description='The tractor of the capacity.')


class Driver1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally-defined UUID of the driver.'
    )
    code: Optional[str] = Field(
        None, description='The externally-defined code of the driver.'
    )
    drive_time: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None, alias='driveTime', description='The drive time of the driver.'
    )
    shift_time: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None, alias='shiftTime', description='The shift time of the driver.'
    )
    cycle_time: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None, alias='cycleTime', description='The cycle time of the driver.'
    )


class Tractor1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally-defined UUID of the tractor.'
    )
    code: Optional[str] = Field(
        None, description='The externally-defined code of the tractor.'
    )


class Fleet(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    drivers: Optional[List[Driver1]] = Field(
        None, description='The driver of the carrier with the carrier type of fleet.'
    )
    tractor: Optional[Tractor1] = Field(
        None, description='The tractor of the capacity.'
    )


class Length(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value of the length of the trailer.'
    )
    unit_term: UnitTerm = Field(
        ..., alias='unitTerm', description='The unit for the length of the trailer.'
    )


class Owner(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='An internally-defined UUID referencing the carrier who owns the trailer.',
    )
    code: Optional[str] = Field(
        None,
        description='The externally-defined code referencing the carrier who owns the trailer.',
    )


class Trailer(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='An internally-defined UUID referencing the trailer.'
    )
    code: Optional[str] = Field(
        None, description='The externally-defined code for the trailer.'
    )
    number: Optional[str] = Field(
        None, description='The trailer number for the trailer.'
    )
    type_term: str = Field(..., alias='typeTerm', description='The type of trailer.')
    length: Optional[Length] = Field(None, description='The length of the trailer.')
    owner: Optional[Owner] = Field(None, description='The owner of the trailer.')


class PreviousRoute(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally-defined UUID of the route.'
    )
    number: Optional[str] = Field(
        None, description='The externally-defined number of the route.'
    )


class Tarp(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    count: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ..., description='The count of the tarp(s).'
    )
    type_term: str = Field(
        ..., alias='typeTerm', description='The type term of the tarp(s).'
    )


class Bracing(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_terms: List[str] = Field(
        ..., alias='typeTerms', description='The type term(s) of the bracing.'
    )
    count: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ..., description='The total count of the bracing.'
    )


class Pallet(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    count: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ..., description='The count of the pallet(s).'
    )
    type_terms: str = Field(
        ..., alias='typeTerms', description='The type term of the pallet(s).'
    )


class CarriersCarrierCodedriverCapacityPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally-defined code for the capacity.'
    )
    origin: Origin = Field(
        ..., description='The origin information of the capacity.', title='Origin'
    )
    destination: Optional[Destination] = Field(
        None, description='The destination information of the capacity.'
    )
    destination_states: Optional[List[DestinationState]] = Field(
        None,
        alias='destinationStates',
        description='The destination states of the capacity.',
    )
    origin_deadhead: OriginDeadhead = Field(
        ...,
        alias='originDeadhead',
        description='The origin dead head of this capacity.',
        title='OriginDeadhead',
    )
    destination_deadhead: Optional[DestinationDeadhead] = Field(
        None,
        alias='destinationDeadhead',
        description='The destination dead head of this capacity.',
    )
    ready_date_time: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        alias='readyDateTime',
        description='When the truck will be ready. Unix timestamp (in milliseconds).',
    )
    load_by_date_time: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='loadByDateTime',
        description='The latest date this truck is available until. Unix timestamp (in milliseconds).',
    )
    final_by_date_time: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='finalByDateTime',
        description='Datetime used to restrict truck matching for final delivery date. Unix timestamp (in milliseconds).',
    )
    is_hazmat: Optional[bool] = Field(
        None, alias='isHazmat', description='The hazmat designation for the driver.'
    )
    is_team: Optional[bool] = Field(
        None, alias='isTeam', description='The team designation for the driver.'
    )
    carrier: Optional[Carrier] = Field(
        None,
        description='The driver, tractor, and trailer information for the carrier type carrier of the capacity.',
    )
    fleet: Optional[Fleet] = Field(
        None,
        description='The driver, tractor, and trailer information for the fleet type carrier of the capacity.',
    )
    trailer: Trailer = Field(
        ..., description='The trailer for the capacity.', title='Trailer'
    )
    notes: Optional[str] = Field(
        None, description='The notes associated to the capacity.'
    )
    previous_route: Optional[PreviousRoute] = Field(
        None,
        alias='previousRoute',
        description='The previous route of the capacity record.',
    )
    tarp: Optional[Tarp] = Field(
        None, description='The tarp accessory associated to the capacity.'
    )
    bracing: Optional[Bracing] = Field(
        None, description='The bracing accessory associated to the capacity.'
    )
    pallet: Optional[Pallet] = Field(
        None, description='The pallet accessory associated to the capacity.'
    )


class Location2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city: Optional[str] = Field(None, description='The city of the origin location.')
    state: Optional[str] = Field(None, description='The state of the origin location.')
    postal_code: Optional[str] = Field(
        None, alias='postalCode', description='The postal code of the origin location.'
    )
    country: Optional[str] = Field(
        None, description='The country of the origin location.'
    )


class Origin1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    location: Optional[Location2] = Field(
        None, description='The location of the origin information.'
    )
    facility: Optional[Facility] = Field(
        None, description='The facility of the origin.'
    )


class Location3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city: Optional[str] = Field(
        None, description='The city of the destination location.'
    )
    state: Optional[str] = Field(
        None, description='The state of the destination location.'
    )
    postal_code: Optional[str] = Field(
        None,
        alias='postalCode',
        description='The postal code of the destination location.',
    )
    country: Optional[str] = Field(
        None, description='The country of the destination location.'
    )


class PreferredState1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    state: constr(min_length=2, max_length=2) = Field(
        ..., description='The states of the destination states.'
    )
    country: constr(min_length=2, max_length=2) = Field(
        ..., description='The country of the destination states.'
    )


class Destination1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    location: Optional[Location3] = Field(
        None, description='The location of the destination information.'
    )
    facility: Optional[Facility] = Field(
        None, description='The facility of the destination.'
    )
    preferred_states: Optional[List[PreferredState1]] = Field(
        None,
        alias='preferredStates',
        description='The destination states of the capacity.',
    )


class OriginDeadhead1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    unit_term: UnitTerm = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement of the origin dead head.',
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value of the origin dead head.'
    )


class DestinationDeadhead1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    unit_term: UnitTerm = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement if the destination dead head.',
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value of the destination dead head.'
    )


class Driver2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    driver_name: constr(min_length=1) = Field(
        ..., alias='driverName', description='The name of the driver.'
    )
    mobile_phone: constr(
        pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$',
        min_length=1,
    ) = Field(
        ..., alias='mobilePhone', description='The mobile phone number of the driver.'
    )


class Tractor2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    number: Optional[str] = Field(None, description='The number of the Tractor.')


class Carrier1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    drivers: Optional[List[Driver2]] = Field(
        None, description='The driver of the carrier with the carrier type of carrier.'
    )
    tractor: Optional[Tractor2] = Field(
        None, description='The tractor of the capacity.'
    )


class Driver3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally-defined UUID of the driver.'
    )
    code: Optional[str] = Field(
        None, description='The externally-defined code of the driver.'
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if the driver should be destroyed.',
    )
    drive_time: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None, alias='driveTime', description='The drive time of the driver.'
    )
    shift_time: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None, alias='shiftTime', description='The shift time of the driver.'
    )
    cycle_time: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None, alias='cycleTime', description='The cycle time of the driver.'
    )


class Tractor3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally-defined UUID of the tractor.'
    )
    code: Optional[str] = Field(
        None, description='The externally-defined code of the tractor.'
    )


class Fleet1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    drivers: Optional[List[Driver3]] = Field(
        None, description='The driver of the carrier with the carrier type of fleet.'
    )
    tractor: Optional[Tractor3] = Field(
        None, description='The tractor of the capacity.'
    )


class Length1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value of the length of the trailer.'
    )
    unit_term: UnitTerm = Field(
        ..., alias='unitTerm', description='The unit for the length of the trailer.'
    )


class Trailer1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='An internally-defined UUID referencing the trailer.'
    )
    code: Optional[str] = Field(
        None, description='The externally-defined code for the trailer.'
    )
    number: Optional[str] = Field(
        None, description='The trailer number for the trailer.'
    )
    type_term: Optional[str] = Field(
        None, alias='typeTerm', description='The type of trailer.'
    )
    length: Optional[Length1] = Field(None, description='The length of the trailer.')
    owner: Optional[Owner] = Field(None, description='The owner of the trailer.')


class CarriersCarrierCodedriverCapacityIdentifierValuePATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    origin: Optional[Origin1] = Field(
        None, description='The origin information of the capacity.'
    )
    destination: Optional[Destination1] = Field(
        None, description='The destination information of the capacity.'
    )
    destination_states: Optional[List[DestinationState]] = Field(
        None,
        alias='destinationStates',
        description='The destination states of the capacity.',
    )
    origin_deadhead: Optional[OriginDeadhead1] = Field(
        None,
        alias='originDeadhead',
        description='The origin dead head of this capacity.',
    )
    destination_deadhead: Optional[DestinationDeadhead1] = Field(
        None,
        alias='destinationDeadhead',
        description='The destination dead head of this capacity.',
    )
    ready_date_time: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='readyDateTime',
        description='When the truck will be ready. Unix timestamp (in milliseconds).',
    )
    load_by_date_time: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='loadByDateTime',
        description='The latest date this truck is available until. Unix timestamp (in milliseconds).',
    )
    final_by_date_time: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='finalByDateTime',
        description='Datetime used to restrict truck matching for final delivery date. Unix timestamp (in milliseconds).',
    )
    is_hazmat: Optional[bool] = Field(
        None, alias='isHazmat', description='The hazmat designation for the driver.'
    )
    is_team: Optional[bool] = Field(
        None, alias='isTeam', description='The team designation for the driver.'
    )
    carrier: Optional[Carrier1] = Field(
        None,
        description='The driver, tractor, and trailer information for the carrier type carrier of the capacity.',
    )
    fleet: Optional[Fleet1] = Field(
        None,
        description='The driver, tractor, and trailer information for the fleet type carrier of the capacity.',
    )
    trailer: Optional[Trailer1] = Field(
        None, description='The trailer for the capacity.'
    )
    notes: Optional[str] = Field(
        None, description='The notes associated to the capacity.'
    )
    previous_route: Optional[PreviousRoute] = Field(
        None,
        alias='previousRoute',
        description='The previous route of the capacity record.',
    )
    tarp: Optional[Tarp] = Field(
        None, description='The tarp accessory associated to the capacity.'
    )
    bracing: Optional[Bracing] = Field(
        None, description='The bracing accessory associated to the capacity.'
    )
    pallet: Optional[Pallet] = Field(
        None, description='The pallet accessory associated to the capacity.'
    )


class CarriersCarrierCodeidentifiersPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The carrier identifier `Type`. Expects a value based on `Carrier Identifier Type` configuration.',
    )
    value: constr(min_length=1) = Field(
        ..., description='The uniqueID for the identifier (alpha or numerical).'
    )
    link: Optional[str] = Field(
        None, description='The corresponding URL for the type of carrier identifier.'
    )


class CarriersCarrierCodeidentifiersIdentifierIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The carrier identifier `Type`. Expects a value based on `Carrier Identifier Type` configuration.',
    )
    value: constr(min_length=1) = Field(
        ..., description='The uniqueID for the identifier (alpha or numerical).'
    )
    link: Optional[str] = Field(
        None, description='The corresponding URL for the type of carrier identifier.'
    )


class CarriersCarrierCodeinsurancesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description="This is where the carrier's insurance type will be displayed. Required field within carrier record before assigning a carrier.",
    )
    effective_date: date = Field(
        ...,
        alias='effectiveDate',
        description="This is where the policy start date of carrier's insurance policy would be displayed. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.",
    )
    expiration_date: date = Field(
        ...,
        alias='expirationDate',
        description="This is where the policy end date of carrier's insurance policy would be displayed. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.",
    )
    identification: constr(min_length=1) = Field(
        ...,
        description="This is where a carrier's insurance policy number would be displayed.",
    )
    insurer: constr(min_length=1) = Field(
        ...,
        description="This is where a carrier's underwrite company name would be displayed.",
    )
    limit: conint(ge=1) = Field(
        ...,
        description="This is where a carrier's insurance coverage amount would be displayed.",
    )
    producer: constr(min_length=1) = Field(
        ...,
        description="This is where a carrier's insurance agent name would be displayed.",
    )
    exemptions: Optional[str] = Field(
        None,
        description='This is where a user would free form text any application exemptions (High Value Overrides, etc).',
    )
    cancellation_date: Optional[date] = Field(
        None,
        alias='cancellationDate',
        description="This is where the carrier's insurance cancellation date is indicated.",
    )
    insurers_am_best_rating_type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='insurersAmBestRatingTypeTerm',
        description='The AM best rating of the insurance company used by the carrier (i.e. A, A+, B-, C, etc).',
    )


class CarriersCarrierCodeinsurancesInsuranceIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description="This is where the carrier's insurance type will be displayed. Required field within carrier record before assigning a carrier.",
    )
    effective_date: date = Field(
        ...,
        alias='effectiveDate',
        description="This is where the policy start date of carrier's insurance policy would be displayed. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.",
    )
    expiration_date: date = Field(
        ...,
        alias='expirationDate',
        description="This is where the policy end date of carrier's insurance policy would be displayed. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.",
    )
    identification: constr(min_length=1) = Field(
        ...,
        description="This is where a carrier's insurance policy number would be displayed.",
    )
    insurer: constr(min_length=1) = Field(
        ...,
        description="This is where a carrier's underwrite company name would be displayed.",
    )
    limit: conint(ge=1) = Field(
        ...,
        description="This is where a carrier's insurance coverage amount would be displayed.",
    )
    producer: constr(min_length=1) = Field(
        ...,
        description="This is where a carrier's insurance agent name would be displayed.",
    )
    exemptions: Optional[str] = Field(
        None,
        description='This is where a user would free form text any application exemptions (High Value Overrides, etc).',
    )
    cancellation_date: Optional[date] = Field(
        None,
        alias='cancellationDate',
        description="This is where the carrier's insurance cancellation date is indicated.",
    )
    insurers_am_best_rating_type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='insurersAmBestRatingTypeTerm',
        description='The AM best rating of the insurance company used by the carrier (i.e. A, A+, B-, C, etc).',
    )


class CarriersCarrierCoderepsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of rep based on their job duties. Data Dictionary Term.',
    )
    employee_code: constr(min_length=1) = Field(
        ...,
        alias='employeeCode',
        description="A unique ID exposed on the UI that can be searched within the TMS. This can also be used a reference ID to a client's legacy system where B2B integrations are in place.",
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description="This is where a user can indicate an individual carrier rep's alignment to a carrier (Carrier reps can `Sponsor` a carrier and would be displayed as `Main`).  Only 1 main user allowed.",
    )
    is_load: Optional[bool] = Field(
        None, alias='isLoad', description='Indicates if the carrier rep handles loads.'
    )
    mode_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='modeTerm',
        description='The transportation mode the carrier rep handles (i.e. Truck, Rail, etc).',
    )
    size_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='sizeTerm',
        description='The load size the carrier rep handles (i.e. FTL, LTL).',
    )
    direction_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='directionTerm',
        description='The direction of loads the rep handles (i.e. Inbound).',
    )


class CarriersCarrierCoderepsRepIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of rep based on their job duties. Data Dictionary Term.',
    )
    employee_code: constr(min_length=1) = Field(
        ...,
        alias='employeeCode',
        description="A unique ID exposed on the UI that can be searched within the TMS. This can also be used a reference ID to a client's legacy system where B2B integrations are in place.",
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description="This is where a user can indicate an individual carrier rep's alignment to a carrier (Carrier reps can `Sponsor` a carrier and would be displayed as `Main`).  Only 1 main user allowed.",
    )
    is_load: Optional[bool] = Field(
        None, alias='isLoad', description='Indicates if the carrier rep handles loads.'
    )
    mode_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='modeTerm',
        description='The transportation mode the carrier rep handles (i.e. Truck, Rail, etc).',
    )
    size_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='sizeTerm',
        description='The load size the carrier rep handles (i.e. FTL, LTL).',
    )
    direction_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='directionTerm',
        description='The direction of loads the rep handles (i.e. Inbound).',
    )


class CarriersCarrierCodeservicesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The type of special service the carrier can offer.',
    )
    notes: Optional[str] = Field(
        None, description='Any notes associated with the special service.'
    )


class CarriersCarrierCodeservicesServiceIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The type of special service the carrier can offer.',
    )
    notes: Optional[str] = Field(
        None, description='Any notes associated with the special service.'
    )


class Organization3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined UUID referencing the organization.'
    )
    name: Optional[constr(min_length=1)] = Field(
        None, description='The name of the organization.'
    )
    hierarchy_code: Optional[constr(min_length=1)] = Field(
        None,
        alias='hierarchyCode',
        description='The internally defined hierarchyCode referencing the organization.',
    )


class Organization4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined UUID referencing the organization.'
    )
    name: constr(min_length=1) = Field(..., description='The name of the organization.')
    hierarchy_code: Optional[constr(min_length=1)] = Field(
        None,
        alias='hierarchyCode',
        description='The internally defined hierarchyCode referencing the organization.',
    )


class Organization5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined UUID referencing the organization.'
    )
    name: Optional[constr(min_length=1)] = Field(
        None, description='The name of the organization.'
    )
    hierarchy_code: constr(min_length=1) = Field(
        ...,
        alias='hierarchyCode',
        description='The internally defined hierarchyCode referencing the organization.',
    )


class Address2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The CustomerAddress `Type` will be displayed (MasterMind will require a minimum of 1 address entered to create a customer) - Example: Billing, Main.',
    )
    street1: constr(min_length=1) = Field(
        ..., description="The Street Name of a customer's address will be displayed."
    )
    street2: Optional[str] = Field(
        None,
        description='This would serve as an optional 2nd line of Street1 (Example: P.O. Box, ApartmentNumber, etc).',
    )
    city: constr(min_length=1) = Field(
        ..., description="The customer's address City will be displayed."
    )
    state: constr(min_length=1) = Field(
        ..., description="The State of a customer's address will be displayed."
    )
    country: constr(min_length=1) = Field(
        ..., description="The Country of a customer's address will be displayed."
    )
    postal_code: constr(min_length=1) = Field(
        ...,
        alias='postalCode',
        description='The Postalcode of a customer address will be displayed.',
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description='A user can flag to indicate a customer address as the `Main` address for a given customer.',
    )


class InstantMessenger4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of instant messaging system being used for the contact (Skype, Zoom,etc).',
    )
    user_name: constr(min_length=1) = Field(
        ...,
        alias='userName',
        description="The customer contact's instant-messaging username. If a service type is indicated then a username must be provided.",
    )


class Contact2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of customer contact would be displayed (Examples: Primary, Dispatch, Billing, etc).',
    )
    name: constr(min_length=1) = Field(
        ..., description="A customer contact's First and Last name will be displayed."
    )
    email_address: Optional[EmailStr] = Field(
        None,
        alias='emailAddress',
        description='An email address will display in relation to a specific customer contact. Will be used to identify recipient of manual/automatic tendering, billing information, etc.',
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='phoneNumber',
        description="The customer contact's phone number will be displayed in the TMS.",
    )
    extension: Optional[str] = Field(
        None, description="A customer's phone extension will be displayed in the TMS."
    )
    fax_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='faxNumber',
        description="A customer's fax number will be displayed in the TMS.",
    )
    instant_messenger: Optional[InstantMessenger4] = Field(
        None,
        alias='instantMessenger',
        description='Instant messenger object for the customer contact.',
    )
    is_main: Optional[bool] = Field(
        None, alias='isMain', description='The main contact for a customer.'
    )


class Group(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    division_term: str = Field(
        ...,
        alias='divisionTerm',
        description='The division for a customer (e.g., brokerage, managed).',
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type for a customer (e.g., sales, operations).',
    )
    group_term: str = Field(
        ..., alias='groupTerm', description='The group for a customer (e.g., ac1, ah1).'
    )


class Identifier2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description="A unique customer's connectivity `type` will be displayed (EDI, OTM, etc). Currently defined as a `System` within MasterMind.",
    )
    value: constr(min_length=1) = Field(
        ...,
        description='A unique ID will be displayed in correlation to the identifier type. Alpha and numeric values are supported.',
    )


class Rep2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    employee_code: constr(min_length=1) = Field(
        ...,
        alias='employeeCode',
        description="A unique ID exposed on the UI that can be searched within the TMS. This can also be used a reference ID to a Client's legacy system where B2B integrations are in place.",
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description="A user can indicate an individual Customer Rep's alignment to a Customer (Customer reps can `Sponsor` a customer and would be displayed as `Main`). Only 1 main user allowed.",
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of business the rep supports (e.g. Broker, Broker Support, Broker Admin). Expected value based on `Customer Rep Type` value configuration.',
    )
    is_load: Optional[bool] = Field(
        None,
        alias='isLoad',
        description='Indicates if the customer rep handles loads. If `isLoad` is set to TRUE, the rep will persist to the Load when the Customer is assigned as the Order Customer.',
    )
    mode_term: Optional[str] = Field(
        None,
        alias='modeTerm',
        description='Mode of the Customer Rep (Ex. Truck, Rail).',
    )
    size_term: Optional[str] = Field(
        None, alias='sizeTerm', description='Load size the Customer Rep handles.'
    )
    direction_term: Optional[str] = Field(
        None,
        alias='directionTerm',
        description='The direction of loads the rep handles (i.e. Inbound).',
    )


class ServiceTolerance(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    stop_type_term: str = Field(
        ...,
        alias='stopTypeTerm',
        description='The type of stop used to track the service tolerance (e.g. pickup, delivery).',
    )
    unit_type_term: str = Field(
        ...,
        alias='unitTypeTerm',
        description='The unit of measure of time (e.g. hours, minutes).',
    )
    early_tolerance: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        alias='earlyTolerance',
        description='How early the customer will allow for a pickup or drop off.',
    )
    late_tolerance: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        alias='lateTolerance',
        description='How late the customer will allow for a pickup or drop off.',
    )


class CustomersPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ...,
        description='A uniqueID exposed on the UI that can be searched throughout the TMS.',
    )
    name: constr(min_length=1) = Field(
        ...,
        description='A descriptive location Customer Name would be displayed throughout the TMS.',
    )
    website: Optional[str] = Field(None, description='The website of the customer.')
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The type of customer (e.x. Supplier, Tender Party, etc).',
    )
    status_term: str = Field(
        ...,
        alias='statusTerm',
        description='The current status of a customer would be displayed.',
    )
    level_term: Optional[str] = Field(
        None,
        alias='levelTerm',
        description="The intent with level is to identify the level of the Customer within your organization. These values can be client defined or selected using preconfigured values: Bronze, Silver, Gold, Platinum. The Client is able to indicate the business rules that drive level - in the future there can be automated processes if this isn't indicated within a legacy system.",
    )
    opportunity_term: Optional[str] = Field(
        None,
        alias='opportunityTerm',
        description='The level of customer Opportunity will be displayed. The intent is to automate the level of opportunity the Client can have with the customer based on company size, transporation spend, etc.',
    )
    insurance_cargo: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='insuranceCargo',
        description='The Cargo Insurance for a customer will be displayed. If not indicated, this should default to $100K.',
    )
    insurance_general: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='insuranceGeneral',
        description='The General Insurance for a customer will be displayed. Most commonly will be $1,000,000 (will be defined upon implementation.',
    )
    insurance_liability: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='insuranceLiability',
        description='The Liability Insurance for a customer will be displayed. Most commonly will be $1,000,000 (will be defined upon implementation.',
    )
    minimum_insurance_rating_type_term: Optional[str] = Field(
        None,
        alias='minimumInsuranceRatingTypeTerm',
        description='The minimum insurance rating for a customer.',
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='phoneNumber',
        description="The customer's phone number that will be displayed in the TMS per customer location.",
    )
    notes: Optional[str] = Field(
        None, description="A user's free form text notes would be displayed."
    )
    rating_based_on_term: Optional[str] = Field(
        None,
        alias='ratingBasedOnTerm',
        description='Identifies the date type used to match to customer rate quotes (e.g., pick up date, ship date, delivery date).',
    )
    organization: Optional[Union[Organization3, Organization4, Organization5]] = Field(
        None,
        description='The organization record the customer record is associated with.',
    )
    addresses: List[Address2] = Field(
        ...,
        description='A collection of addresses associated with the Customer. At least one address is required.',
        min_length=1,
    )
    contacts: Optional[List[Contact2]] = Field(
        None,
        description='A collection of contacts associated with the Customer. Contacts are not required.',
    )
    groups: Optional[List[Group]] = Field(
        None, description='The collection of groups associated to a customer.'
    )
    identifiers: Optional[List[Identifier2]] = Field(
        None,
        description='A collection of keys associated with the Customer to identify them within MasterMind.',
    )
    reps: Optional[List[Rep2]] = Field(
        None, description='A collection of Reps that can be associated to a Customer.'
    )
    service_tolerances: Optional[List[ServiceTolerance]] = Field(
        None,
        alias='serviceTolerances',
        description='The collection of service tolerances for how early or late a Customer accepts pickups and drop offs.',
    )


class Address3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if the address should be destroyed.',
    )
    id: Optional[str] = Field(None, description='The unique customer address ID.')
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The CustomerAddress `Type` will be displayed (MasterMind will require a minimum of 1 address entered to create a customer) - Example: Billing, Main.',
    )
    street1: Optional[str] = Field(
        None, description="The Street Name of a customer's address will be displayed."
    )
    street2: Optional[str] = Field(
        None,
        description='This would serve as an optional 2nd line of Street1 (Example: P.O. Box, ApartmentNumber, etc).',
    )
    city: Optional[str] = Field(
        None, description="The customer's address City will be displayed."
    )
    state: Optional[str] = Field(
        None, description="The State of a customer's address will be displayed."
    )
    country: Optional[str] = Field(
        None, description="The Country of a customer's address will be displayed."
    )
    postal_code: Optional[str] = Field(
        None,
        alias='postalCode',
        description='The Postalcode of a customer address will be displayed.',
    )
    is_main: Optional[bool] = Field(
        None,
        alias='isMain',
        description='A user can flag to indicate a customer address as the `Main` address for a given customer.',
    )


class InstantMessenger5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The type of instant messaging system being used for the contact (Skype, Zoom,etc).',
    )
    user_name: Optional[str] = Field(
        None,
        alias='userName',
        description="The customer contact's instant-messaging username. If a service type is indicated then a username must be provided.",
    )


class Contact3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if the contact should be destroyed.',
    )
    id: Optional[str] = Field(None, description='The unique customer contact ID.')
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The type of customer contact would be displayed (Examples: Primary, Dispatch, Billing, etc).',
    )
    name: Optional[str] = Field(
        None, description="A customer contact's First and Last name will be displayed."
    )
    email_address: Optional[EmailStr] = Field(
        None,
        alias='emailAddress',
        description='An email address will display in relation to a specific customer contact. Will be used to identify recipient of manual/automatic tendering, billing information, etc.',
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='phoneNumber',
        description="The customer contact's phone number will be displayed in the TMS.",
    )
    extension: Optional[str] = Field(
        None, description="A customer's phone extension will be displayed in the TMS."
    )
    fax_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='faxNumber',
        description="A customer's fax number will be displayed in the TMS.",
    )
    instant_messenger: Optional[InstantMessenger5] = Field(
        None,
        alias='instantMessenger',
        description='Instant messenger object for the customer contact.',
    )
    is_main: Optional[bool] = Field(
        None, alias='isMain', description='The main contact for a customer.'
    )


class Group1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if the group should be destroyed.',
    )
    id: Optional[str] = Field(None, description='The unique customer group ID.')
    division_term: Optional[str] = Field(
        None,
        alias='divisionTerm',
        description='The division for a customer (e.g., brokerage, managed).',
    )
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The type for a customer (e.g., sales, operations).',
    )
    group_term: Optional[str] = Field(
        None,
        alias='groupTerm',
        description='The group for a customer (e.g., ac1, ah1).',
    )


class Identifier3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if the identifier should be destroyed.',
    )
    id: Optional[str] = Field(None, description='The unique identifier ID.')
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description="A unique customer's connectivity `type` will be displayed (EDI, OTM, etc). Currently defined as a `System` within MasterMind.",
    )
    value: Optional[str] = Field(
        None,
        description='A unique ID will be displayed in correlation to the identifier type. Alpha and numeric values are supported.',
    )


class Rep3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if the rep should be destroyed.',
    )
    id: Optional[str] = Field(None, description='The unique customer rep ID.')
    employee_code: Optional[str] = Field(
        None,
        alias='employeeCode',
        description="A unique ID exposed on the UI that can be searched within the TMS. This can also be used a reference ID to a Client's legacy system where B2B integrations are in place.",
    )
    is_main: Optional[bool] = Field(
        None,
        alias='isMain',
        description="A user can indicate an individual Customer Rep's alignment to a Customer (Customer reps can `Sponsor` a customer and would be displayed as `Main`). Only 1 main user allowed.",
    )
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The type of business the rep supports (e.g. Broker, Broker Support, Broker Admin). Expected value based on `Customer Rep Type` value configuration.',
    )
    is_load: Optional[bool] = Field(
        None,
        alias='isLoad',
        description='Indicates if the customer rep handles loads. If `isLoad` is set to TRUE, the rep will persist to the Load when the Customer is assigned as the Order Customer.',
    )
    mode_term: Optional[str] = Field(
        None,
        alias='modeTerm',
        description='Mode of the Customer Rep (Ex. Truck, Rail).',
    )
    size_term: Optional[str] = Field(
        None, alias='sizeTerm', description='Load size the Customer Rep handles.'
    )
    direction_term: Optional[str] = Field(
        None,
        alias='directionTerm',
        description='The direction of loads the rep handles (i.e. Inbound).',
    )


class ServiceTolerance1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if the service tolerance should be destroyed.',
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID of the service tolerance record.'
    )
    stop_type_term: Optional[str] = Field(
        None,
        alias='stopTypeTerm',
        description='The type of stop used to track the service tolerance (e.g. pickup, delivery).',
    )
    unit_type_term: Optional[str] = Field(
        None,
        alias='unitTypeTerm',
        description='The unit of measure of time (e.g. hours, minutes).',
    )
    early_tolerance: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='earlyTolerance',
        description='How early the customer will allow for a pickup or drop off.',
    )
    late_tolerance: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='lateTolerance',
        description='How late the customer will allow for a pickup or drop off.',
    )


class CustomersCustomerCodePATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: Optional[str] = Field(
        None,
        description='A descriptive location Customer Name would be displayed throughout the TMS.',
    )
    website: Optional[str] = Field(None, description='The website of the customer.')
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The type of customer (e.x. Supplier, Tender Party, etc).',
    )
    status_term: Optional[str] = Field(
        None,
        alias='statusTerm',
        description='The current status of a customer would be displayed.',
    )
    level_term: Optional[str] = Field(
        None,
        alias='levelTerm',
        description="The intent with level is to identify the level of the Customer within your organization. These values can be client defined or selected using preconfigured values: Bronze, Silver, Gold, Platinum. The Client is able to indicate the business rules that drive level - in the future there can be automated processes if this isn't indicated within a legacy system.",
    )
    opportunity_term: Optional[str] = Field(
        None,
        alias='opportunityTerm',
        description='The level of customer Opportunity will be displayed. The intent is to automate the level of opportunity the Client can have with the customer based on company size, transporation spend, etc.',
    )
    insurance_cargo: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='insuranceCargo',
        description='The Cargo Insurance for a customer will be displayed. If not indicated, this should default to $100K.',
    )
    insurance_general: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='insuranceGeneral',
        description='The General Insurance for a customer will be displayed. Most commonly will be $1,000,000 (will be defined upon implementation.',
    )
    insurance_liability: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='insuranceLiability',
        description='The Liability Insurance for a customer will be displayed. Most commonly will be $1,000,000 (will be defined upon implementation.',
    )
    minimum_insurance_rating_type_term: Optional[str] = Field(
        None,
        alias='minimumInsuranceRatingTypeTerm',
        description='The minimum insurance rating for a customer.',
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='phoneNumber',
        description="The customer's phone number that will be displayed in the TMS per customer location.",
    )
    notes: Optional[str] = Field(
        None, description="A user's free form text notes would be displayed."
    )
    rating_based_on_term: Optional[str] = Field(
        None,
        alias='ratingBasedOnTerm',
        description='Identifies the date type used to match to customer rate quotes (e.g., pick up date, ship date, delivery date).',
    )
    addresses: Optional[List[Address3]] = Field(
        None, description='A collection of addresses associated with the Customer.'
    )
    contacts: Optional[List[Contact3]] = Field(
        None, description='A collection of contacts associated with the Customer.'
    )
    groups: Optional[List[Group1]] = Field(
        None, description='The collection of groups associated to a customer.'
    )
    identifiers: Optional[List[Identifier3]] = Field(
        None,
        description='A collection of keys associated with the Customer to identify them within MasterMind.',
    )
    reps: Optional[List[Rep3]] = Field(
        None, description='A collection of Reps that can be associated to a Customer.'
    )
    service_tolerances: Optional[List[ServiceTolerance1]] = Field(
        None,
        alias='serviceTolerances',
        description='The collection of service tolerances for how early or late a Customer accepts pickups and drop offs.',
    )


class Weekly(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_monday: bool = Field(
        ...,
        alias='isMonday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_tuesday: bool = Field(
        ...,
        alias='isTuesday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_wednesday: bool = Field(
        ...,
        alias='isWednesday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_thursday: bool = Field(
        ...,
        alias='isThursday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_friday: bool = Field(
        ...,
        alias='isFriday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_saturday: bool = Field(
        ...,
        alias='isSaturday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_sunday: bool = Field(
        ...,
        alias='isSunday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )


class InvoiceFrequencies(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    weekly: Optional[Weekly] = Field(
        None,
        description='If invoiceFrequencyTerm is set to Weekly, this object determines which day(s) of the week invoices will be consolidated.',
    )
    monthly: Optional[List[confloat(ge=1.0, le=8640000000000000.0)]] = Field(
        None,
        description='If invoiceFrequencyTerm is set to Monthly, this field determines the days of the month that invoices will be consolidated.',
    )


class BillingCode(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internal unique system UUID for billing code.'
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The unique Billing Code ID that is exposed on the UI that can be searched throughout the TMS. This will default to be the same as the Customer Code when a Customer is first created. Any additional billing codes created on the UI will default to the customer code followed by a 3-digit number (001, 002, 003). Users can manually update the Billing Code on the UI or update it via API.',
    )
    is_default: Optional[bool] = Field(
        None,
        alias='isDefault',
        description='Indicates if the billing code is the default for the customer record.',
    )
    bill_to_customer_code: constr(min_length=1) = Field(
        ...,
        alias='billToCustomerCode',
        description='The Customer reference code for the record it should  be billed to. This is `Bill to` on the UI.',
    )
    bill_to_address_id: constr(min_length=1) = Field(
        ...,
        alias='billToAddressId',
        description='The internal unique system UUID for the address on the customer record.',
    )
    payment_term: str = Field(
        ...,
        alias='paymentTerm',
        description='The payment terms of a billing customer would be displayed in the TMS (Example: Net 20, Net 30, Net 45, Quick Pay, etc.).',
    )
    payment_method_term: str = Field(
        ...,
        alias='paymentMethodTerm',
        description="A billing customer's preferred payment method is indicated (Example: check, EFT).",
    )
    currency_term: str = Field(
        ...,
        alias='currencyTerm',
        description="A billing customer's payment currency is indicated (Example: USD, CAN, etc.).",
    )
    email_addresses: Optional[List[EmailStr]] = Field(
        None,
        alias='emailAddresses',
        description="The customer's billing email address.",
    )
    invoice_method_term: str = Field(
        ...,
        alias='invoiceMethodTerm',
        description="A billing customer's invoice method is indictated (Example: Print, No Print, Email, etc.).",
    )
    invoice_grouping_term: Optional[str] = Field(
        None,
        alias='invoiceGroupingTerm',
        description="A billing customer's invoice grouping method is indicated (Example: Invoice or Consolidated Invoice).",
    )
    invoice_type_term: Optional[str] = Field(
        None,
        alias='invoiceTypeTerm',
        description="The way the billing code's associated invoices will be managed (e.g., Single, Consolidated). Data Dictionary Term.",
    )
    invoice_frequency_term: str = Field(
        ...,
        alias='invoiceFrequencyTerm',
        description="A billing customer's invoice distribution frequency method is indicated (Example: At Invoicing, Weekly, Monthly).",
    )
    invoice_frequencies: Optional[InvoiceFrequencies] = Field(
        None,
        alias='invoiceFrequencies',
        description='The days of the week or month when the frequency is Weekly or Monthly.',
    )
    invoice_template_term: str = Field(
        ...,
        alias='invoiceTemplateTerm',
        description='Specifies what template version to show based on Invoice Grouping value.',
    )


class RequiredPaperworkItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internal unique system UUID for required paperwork record.',
    )
    document_type_term: str = Field(
        ...,
        alias='documentTypeTerm',
        description='The document type is indicated (Example: Bill of Lading, Customer Invoice, Lumper Receipt, etc.).',
    )
    mode_term: str = Field(
        ...,
        alias='modeTerm',
        description='The mode of transportation this paperwork is required for is indicated (Example: Truck, Intermodal,  Rail, etc.).',
    )
    size_term: str = Field(
        ...,
        alias='sizeTerm',
        description='The the size of load this paperwork is required for is indicated (Example: FTL, LTL, Partial).',
    )
    billing_code: Optional[str] = Field(
        None,
        alias='billingCode',
        description='The unique billing code for the required paperwork. If this is empty then the required paperwork is applicable to all billing codes.',
    )
    division_term: List[str] = Field(
        ...,
        alias='divisionTerm',
        description='A required paperwork to a specific division will be indicated. Note: A client will determine these values upon implementation.',
        min_length=1,
    )
    charge_type_term: Optional[str] = Field(
        None,
        alias='chargeTypeTerm',
        description='The charge type associated to the required paperwork is indicated (Example: Freight, Unloading, Layover, Pickup, etc.).',
    )
    is_included_with_invoice: Optional[bool] = Field(
        None,
        alias='isIncludedWithInvoice',
        description='The required paperwork is indicated as needing to be included with the invoice.',
    )
    is_combined_pod_document: Optional[bool] = Field(
        None,
        alias='isCombinedPodDocument',
        description='This is only applicable when the document type is a Proof of Delivery. If this flag is set to true then then it will combine the POD requirements in to one requirement. Otherwise it will display one POD requirement per delivery stop.',
    )


class StatusTerm(Enum):
    approved = 'Approved'
    hold = 'Hold'
    denied = 'Denied'
    pending = 'Pending'


class CreditStatusRecord(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_use_parent_credit: Optional[bool] = Field(
        None,
        alias='isUseParentCredit',
        description="This will indicate if the customer's parent company should be used for the credit limit.",
    )
    status_term: StatusTerm = Field(
        ...,
        alias='statusTerm',
        description="This will indicate the Customer's credit status (i.e. Approved, Hold, Denied).",
    )
    limit_amount: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='limitAmount',
        description='The monetary amount of the credit limit.',
    )
    expiration_date: Optional[date] = Field(
        None,
        alias='expirationDate',
        description='This will indicate the expiration of the credit limit extended to the customer.',
    )


class CustomersCustomerCodeaccountingPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    accounting_status_term: str = Field(
        ...,
        alias='accountingStatusTerm',
        description='The accounting status of the customer record determines if it can be used throughout the TMS.',
    )
    is_tax_exempt: bool = Field(
        ...,
        alias='isTaxExempt',
        description='Indicates if the customer is exempt or non-exempt.',
    )
    is_auto_invoicing: bool = Field(
        ...,
        alias='isAutoInvoicing',
        description='Enabling auto invoicing for a customer will allow seamless processing in the TMS.',
    )
    rating_source_term: str = Field(
        ...,
        alias='ratingSourceTerm',
        description='When Rating Source is EDI, rating/rerating functionality will not be executed for a given load. When rating source is MasterMind, EDI Rate Details are informational only and will only be used for reference.',
    )
    notes: Optional[str] = Field(
        None, description='The customer accounting specific notes.'
    )
    is_use_global_paperwork: bool = Field(
        ...,
        alias='isUseGlobalPaperwork',
        description='Indicates if the customer will use the global required paperwork settings in the TMS.',
    )
    billing_codes: Optional[List[BillingCode]] = Field(
        None,
        alias='billingCodes',
        description='Collection of billing codes for a customer.',
    )
    required_paperwork: Optional[List[RequiredPaperworkItem]] = Field(
        None,
        alias='requiredPaperwork',
        description='A collection of required paperwork associated with the customer.',
    )
    credit_status_record: Optional[CreditStatusRecord] = Field(
        None,
        alias='creditStatusRecord',
        description="Set or update the Customer's credit Status.",
    )


class Weekly1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_monday: Optional[bool] = Field(
        None,
        alias='isMonday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_tuesday: Optional[bool] = Field(
        None,
        alias='isTuesday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_wednesday: Optional[bool] = Field(
        None,
        alias='isWednesday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_thursday: Optional[bool] = Field(
        None,
        alias='isThursday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_friday: Optional[bool] = Field(
        None,
        alias='isFriday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_saturday: Optional[bool] = Field(
        None,
        alias='isSaturday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_sunday: Optional[bool] = Field(
        None,
        alias='isSunday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )


class InvoiceFrequencies1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    weekly: Optional[Weekly1] = Field(
        None,
        description='If invoiceFrequencyTerm is set to Weekly, this object determines which day(s) of the week invoices will be consolidated.',
    )
    monthly: Optional[List[confloat(ge=1.0, le=8640000000000000.0)]] = Field(
        None,
        description='If invoiceFrequencyTerm is set to Monthly, this field determines the days of the month that invoices will be consolidated.',
    )


class BillingCode1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this billing code should be destroyed.',
    )
    id: Optional[str] = Field(
        None, description='The internal unique system UUID for billing code.'
    )
    code: Optional[constr(min_length=1)] = Field(
        None,
        description='The unique Billing Code ID that is exposed on the UI that can be searched throughout the TMS. This will default to be the same as the Customer Code when a Customer is first created. Any additional billing codes created on the UI will default to the customer code followed by a 3-digit number (001, 002, 003). Users can manually update the Billing Code on the UI or update it via API.',
    )
    is_default: Optional[bool] = Field(
        None,
        alias='isDefault',
        description='Indicates if the billing code is the default for the customer record.',
    )
    bill_to_customer_code: Optional[constr(min_length=1)] = Field(
        None,
        alias='billToCustomerCode',
        description='The Customer reference code for the record it should  be billed to. This is `Bill to` on the UI.',
    )
    bill_to_address_id: Optional[constr(min_length=1)] = Field(
        None,
        alias='billToAddressId',
        description='The internal unique system UUID for the address on the customer record.',
    )
    payment_term: Optional[str] = Field(
        None,
        alias='paymentTerm',
        description='The payment terms of a billing customer would be displayed in the TMS (Example: Net 20, Net 30, Net 45, Quick Pay, etc.).',
    )
    payment_method_term: Optional[str] = Field(
        None,
        alias='paymentMethodTerm',
        description="A billing customer's preferred payment method is indicated (Example: check, EFT).",
    )
    currency_term: Optional[str] = Field(
        None,
        alias='currencyTerm',
        description="A billing customer's payment currency is indicated (Example: USD, CAN, etc.).",
    )
    email_addresses: Optional[List[EmailStr]] = Field(
        None,
        alias='emailAddresses',
        description="The customer's billing email address.",
    )
    invoice_method_term: Optional[str] = Field(
        None,
        alias='invoiceMethodTerm',
        description="A billing customer's invoice method is indicated (Example: Print, No Print, Email, etc.).",
    )
    invoice_grouping_term: Optional[str] = Field(
        None,
        alias='invoiceGroupingTerm',
        description="A billing customer's invoice grouping method is indicated (Example: Invoice or Consolidated Invoice).",
    )
    invoice_type_term: Optional[str] = Field(
        None,
        alias='invoiceTypeTerm',
        description="The way the billing code's associated invoices will be managed (e.g., Single, Consolidated). Data Dictionary Term.",
    )
    invoice_frequency_term: Optional[str] = Field(
        None,
        alias='invoiceFrequencyTerm',
        description="A billing customer's invoice distribution frequency method is indicated (Example: At Invoicing, Weekly, Monthly).",
    )
    invoice_frequencies: Optional[InvoiceFrequencies1] = Field(
        None,
        alias='invoiceFrequencies',
        description='The days of the week or month when the frequency is Weekly or Monthly.',
    )
    invoice_template_term: Optional[str] = Field(
        None,
        alias='invoiceTemplateTerm',
        description='Specifies what template version to show based on Invoice Grouping value.',
    )


class RequiredPaperworkItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this required paperwork should be destroyed.',
    )
    id: Optional[str] = Field(
        None,
        description='The internal unique system UUID for required paperwork record.',
    )
    document_type_term: Optional[str] = Field(
        None,
        alias='documentTypeTerm',
        description='The document type is indicated (Example: Bill of Lading, Customer Invoice, Lumper Receipt, etc.).',
    )
    mode_term: Optional[str] = Field(
        None,
        alias='modeTerm',
        description='The mode of transportation this paperwork is required for is indicated (Example: Truck, Intermodal,  Rail, etc.).',
    )
    size_term: Optional[str] = Field(
        None,
        alias='sizeTerm',
        description='The size of load this paperwork is required for is indicated (Example: FTL, LTL, Partial).',
    )
    billing_code: Optional[str] = Field(
        None,
        alias='billingCode',
        description='The unique billing code for the required paperwork. If this is empty then the required paperwork is applicable to all billing codes.',
    )
    division_term: Optional[List[str]] = Field(
        None,
        alias='divisionTerm',
        description='A required paperwork to a specific division will be indicated. Note: A client will determine these values upon implementation.',
    )
    charge_type_term: Optional[str] = Field(
        None,
        alias='chargeTypeTerm',
        description='The charge type associated to the required paperwork is indicated (Example: Freight, Unloading, Layover, Pickup, etc.).',
    )
    is_included_with_invoice: Optional[bool] = Field(
        None,
        alias='isIncludedWithInvoice',
        description='The required paperwork is indicated as needing to be included with the invoice.',
    )
    is_combined_pod_document: Optional[bool] = Field(
        None,
        alias='isCombinedPodDocument',
        description='This is only applicable when the document type is a Proof of Delivery. If this flag is set to true then then it will combine the POD requirements in to one requirement. Otherwise it will display one POD requirement per delivery stop.',
    )


class CreditStatusRecord1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_use_parent_credit: Optional[bool] = Field(
        None,
        alias='isUseParentCredit',
        description="This will indicate if the customer's parent company should be used for the credit limit.",
    )
    status_term: Optional[StatusTerm] = Field(None, alias='statusTerm')
    limit_amount: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='limitAmount',
        description='The monetary amount of the credit limit.',
    )
    expiration_date: Optional[date] = Field(
        None,
        alias='expirationDate',
        description='This will indicate the expiration of the credit limit extended to the customer.',
    )


class CustomersCustomerCodeaccountingPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    accounting_status_term: Optional[str] = Field(
        None,
        alias='accountingStatusTerm',
        description='The accounting status of the customer record determines if it can be used throughout the TMS.',
    )
    is_tax_exempt: Optional[bool] = Field(
        None,
        alias='isTaxExempt',
        description='Indicates if the customer is exempt or non-exempt.',
    )
    is_auto_invoicing: Optional[bool] = Field(
        None,
        alias='isAutoInvoicing',
        description='Enabling auto invoicing for a customer will allow seamless processing in the TMS.',
    )
    rating_source_term: Optional[str] = Field(
        None,
        alias='ratingSourceTerm',
        description='When Rating Source is EDI, rating/rerating functionality will not be executed for a given load. When rating source is MasterMind, EDI Rate Details are informational only and will only be used for reference.',
    )
    notes: Optional[str] = Field(
        None, description='The customer accounting specific notes.'
    )
    is_use_global_paperwork: Optional[bool] = Field(
        None,
        alias='isUseGlobalPaperwork',
        description='Indicates if the customer will use the global required paperwork settings in the TMS.',
    )
    billing_codes: Optional[List[BillingCode1]] = Field(
        None,
        alias='billingCodes',
        description='Collection of billing codes for a customer.',
    )
    required_paperwork: Optional[List[RequiredPaperworkItem1]] = Field(
        None,
        alias='requiredPaperwork',
        description='A collection of required paperwork associated with the customer.',
    )
    credit_status_record: Optional[CreditStatusRecord1] = Field(
        None,
        alias='creditStatusRecord',
        description="Set or update the Customer's credit Status.",
    )


class Weekly2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_monday: bool = Field(
        ...,
        alias='isMonday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_tuesday: bool = Field(
        ...,
        alias='isTuesday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_wednesday: bool = Field(
        ...,
        alias='isWednesday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_thursday: bool = Field(
        ...,
        alias='isThursday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_friday: bool = Field(
        ...,
        alias='isFriday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_saturday: bool = Field(
        ...,
        alias='isSaturday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )
    is_sunday: bool = Field(
        ...,
        alias='isSunday',
        description='Indicates whether or not invoices will be consolidated this day of the week.',
    )


class InvoiceFrequencies2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    weekly: Optional[Weekly2] = Field(
        None,
        description='If invoiceFrequencyTerm is set to Weekly, this object determines which day(s) of the week invoices will be consolidated.',
    )
    monthly: Optional[List[confloat(ge=1.0, le=8640000000000000.0)]] = Field(
        None,
        description='If invoiceFrequencyTerm is set to Monthly, this field determines the days of the month that invoices will be consolidated.',
    )


class CustomersCustomerCodeaccountingbillingCodesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The unique Billing Code ID that is exposed on the UI that can be searched throughout the TMS. This will default to be the same as the Customer Code when a Customer is first created. Any additional billing codes created on the UI will default to the customer code followed by a 3-digit number (001, 002, 003). Users can manually update the Billing Code on the UI or update it via API.',
    )
    is_default: Optional[bool] = Field(
        None,
        alias='isDefault',
        description='Indicates if the billing code is the default for the customer record.',
    )
    bill_to_customer_code: constr(min_length=1) = Field(
        ...,
        alias='billToCustomerCode',
        description='The Customer reference code for the record it should  be billed to. This is `Bill to` on the UI.',
    )
    bill_to_address_id: constr(min_length=1) = Field(
        ...,
        alias='billToAddressId',
        description='The internal unique system UUID for the address on the customer record.',
    )
    payment_term: str = Field(
        ...,
        alias='paymentTerm',
        description='The payment terms of a billing customer would be displayed in the TMS (Example: Net 20, Net 30, Net 45, Quick Pay, etc.).',
    )
    payment_method_term: str = Field(
        ...,
        alias='paymentMethodTerm',
        description="A billing customer's preferred payment method is indicated (Example: check, EFT).",
    )
    currency_term: str = Field(
        ...,
        alias='currencyTerm',
        description="A billing customer's payment currency is indicated (Example: USD, CAN, etc.).",
    )
    email_addresses: Optional[List[EmailStr]] = Field(
        None,
        alias='emailAddresses',
        description="The customer's billing email address.",
    )
    invoice_method_term: str = Field(
        ...,
        alias='invoiceMethodTerm',
        description="A billing customer's invoice method is indictated (Example: Print, No Print, Email, etc.).",
    )
    invoice_grouping_term: Optional[str] = Field(
        None,
        alias='invoiceGroupingTerm',
        description="A billing customer's invoice grouping method is indicated (Example: Invoice or Consolidated Invoice).",
    )
    invoice_type_term: Optional[str] = Field(
        None,
        alias='invoiceTypeTerm',
        description="The way the billing code's associated invoices will be managed (e.g., Single, Consolidated). Data Dictionary Term.",
    )
    invoice_frequency_term: str = Field(
        ...,
        alias='invoiceFrequencyTerm',
        description="A billing customer's invoice distribution frequency method is indicated (Example: At Invoicing, Weekly, Monthly).",
    )
    invoice_frequencies: Optional[InvoiceFrequencies2] = Field(
        None,
        alias='invoiceFrequencies',
        description='The days of the week or month when the frequency is Weekly or Monthly.',
    )
    invoice_template_term: str = Field(
        ...,
        alias='invoiceTemplateTerm',
        description='Specifies what template version to show based on Invoice Grouping value.',
    )


class InvoiceFrequencies3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    weekly: Optional[Weekly2] = Field(
        None,
        description='If invoiceFrequencyTerm is set to Weekly, this object determines which day(s) of the week invoices will be consolidated.',
    )
    monthly: Optional[List[confloat(ge=1.0, le=8640000000000000.0)]] = Field(
        None,
        description='If invoiceFrequencyTerm is set to Monthly, this field determines the days of the month that invoices will be consolidated.',
    )


class CustomersCustomerCodeaccountingbillingCodesBillingCodeIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The unique Billing Code ID that is exposed on the UI that can be searched throughout the TMS. This will default to be the same as the Customer Code when a Customer is first created. Any additional billing codes created on the UI will default to the customer code followed by a 3-digit number (001, 002, 003). Users can manually update the Billing Code on the UI or update it via API.',
    )
    is_default: Optional[bool] = Field(
        None,
        alias='isDefault',
        description='Indicates if the billing code is the default for the customer record.',
    )
    bill_to_customer_code: constr(min_length=1) = Field(
        ...,
        alias='billToCustomerCode',
        description='The Customer reference code for the record it should  be billed to. This is `Bill to` on the UI.',
    )
    bill_to_address_id: constr(min_length=1) = Field(
        ...,
        alias='billToAddressId',
        description='The internal unique system UUID for the address on the customer record.',
    )
    payment_term: str = Field(
        ...,
        alias='paymentTerm',
        description='The payment terms of a billing customer would be displayed in the TMS (Example: Net 20, Net 30, Net 45, Quick Pay, etc.).',
    )
    payment_method_term: str = Field(
        ...,
        alias='paymentMethodTerm',
        description="A billing customer's preferred payment method is indicated (Example: check, EFT).",
    )
    currency_term: str = Field(
        ...,
        alias='currencyTerm',
        description="A billing customer's payment currency is indicated (Example: USD, CAN, etc.).",
    )
    email_addresses: Optional[List[EmailStr]] = Field(
        None,
        alias='emailAddresses',
        description="The customer's billing email address.",
    )
    invoice_method_term: str = Field(
        ...,
        alias='invoiceMethodTerm',
        description="A billing customer's invoice method is indictated (Example: Print, No Print, Email, etc.).",
    )
    invoice_grouping_term: Optional[str] = Field(
        None,
        alias='invoiceGroupingTerm',
        description="A billing customer's invoice grouping method is indicated (Example: Invoice or Consolidated Invoice).",
    )
    invoice_type_term: Optional[str] = Field(
        None,
        alias='invoiceTypeTerm',
        description="The way the billing code's associated invoices will be managed (e.g., Single, Consolidated). Data Dictionary Term.",
    )
    invoice_frequency_term: str = Field(
        ...,
        alias='invoiceFrequencyTerm',
        description="A billing customer's invoice distribution frequency method is indicated (Example: At Invoicing, Weekly, Monthly).",
    )
    invoice_frequencies: Optional[InvoiceFrequencies3] = Field(
        None,
        alias='invoiceFrequencies',
        description='The days of the week or month when the frequency is Weekly or Monthly.',
    )
    invoice_template_term: str = Field(
        ...,
        alias='invoiceTemplateTerm',
        description='Specifies what template version to show based on Invoice Grouping value.',
    )


class CustomersCustomerCodeaccountingrequiredPaperworkPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    document_type_term: str = Field(
        ...,
        alias='documentTypeTerm',
        description='The document type is indicated (Example: Bill of Lading, Customer Invoice, Lumper Receipt, etc.).',
    )
    mode_term: str = Field(
        ...,
        alias='modeTerm',
        description='The mode of transportation this paperwork is required for is indicated (Example: Truck, Intermodal,  Rail, etc.).',
    )
    size_term: str = Field(
        ...,
        alias='sizeTerm',
        description='The size of load this paperwork is required for is indicated (Example: FTL, LTL, Partial).',
    )
    billing_code: Optional[str] = Field(
        None,
        alias='billingCode',
        description='The unique billing code for the required paperwork. If this is empty then the required paperwork is applicable to all billing codes.',
    )
    division_term: List[str] = Field(
        ...,
        alias='divisionTerm',
        description='A required paperwork to a specific division will be indicated. Note: A client will determine these values upon implementation.',
        min_length=1,
    )
    charge_type_term: Optional[str] = Field(
        None,
        alias='chargeTypeTerm',
        description='The charge type associated to the required paperwork is indicated (Example: Freight, Unloading, Layover, Pickup, etc.).',
    )
    is_included_with_invoice: Optional[bool] = Field(
        None,
        alias='isIncludedWithInvoice',
        description='The required paperwork is indicated as needing to be included with the invoice.',
    )
    is_combined_pod_document: Optional[bool] = Field(
        None,
        alias='isCombinedPodDocument',
        description='This is only applicable when the document type is a Proof of Delivery. If this flag is set to true then then it will combine the POD requirements in to one requirement. Otherwise it will display one POD requirement per delivery stop.',
    )


class CustomersCustomerCodeaccountingrequiredPaperworkRequiredPaperworkIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    document_type_term: str = Field(
        ...,
        alias='documentTypeTerm',
        description='The document type is indicated (Example: Bill of Lading, Customer Invoice, Lumper Receipt, etc.).',
    )
    mode_term: str = Field(
        ...,
        alias='modeTerm',
        description='The mode of transportation this paperwork is required for is indicated (Example: Truck, Intermodal,  Rail, etc.).',
    )
    size_term: str = Field(
        ...,
        alias='sizeTerm',
        description='The size of load this paperwork is required for is indicated (Example: FTL, LTL, Partial).',
    )
    billing_code: Optional[str] = Field(
        None,
        alias='billingCode',
        description='The unique billing code for the required paperwork. If this is empty then the required paperwork is applicable to all billing codes.',
    )
    division_term: List[str] = Field(
        ...,
        alias='divisionTerm',
        description='A required paperwork to a specific division will be indicated. Note: A client will determine these values upon implementation.',
        min_length=1,
    )
    charge_type_term: Optional[str] = Field(
        None,
        alias='chargeTypeTerm',
        description='The charge type associated to the required paperwork is indicated (Example: Freight, Unloading, Layover, Pickup, etc.).',
    )
    is_included_with_invoice: Optional[bool] = Field(
        None,
        alias='isIncludedWithInvoice',
        description='The required paperwork is indicated as needing to be included with the invoice.',
    )
    is_combined_pod_document: Optional[bool] = Field(
        None,
        alias='isCombinedPodDocument',
        description='This is only applicable when the document type is a Proof of Delivery. If this flag is set to true then then it will combine the POD requirements in to one requirement. Otherwise it will display one POD requirement per delivery stop.',
    )


class CustomersCustomerCodeaddressesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The CustomerAddress `Type` will be displayed (MasterMind will require a minimum of 1 address entered to create a customer) - Example: Billing, Main.',
    )
    street1: constr(min_length=1) = Field(
        ..., description="The Street Name of a customer's address will be displayed."
    )
    street2: Optional[str] = Field(
        None,
        description='This would serve as an optional 2nd line of Street1 (Example: P.O. Box, ApartmentNumber, etc).',
    )
    city: constr(min_length=1) = Field(
        ..., description="The customer's address City will be displayed."
    )
    state: constr(min_length=1) = Field(
        ..., description="The State of a customer's address will be displayed."
    )
    country: constr(min_length=1) = Field(
        ..., description="The Country of a customer's address will be displayed."
    )
    postal_code: constr(min_length=1) = Field(
        ...,
        alias='postalCode',
        description='The Postalcode of a customer address will be displayed.',
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description='A user can flag to indicate a customer address as the `Main` address for a given customer.',
    )


class CustomersCustomerCodeaddressesAddressIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The CustomerAddress `Type` will be displayed (MasterMind will require a minimum of 1 address entered to create a customer) - Example: Billing, Main.',
    )
    street1: constr(min_length=1) = Field(
        ..., description="The Street Name of a customer's address will be displayed."
    )
    street2: Optional[str] = Field(
        None,
        description='This would serve as an optional 2nd line of Street1 (Example: P.O. Box, ApartmentNumber, etc).',
    )
    city: constr(min_length=1) = Field(
        ..., description="The customer's address City will be displayed."
    )
    state: constr(min_length=1) = Field(
        ..., description="The State of a customer's address will be displayed."
    )
    country: constr(min_length=1) = Field(
        ..., description="The Country of a customer's address will be displayed."
    )
    postal_code: constr(min_length=1) = Field(
        ...,
        alias='postalCode',
        description='The Postalcode of a customer address will be displayed.',
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description='A user can flag to indicate a customer address as the `Main` address for a given customer.',
    )


class InstantMessenger6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of instant messaging system being used for the contact (Skype, Zoom,etc).',
    )
    user_name: constr(min_length=1) = Field(
        ...,
        alias='userName',
        description="The customer contact's instant-messaging username. If a service type is indicated then a username must be provided.",
    )


class CustomersCustomerCodecontactsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of customer contact would be displayed (Examples: Primary, Dispatch, Billing, etc).',
    )
    name: constr(min_length=1) = Field(
        ..., description="A customer contact's First and Last name will be displayed."
    )
    email_address: Optional[EmailStr] = Field(
        None,
        alias='emailAddress',
        description='An email address will display in relation to a specific customer contact. Will be used to identify recipient of manual/automatic tendering, billing information, etc.',
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='phoneNumber',
        description="The customer contact's phone number will be displayed in the TMS.",
    )
    extension: Optional[str] = Field(
        None, description="A customer's phone extension will be displayed in the TMS."
    )
    fax_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='faxNumber',
        description="A customer's fax number will be displayed in the TMS.",
    )
    instant_messenger: Optional[InstantMessenger6] = Field(
        None,
        alias='instantMessenger',
        description='Instant messenger object for the customer contact.',
    )
    is_main: Optional[bool] = Field(
        None, alias='isMain', description='The main contact for a customer.'
    )


class CustomersCustomerCodecontactsContactIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of customer contact would be displayed (Examples: Primary, Dispatch, Billing, etc).',
    )
    name: constr(min_length=1) = Field(
        ..., description="A customer contact's First and Last name will be displayed."
    )
    email_address: Optional[EmailStr] = Field(
        None,
        alias='emailAddress',
        description='An email address will display in relation to a specific customer contact. Will be used to identify recipient of manual/automatic tendering, billing information, etc.',
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='phoneNumber',
        description="The customer contact's phone number will be displayed in the TMS.",
    )
    extension: Optional[str] = Field(
        None, description="A customer's phone extension will be displayed in the TMS."
    )
    fax_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='faxNumber',
        description="A customer's fax number will be displayed in the TMS.",
    )
    instant_messenger: Optional[InstantMessenger6] = Field(
        None,
        alias='instantMessenger',
        description='Instant messenger object for the customer contact.',
    )
    is_main: Optional[bool] = Field(
        None, alias='isMain', description='The main contact for a customer.'
    )


class CustomersCustomerCodegroupsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    division_term: str = Field(
        ...,
        alias='divisionTerm',
        description='The division for a customer (e.g., brokerage, managed).',
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type for a customer (e.g., sales, operations).',
    )
    group_term: str = Field(
        ..., alias='groupTerm', description='The group for a customer (e.g., ac1, ah1).'
    )


class CustomersCustomerCodegroupsGroupIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    division_term: str = Field(
        ...,
        alias='divisionTerm',
        description='The division for a customer (e.g., brokerage, managed).',
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type for a customer (e.g., sales, operations).',
    )
    group_term: str = Field(
        ..., alias='groupTerm', description='The group for a customer (e.g., ac1, ah1).'
    )


class CustomersCustomerCodeidentifiersPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description="A unique customer's connectivity `type` will be displayed (EDI, OTM, etc). Currently defined as a `System` within MasterMind.",
    )
    value: constr(min_length=1) = Field(
        ...,
        description='A unique ID will be displayed in correlation to the identifier type. Alpha and numeric values are supported.',
    )


class CustomersCustomerCodeidentifiersIdentifierIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description="A unique customer's connectivity `type` will be displayed (EDI, OTM, etc). Currently defined as a `System` within MasterMind.",
    )
    value: constr(min_length=1) = Field(
        ...,
        description='A unique ID will be displayed in correlation to the identifier type. Alpha and numeric values are supported.',
    )


class CustomersCustomerCoderepsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    employee_code: constr(min_length=1) = Field(
        ...,
        alias='employeeCode',
        description="A unique ID exposed on the UI that can be searched within the TMS. This can also be used a reference ID to a Client's legacy system where B2B integrations are in place.",
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description="A user can indicate an individual Customer Rep's alignment to a Customer (Customer reps can `Sponsor` a customer and would be displayed as `Main`). Only 1 main user allowed.",
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of business the rep supports (e.g. Broker, Broker Support, Broker Admin). Expected value based on `Customer Rep Type` value configuration.',
    )
    is_load: Optional[bool] = Field(
        None,
        alias='isLoad',
        description='Indicates if the customer rep handles loads. If `isLoad` is set to TRUE, the rep will persist to the Load when the Customer is assigned as the Order Customer.',
    )
    mode_term: Optional[str] = Field(
        None,
        alias='modeTerm',
        description='Mode of the Customer Rep (Ex. Truck, Rail).',
    )
    size_term: Optional[str] = Field(
        None, alias='sizeTerm', description='Load size the Customer Rep handles.'
    )
    direction_term: Optional[str] = Field(
        None,
        alias='directionTerm',
        description='The direction of loads the rep handles (i.e. Inbound).',
    )


class CustomersCustomerCoderepsRepIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    employee_code: constr(min_length=1) = Field(
        ...,
        alias='employeeCode',
        description="A unique ID exposed on the UI that can be searched within the TMS. This can also be used a reference ID to a Client's legacy system where B2B integrations are in place.",
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description="A user can indicate an individual Customer Rep's alignment to a Customer (Customer reps can `Sponsor` a customer and would be displayed as `Main`). Only 1 main user allowed.",
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of business the rep supports (e.g. Broker, Broker Support, Broker Admin). Expected value based on `Customer Rep Type` value configuration.',
    )
    is_load: Optional[bool] = Field(
        None,
        alias='isLoad',
        description='Indicates if the customer rep handles loads. If `isLoad` is set to TRUE, the rep will persist to the Load when the Customer is assigned as the Order Customer.',
    )
    mode_term: Optional[str] = Field(
        None,
        alias='modeTerm',
        description='Mode of the Customer Rep (Ex. Truck, Rail).',
    )
    size_term: Optional[str] = Field(
        None, alias='sizeTerm', description='Load size the Customer Rep handles.'
    )
    direction_term: Optional[str] = Field(
        None,
        alias='directionTerm',
        description='The direction of loads the rep handles (i.e. Inbound).',
    )


class CustomersCustomerCodeserviceTolerancesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    stop_type_term: str = Field(
        ...,
        alias='stopTypeTerm',
        description='The type of stop used to track the service tolerance (e.g. pickup, delivery).',
    )
    unit_type_term: str = Field(
        ...,
        alias='unitTypeTerm',
        description='The unit of measure of time (e.g. hours, minutes).',
    )
    early_tolerance: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        alias='earlyTolerance',
        description='How early the customer will allow for a pickup or drop off.',
    )
    late_tolerance: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        alias='lateTolerance',
        description='How late the customer will allow for a pickup or drop off.',
    )


class CustomersCustomerCodeserviceTolerancesServiceToleranceIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    stop_type_term: str = Field(
        ...,
        alias='stopTypeTerm',
        description='The type of stop used to track the service tolerance (e.g. pickup, delivery).',
    )
    unit_type_term: str = Field(
        ...,
        alias='unitTypeTerm',
        description='The unit of measure of time (e.g. hours, minutes).',
    )
    early_tolerance: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        alias='earlyTolerance',
        description='How early the customer will allow for a pickup or drop off.',
    )
    late_tolerance: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        alias='lateTolerance',
        description='How late the customer will allow for a pickup or drop off.',
    )


class FixedDistance(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    unit_term: UnitTerm = Field(
        ...,
        alias='unitTerm',
        description='The unit of measure for distance.',
        title='FixedDistanceUnitTerm',
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value of the distance.'
    )


class Timezone(Enum):
    america_anchorage = 'America/Anchorage'
    america_los_angeles = 'America/Los_Angeles'
    america_phoenix = 'America/Phoenix'
    america_denver = 'America/Denver'
    america_chicago = 'America/Chicago'
    america_new_york = 'America/New_York'


class LiveDropTerm(Enum):
    bobtail_hook_empty = 'bobtailHookEmpty'
    bobtail_hook_loaded = 'bobtailHookLoaded'
    drop_avail = 'dropAvail'
    drop_empty_bobtail = 'dropEmptyBobtail'
    drop_empty_hook_loaded = 'dropEmptyHookLoaded'
    drop_empty_wait = 'dropEmptyWait'
    drop_loaded_bobtail = 'dropLoadedBobtail'
    drop_loaded_hook_empty = 'dropLoadedHookEmpty'
    drop_loaded_wait = 'dropLoadedWait'
    drop_only = 'dropOnly'
    live = 'live'


class Facility4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description='The internally defined unique identifier of a facility record.',
    )
    code: Optional[str] = Field(
        None,
        description='The externally defined unique identifier for a facility record.',
    )


class Facility5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined unique identifier of a facility record.',
    )
    code: str = Field(
        ...,
        description='The externally defined unique identifier for a facility record.',
    )


class CityState(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city: constr(min_length=1) = Field(..., description='City of the spot quote.')
    state: constr(min_length=2, max_length=2) = Field(
        ..., description='State of the spot quote. ISO alpha-2 code.'
    )
    country: constr(min_length=2, max_length=2) = Field(
        ..., description='Country of the spot quote. ISO alpha-2 code.'
    )


class PostalCode(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: constr(min_length=2, max_length=2) = Field(
        ..., description='Country of the spot quote. ISO alpha-2 code.'
    )
    code: constr(min_length=1) = Field(
        ..., description='Postal code of the spot quote.'
    )


class Location4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Union[Facility4, Facility5] = Field(
        ..., description='The spot quote stop facility.', title='Facility'
    )
    city_state: Optional[CityState] = Field(
        None,
        alias='cityState',
        description='Identifies the city and state of the spot quote stop.',
        title='CityState',
    )
    postal_code: Optional[PostalCode] = Field(
        None,
        alias='postalCode',
        description='Identifies the postal code of the spot quote stop.',
        title='postalCode',
    )


class Facility6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description='The internally defined unique identifier of a facility record.',
    )
    code: Optional[str] = Field(
        None,
        description='The externally defined unique identifier for a facility record.',
    )


class Facility7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined unique identifier of a facility record.',
    )
    code: str = Field(
        ...,
        description='The externally defined unique identifier for a facility record.',
    )


class Location5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility6, Facility7]] = Field(
        None, description='The spot quote stop facility.', title='Facility'
    )
    city_state: CityState = Field(
        ...,
        alias='cityState',
        description='Identifies the city and state of the spot quote stop.',
        title='CityState',
    )
    postal_code: Optional[PostalCode] = Field(
        None,
        alias='postalCode',
        description='Identifies the postal code of the spot quote stop.',
        title='postalCode',
    )


class Facility8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description='The internally defined unique identifier of a facility record.',
    )
    code: Optional[str] = Field(
        None,
        description='The externally defined unique identifier for a facility record.',
    )


class Facility9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined unique identifier of a facility record.',
    )
    code: str = Field(
        ...,
        description='The externally defined unique identifier for a facility record.',
    )


class Location6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility8, Facility9]] = Field(
        None, description='The spot quote stop facility.', title='Facility'
    )
    city_state: Optional[CityState] = Field(
        None,
        alias='cityState',
        description='Identifies the city and state of the spot quote stop.',
        title='CityState',
    )
    postal_code: PostalCode = Field(
        ...,
        alias='postalCode',
        description='Identifies the postal code of the spot quote stop.',
        title='postalCode',
    )


class Stop(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ..., alias='typeTerm', description='The type of stop (e.g., pickup, delivery).'
    )
    sequence_number: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        alias='sequenceNumber',
        description='The number used to notate the order of the stops on a spot quote.',
    )
    live_drop_term: LiveDropTerm = Field(
        ...,
        alias='liveDropTerm',
        description='Indicates the planned activity at a stop (e.g., live, drop, hook).',
    )
    requirement_terms: Optional[List[str]] = Field(
        None,
        alias='requirementTerms',
        description='Any special requirements for the Stop on the quote (e.g. Food Grade, Lift Gate).',
    )
    location: Union[Location4, Location5, Location6] = Field(
        ...,
        description='The physical location of a single stop identified on the spot quote that will match the load.',
        title='Location',
    )


class UnitTerm7(Enum):
    feet = 'feet'
    inches = 'inches'


class MinimumLength(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the minimum required length of equipment.'
    )
    unit_term: UnitTerm7 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the minimum required length of equipment.',
        title='MinimumLengthUnitTerm',
    )


class Width(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the required width of equipment.'
    )
    unit_term: UnitTerm7 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the required width of equipment.',
        title='WidthUnitTerm',
    )


class Height(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the required height of equipment.'
    )
    unit_term: UnitTerm7 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the required height of equipment.',
        title='HeightUnitTerm',
    )


class Dimensions(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    minimum_length: Optional[MinimumLength] = Field(
        None,
        alias='minimumLength',
        description='The minimum required length of equipment.',
    )
    width: Optional[Width] = Field(
        None, description='The minimum required width of equipment.'
    )
    height: Optional[Height] = Field(
        None, description='The minimum required height of equipment.'
    )


class Equipment(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    trailer_type_term: str = Field(
        ...,
        alias='trailerTypeTerm',
        description='The type of equipment needed (e.g. Van, Reefer).',
    )
    dimensions: Optional[Dimensions] = Field(
        None, description='The dimensional requirements of equipment.'
    )


class CustomersIdentifierValuespotQuotesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The externally defined identifier for a spot quote. This is the external quote ID field in the UI.',
    )
    mode_term: str = Field(
        ...,
        alias='modeTerm',
        description='The mode of transportation required (e.g., truck, rail).',
    )
    size_term: str = Field(
        ...,
        alias='sizeTerm',
        description='The truckload size of an order record (e.g., FTL, LTL, partial).',
    )
    lane_type_term: str = Field(
        ...,
        alias='laneTypeTerm',
        description='Defines which load stops match the lane stops (e.g., Multi-Stop, Point-Point). Data Dictionary Term.',
    )
    is_variable_distance_type: bool = Field(
        ...,
        alias='isVariableDistanceType',
        description='Determines whether the distance value will be set at the Spot Quote level or the Order level. A boolean of true indicates Order level, and therefore no calculated rate will be returned for any per-mile rate line items on the Spot Quote. If false, the values in the fixedDistance will be applied and per-mile rate line items will be calculated on the Spot Quote.',
    )
    fixed_distance: Optional[FixedDistance] = Field(
        None,
        alias='fixedDistance',
        description='The distance will be used to calculate per-mile rate line items and will be applied to matching orders. This object should only be used when isVariableDistance is false.',
    )
    quote_fuel_configuration_term: str = Field(
        ...,
        alias='quoteFuelConfigurationTerm',
        description='Determines if fuel is included or excluded as part of the quote.',
    )
    effective_date_time: confloat(ge=1.0, le=2147483647999.0) = Field(
        ...,
        alias='effectiveDateTime',
        description='The effective datetime of the spot quote that will drive quote application to loads.',
    )
    expiration_date_time: confloat(ge=1.0, le=2147483647999.0) = Field(
        ...,
        alias='expirationDateTime',
        description='The expiration date time of the spot quote that will drive quote application to loads.',
    )
    timezone: Timezone = Field(
        ..., description='The local timezone of the user or the system.'
    )
    ship_start_date: date = Field(
        ...,
        alias='shipStartDate',
        description='Lower-bound date of load ship date. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.',
    )
    ship_end_date: date = Field(
        ...,
        alias='shipEndDate',
        description='Upper-bound date of load ship date. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.',
    )
    desired_delivery_date: Optional[date] = Field(
        None,
        alias='desiredDeliveryDate',
        description='Non-binding date that the customer would like the load to deliver. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.',
    )
    division_term: Optional[str] = Field(
        None,
        alias='divisionTerm',
        description='The division associated with the spot quote.',
    )
    service_level_term: str = Field(
        ...,
        alias='serviceLevelTerm',
        description='Identifies the service level for the spot quote  (e.g., standard, expedited).',
    )
    tenant_scac_term: Optional[str] = Field(
        None,
        alias='tenantScacTerm',
        description='The tenant SCAC associated with the spot quote.',
    )
    order_requirement_terms: Optional[List[str]] = Field(
        None,
        alias='orderRequirementTerms',
        description='Any special requirements for the order being quoted (e.g. Hazmat, HRHV, etc.).',
    )
    notes: Optional[str] = Field(
        None,
        description='Free form text field for any notes a user wants to document for the quote.',
    )
    stops: List[Stop] = Field(
        ...,
        description='The physical locations identified on the spot quote that will match the load.',
    )
    equipment: Equipment = Field(
        ...,
        description='The type of equipment needed and all related attributes (e.g. Van, Reefer).',
        title='Equipment',
    )


class DriversDriverCodedriverPayattributesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of attribute (e.g., MPG, Safety Rating). Data Dictionary Term.',
    )
    value: constr(min_length=1) = Field(
        ...,
        description='The value of the attribute. This value field type will be further defined in MasterMind through a client configuration based on the attribute type. A valueTypeTerm will be provided on outbound requests.',
    )
    effective_date: date = Field(
        ...,
        alias='effectiveDate',
        description='The effective date of the attribute. Format YYYY-MM-DD.',
    )
    expiration_date: Optional[date] = Field(
        None,
        alias='expirationDate',
        description='The expiration date of the attribute. Format YYYY-MM-DD.',
    )
    notes: Optional[str] = Field(
        None, description='The notes associated to the attribute.'
    )


class DriversDriverCodedriverPayattributesIdPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    effective_date: Optional[date] = Field(
        None,
        alias='effectiveDate',
        description='The effective date of the attribute. Format YYYY-MM-DD.',
    )
    expiration_date: Optional[date] = Field(
        None,
        alias='expirationDate',
        description='The expiration date of the attribute. Format YYYY-MM-DD.',
    )
    notes: Optional[str] = Field(
        None, description='The notes associated to the attribute.'
    )


class DriversDriverCodedriverPaysettingIdPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    accounting_status_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='accountingStatusTerm',
        description='The accounting status for the driver pay setting (e.g., Active, Hold, New Driver, Inactive). Data Dictionary Term.',
    )
    notes: Optional[str] = Field(
        None, description='The notes associated to the driver pay setting.'
    )
    currency_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='currencyTerm',
        description='The currency value for the driver pay setting (e.g., USD). Data Dictionary Term.',
    )
    voucher_minimum: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='voucherMinimum',
        description='The minimum value allowed on a voucher for the driver.',
    )


class TotalCost(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(..., description='The total amount.')
    currency_code_term: constr(min_length=1) = Field(
        ...,
        alias='currencyCodeTerm',
        description='The currency of the amount. Data Dictionary Term.',
    )


class ApprovedByEmployee(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The externally defined code of the employee that approved the other pay item record.',
    )
    id: Optional[constr(min_length=1)] = Field(
        None,
        description='The internally defined UUID of the employee that approved the other pay item record.',
    )


class ApprovedByEmployee1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Optional[constr(min_length=1)] = Field(
        None,
        description='The externally defined code of the employee that approved the other pay item record.',
    )
    id: constr(min_length=1) = Field(
        ...,
        description='The internally defined UUID of the employee that approved the other pay item record.',
    )


class Approval(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    approved_on: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ...,
        alias='approvedOn',
        description='The date and time the other pay item record was approved.  Unix Timestamp (in milliseconds).',
    )
    approved_by_employee: Union[ApprovedByEmployee, ApprovedByEmployee1] = Field(
        ...,
        alias='approvedByEmployee',
        description='The user who approved the other pay item record.',
        title='ApprovedByEmployee',
    )


class AssignedToEmployee(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The externally defined code of the employee that is assigned the other pay item record.',
    )
    id: Optional[constr(min_length=1)] = Field(
        None,
        description='The internally defined UUID of the employee that is assigned the other pay item record.',
    )


class AssignedToEmployee1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Optional[constr(min_length=1)] = Field(
        None,
        description='The externally defined code of the employee that is assigned the other pay item record.',
    )
    id: constr(min_length=1) = Field(
        ...,
        description='The internally defined UUID of the employee that is assigned the other pay item record.',
    )


class DriversDriverCodeotherPayItemsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='Identifies the type of other pay item record. Data Dictionary Term.',
    )
    total_cost: TotalCost = Field(
        ...,
        alias='totalCost',
        description='The total cost associated with the other pay item record.',
        title='TotalCost',
    )
    approval_status: Optional[constr(min_length=1)] = Field(
        None,
        alias='approvalStatus',
        description='The approval status of the other pay item record.',
    )
    approval: Optional[Approval] = None
    effective_date: date = Field(
        ...,
        alias='effectiveDate',
        description='The date the other pay item record is effective. Format YYYY-MM-DD.',
    )
    assigned_to_employee: Optional[Union[AssignedToEmployee, AssignedToEmployee1]] = (
        Field(
            None,
            alias='assignedToEmployee',
            description='The user assigned to the other pay item record.',
        )
    )
    notes: Optional[str] = Field(
        None, description='The notes for the other pay item record.'
    )


class ApprovedByEmployee2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The externally defined code of the employee that approved the other pay item record.',
    )
    id: Optional[constr(min_length=1)] = Field(
        None,
        description='The internally defined UUID of the employee that approved the other pay item record.',
    )


class ApprovedByEmployee3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Optional[constr(min_length=1)] = Field(
        None,
        description='The externally defined code of the employee that approved the other pay item record.',
    )
    id: constr(min_length=1) = Field(
        ...,
        description='The internally defined UUID of the employee that approved the other pay item record.',
    )


class Approval1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    approved_on: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ...,
        alias='approvedOn',
        description='The date and time the other pay item record was approved.  Unix Timestamp (in milliseconds).',
    )
    approved_by_employee: Union[ApprovedByEmployee2, ApprovedByEmployee3] = Field(
        ...,
        alias='approvedByEmployee',
        description='The user who approved the other pay item record.',
        title='ApprovedByEmployeePatch',
    )


class AssignedToEmployee2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The externally defined code of the employee that is assigned the other pay item record.',
    )
    id: Optional[constr(min_length=1)] = Field(
        None,
        description='The internally defined UUID of the employee that is assigned the other pay item record.',
    )


class AssignedToEmployee3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Optional[constr(min_length=1)] = Field(
        None,
        description='The externally defined code of the employee that is assigned the other pay item record.',
    )
    id: constr(min_length=1) = Field(
        ...,
        description='The internally defined UUID of the employee that is assigned the other pay item record.',
    )


class DriversDriverCodeotherPayItemsIdPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    total_cost: Optional[TotalCost] = Field(
        None,
        alias='totalCost',
        description='The total cost associated with the other pay item record.',
    )
    approval_status: Optional[constr(min_length=1)] = Field(
        None,
        alias='approvalStatus',
        description='The approval status of the other pay item record.',
    )
    approval: Optional[Approval1] = None
    effective_date: Optional[date] = Field(
        None,
        alias='effectiveDate',
        description='The date the other pay item record is effective. Format YYYY-MM-DD.',
    )
    assigned_to_employee: Optional[Union[AssignedToEmployee2, AssignedToEmployee3]] = (
        Field(
            None,
            alias='assignedToEmployee',
            description='The user assigned to the other pay item record.',
        )
    )
    notes: Optional[str] = Field(
        None, description='The notes for the other pay item record.'
    )


class Address4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city: constr(min_length=1) = Field(..., description='The city of the address.')
    state: constr(min_length=2, max_length=3) = Field(
        ..., description='The state of the address (e.g., AZ, AR). ISO 3166-2.'
    )
    country: constr(min_length=3, max_length=3) = Field(
        ...,
        description='The country of the address (e.g., CAN, MEX, USA). ISO 3166-1 Alpha-3.',
    )


class Facility10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined UUID referencing the facility related to this routing request.',
    )
    code: Optional[str] = Field(
        None,
        description='The externally defined code for the facility related to this routing request.',
    )


class Locations(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The location type of the routing request (e.g., City/State or Facility). Data Dictionary Term.',
    )
    addresses: Optional[List[Address4]] = Field(
        None, description='The address of the routing request.'
    )
    facilities: Optional[List[Facility10]] = Field(
        None,
        description='The facilities of a routing request. If this object is provided, then a Facility ID or Facility code is required.',
    )


class DriversDriverCoderoutingRequestPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    status_term: constr(min_length=1) = Field(
        ...,
        alias='statusTerm',
        description='The status of the routing request (e.g., New, Planned, Cancelled, Complete). Data Dictionary Term.',
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The type of routing request (e.g., Home Request, Maintenance, Training). Data Dictionary Term.',
    )
    earliest_arrival_date_time: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ...,
        alias='earliestArrivalDateTime',
        description='The date and time for earliest arrival of a routing request. Unix Timestamp (in milliseconds).',
    )
    latest_arrival_date_time: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ...,
        alias='latestArrivalDateTime',
        description='The date and time of the latest arrival date of a routing request. Unix Timestamp (in milliseconds).',
    )
    locations: Optional[Locations] = Field(
        None, description='The locations of the routing request.'
    )
    timezone: Optional[str] = Field(
        None, description='The timezone of the routing request.'
    )
    notes: Optional[str] = Field(
        None, description='The notes associated to the routing request.'
    )
    is_critical: Optional[bool] = Field(
        None,
        alias='isCritical',
        description="Indicates if the routing request is critical or not. 'Critical' means if the request has to be completed, or can be pushed out. This factors into hard/soft validations for Driver Capacity.",
    )


class Locations1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The location type of the routing request (e.g., City/State or Facility). Data Dictionary Term.',
    )
    addresses: Optional[List[Address4]] = Field(
        None, description='The address of the routing request.'
    )
    facilities: Optional[List[Facility10]] = Field(
        None,
        description='The facilities of a routing request. If this object is provided, then a Facility ID or Facility code is required.',
    )


class DriversDriverCoderoutingRequestIdPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    status_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='statusTerm',
        description='The status of the routing request (e.g., New, Planned, Cancelled, Complete). Data Dictionary Term.',
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='The type of routing request (e.g., Home Request, Maintenance, Training). Data Dictionary Term.',
    )
    earliest_arrival_date_time: Optional[confloat(ge=1.0, le=8640000000000000.0)] = (
        Field(
            None,
            alias='earliestArrivalDateTime',
            description='The date and time for earliest arrival of a routing request. Unix Timestamp (in milliseconds).',
        )
    )
    latest_arrival_date_time: Optional[confloat(ge=1.0, le=8640000000000000.0)] = Field(
        None,
        alias='latestArrivalDateTime',
        description='The date and time of the latest arrival date of a routing request. Unix Timestamp (in milliseconds).',
    )
    locations: Optional[Locations1] = Field(
        None, description='The locations of the routing request.'
    )
    timezone: Optional[str] = Field(
        None, description='The timezone of the routing request.'
    )
    notes: Optional[str] = Field(
        None, description='The notes associated to the routing request.'
    )
    is_critical: Optional[bool] = Field(
        None,
        alias='isCritical',
        description="Indicates if the routing request is critical or not. 'Critical' means if the request has to be completed, or can be pushed out. This factors into hard/soft validations for Driver Capacity.",
    )


class Customer(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined UUID referencing the customer.'
    )
    code: Optional[constr(min_length=1)] = Field(
        None,
        description='The externally defined unique identifier for a customer record.',
    )


class Customer1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined UUID referencing the customer.'
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The externally defined unique identifier for a customer record.',
    )


class Facility12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility13(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class CityState3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city: constr(min_length=1) = Field(
        ..., description='The city of the address of the first location.'
    )
    state: constr(min_length=2, max_length=3) = Field(
        ...,
        description='The state of the address of the first location (e.g., AZ, AR). ISO 3166-2.',
    )
    county: Optional[str] = Field(
        None, description='The county of the address of the first location.'
    )
    country: constr(min_length=3, max_length=3) = Field(
        ...,
        description='The country of the address of first location (i.e. USA, MEX, CAN).',
    )


class Origin2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Union[Facility12, Facility13] = Field(
        ...,
        description='The location of the facility.',
        title='OriginStopCreateFacilityRecord',
    )
    city_state: Optional[CityState3] = Field(
        None,
        alias='cityState',
        description='The city and state of the first stop on an indicated route.',
        title='OriginStopCreateCityStateRecord',
    )


class Facility14(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility15(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class Origin3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility14, Facility15]] = Field(
        None,
        description='The location of the facility.',
        title='OriginStopCreateFacilityRecord',
    )
    city_state: CityState3 = Field(
        ...,
        alias='cityState',
        description='The city and state of the first stop on an indicated route.',
        title='OriginStopCreateCityStateRecord',
    )


class Route(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(..., description='The internally defined UUID for a route record.')
    number: Optional[str] = Field(
        None, description='The internal route number displayed in MasterMind.'
    )


class Route1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID for a route record.'
    )
    number: str = Field(
        ..., description='The internal route number displayed in MasterMind.'
    )


class Facility16(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description='The externally defined unique identifier for a facility record.',
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility17(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The externally defined unique identifier for a facility record.',
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class CityState5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city: constr(min_length=1) = Field(
        ..., description='The city of the address of the last location.'
    )
    state: constr(min_length=2, max_length=3) = Field(
        ...,
        description='The state of the address of the last location (e.g., AZ, AR). ISO 3166-2.',
    )
    county: Optional[str] = Field(
        None, description='The county of the address of the last location.'
    )
    country: constr(min_length=3, max_length=3) = Field(
        ...,
        description='The country of the address of the last location (e.g., CAN, MEX, USA). ISO 3166-1 Alpha-3.',
    )


class Destination2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    route: Union[Route, Route1] = Field(
        ..., description='The route object.', title='DestinationStopRouteRecord'
    )
    facility: Optional[Union[Facility16, Facility17]] = Field(
        None,
        description='The location of the facility of the last stop on an indicated route.',
        title='DestinationStopCreateFacilityRecord',
    )
    city_state: Optional[CityState5] = Field(
        None,
        alias='cityState',
        description='The city and state of the last stop on an indicated route.',
        title='DestinationStopCreateCityStateRecord',
    )


class Route2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(..., description='The internally defined UUID for a route record.')
    number: Optional[str] = Field(
        None, description='The internal route number displayed in MasterMind.'
    )


class Route3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID for a route record.'
    )
    number: str = Field(
        ..., description='The internal route number displayed in MasterMind.'
    )


class Facility18(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description='The externally defined unique identifier for a facility record.',
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility19(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The externally defined unique identifier for a facility record.',
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class Destination3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    route: Optional[Union[Route2, Route3]] = Field(
        None, description='The route object.', title='DestinationStopRouteRecord'
    )
    facility: Union[Facility18, Facility19] = Field(
        ...,
        description='The location of the facility of the last stop on an indicated route.',
        title='DestinationStopCreateFacilityRecord',
    )
    city_state: Optional[CityState5] = Field(
        None,
        alias='cityState',
        description='The city and state of the last stop on an indicated route.',
        title='DestinationStopCreateCityStateRecord',
    )


class Route4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(..., description='The internally defined UUID for a route record.')
    number: Optional[str] = Field(
        None, description='The internal route number displayed in MasterMind.'
    )


class Route5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID for a route record.'
    )
    number: str = Field(
        ..., description='The internal route number displayed in MasterMind.'
    )


class Facility20(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description='The externally defined unique identifier for a facility record.',
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility21(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The externally defined unique identifier for a facility record.',
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class Destination4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    route: Optional[Union[Route4, Route5]] = Field(
        None, description='The route object.', title='DestinationStopRouteRecord'
    )
    facility: Optional[Union[Facility20, Facility21]] = Field(
        None,
        description='The location of the facility of the last stop on an indicated route.',
        title='DestinationStopCreateFacilityRecord',
    )
    city_state: CityState5 = Field(
        ...,
        alias='cityState',
        description='The city and state of the last stop on an indicated route.',
        title='DestinationStopCreateCityStateRecord',
    )


class DriversIdentifierValueemptyMovementDispatchesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    driver_activity_term: constr(min_length=1) = Field(
        ...,
        alias='driverActivityTerm',
        description='Determines Empty Activity for Driver being dispatched (e.g., ExecuteRoute, Reposition). Data Dictionary Term.',
    )
    customer: Union[Customer, Customer1] = Field(
        ...,
        description='The customer associated to the empty movement dispatch.',
        title='CustomerRecord',
    )
    origin: Union[Origin2, Origin3] = Field(
        ...,
        description='The type of location that defines the first stop of an indicated route.',
        title='OriginStopPostRecord',
    )
    destination: Union[Destination2, Destination3, Destination4] = Field(
        ...,
        description='Identifies the location for a stop record.',
        title='DestinationStopPostRecord',
    )


class EmergencyContact(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: Optional[str] = Field(
        None, description="The employee's emergency contact's name."
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='phoneNumber',
        description="The employee's emergency contact's phone number.",
    )
    relationship: Optional[str] = Field(
        None, description='The relationship of the emergency contact to the employee.'
    )


class Manager(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description="The internally defined UUID for an employee's manager record"
    )
    code: Optional[str] = Field(
        None,
        description="The externally defined code for an employee's manager record.",
    )


class EmployeesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally defined code for an employee record.'
    )
    first_name: constr(min_length=1) = Field(
        ..., alias='firstName', description="The employee's first name."
    )
    last_name: constr(min_length=1) = Field(
        ..., alias='lastName', description="The employee's last name."
    )
    middle_name: Optional[str] = Field(
        None, alias='middleName', description="The employee's middle name."
    )
    suffix_term: Optional[str] = Field(
        None, alias='suffixTerm', description="The employee's suffix (e.g., jr, sr)."
    )
    display_name: Optional[str] = Field(
        None,
        alias='displayName',
        description="The employee's name as it will be displayed.",
    )
    user_email: EmailStr = Field(
        ..., alias='userEmail', description="The employee's email used to login."
    )
    slack_name: Optional[str] = Field(
        None, alias='slackName', description="The employee's Slack user name."
    )
    nick_name: Optional[str] = Field(
        None, alias='nickName', description="The employee's nickname or preferred name."
    )
    personal_email: Optional[EmailStr] = Field(
        None, alias='personalEmail', description="The employee's personal email."
    )
    mobile_phone: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None, alias='mobilePhone', description="The employee's mobile phone number."
    )
    emergency_contact: Optional[EmergencyContact] = Field(
        None,
        alias='emergencyContact',
        description="The employee's emergency contact details.",
    )
    role_term: Optional[str] = Field(
        None,
        alias='roleTerm',
        description="The employee's role within the organization.",
    )
    company_level_term: Optional[str] = Field(
        None,
        alias='companyLevelTerm',
        description="The employee's level within a company.",
    )
    status_term: str = Field(
        ...,
        alias='statusTerm',
        description="The empoyee's status within the organization.",
    )
    office_term: Optional[str] = Field(
        None, alias='officeTerm', description="The employee's primary office location."
    )
    manager: Optional[Manager] = Field(
        None, description="An employee's manager record."
    )
    department_term: Optional[str] = Field(
        None, alias='departmentTerm', description="The employee's department."
    )
    department_level_term: Optional[str] = Field(
        None,
        alias='departmentLevelTerm',
        description="The employee's level within a department.",
    )
    employee_type_term: Optional[str] = Field(
        None,
        alias='employeeTypeTerm',
        description="The employee's employment type (e.g., full-time, part-time).",
    )
    title: Optional[str] = Field(None, description="The employee's title.")
    hire_date: Optional[date] = Field(
        None,
        alias='hireDate',
        description='The date the employee was hired with the company. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.',
    )
    term_date: Optional[date] = Field(
        None,
        alias='termDate',
        description='The date the employee was terminated with the company. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.',
    )
    company_email: Optional[EmailStr] = Field(
        None,
        alias='companyEmail',
        description="The employee's company email address; this is also used for notifications.",
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(None, alias='phoneNumber', description="The employee's phone number.")
    extension: Optional[str] = Field(
        None, description="The employee's phone number extension."
    )
    is_all_divisions: Optional[bool] = Field(
        None,
        alias='isAllDivisions',
        description='Indicates if the employee is part of all divisions.',
    )
    division_term: Optional[str] = Field(
        None,
        alias='divisionTerm',
        description="The employee's primary division within the organization.",
    )
    additional_division_terms: Optional[List[str]] = Field(
        None,
        alias='additionalDivisionTerms',
        description="The employee's additional divisions within the organization.",
    )


class EmployeesIdentifierValuePATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    first_name: Optional[str] = Field(
        None, alias='firstName', description="The employee's first name."
    )
    last_name: Optional[str] = Field(
        None, alias='lastName', description="The employee's last name."
    )
    middle_name: Optional[str] = Field(
        None, alias='middleName', description="The employee's middle name."
    )
    suffix_term: Optional[str] = Field(
        None, alias='suffixTerm', description="The employee's suffix (e.g., jr, sr)."
    )
    display_name: Optional[str] = Field(
        None,
        alias='displayName',
        description="The employee's name as it will be displayed.",
    )
    user_email: Optional[EmailStr] = Field(
        None, alias='userEmail', description="The employee's email used to login."
    )
    slack_name: Optional[str] = Field(
        None, alias='slackName', description="The employee's Slack user name."
    )
    nick_name: Optional[str] = Field(
        None, alias='nickName', description="The employee's nickname or preferred name."
    )
    personal_email: Optional[EmailStr] = Field(
        None, alias='personalEmail', description="The employee's personal email."
    )
    mobile_phone: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None, alias='mobilePhone', description="The employee's mobile phone number."
    )
    emergency_contact: Optional[EmergencyContact] = Field(
        None,
        alias='emergencyContact',
        description="The employee's emergency contact details.",
    )
    role_term: Optional[str] = Field(
        None,
        alias='roleTerm',
        description="The employee's role within the organization.",
    )
    company_level_term: Optional[str] = Field(
        None,
        alias='companyLevelTerm',
        description="The employee's level within a company.",
    )
    status_term: Optional[str] = Field(
        None,
        alias='statusTerm',
        description="The empoyee's status within the organization.",
    )
    office_term: Optional[str] = Field(
        None, alias='officeTerm', description="The employee's primary office location."
    )
    manager: Optional[Manager] = Field(
        None, description="An employee's manager record."
    )
    department_term: Optional[str] = Field(
        None, alias='departmentTerm', description="The employee's department."
    )
    department_level_term: Optional[str] = Field(
        None,
        alias='departmentLevelTerm',
        description="The employee's level within a department.",
    )
    employee_type_term: Optional[str] = Field(
        None,
        alias='employeeTypeTerm',
        description="The employee's employment type (e.g., full-time, part-time).",
    )
    title: Optional[str] = Field(None, description="The employee's title.")
    hire_date: Optional[date] = Field(
        None,
        alias='hireDate',
        description='The date the employee was hired with the company. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.',
    )
    term_date: Optional[date] = Field(
        None,
        alias='termDate',
        description='The date the employee was terminated with the company. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.',
    )
    company_email: Optional[EmailStr] = Field(
        None,
        alias='companyEmail',
        description="The employee's company email address; this is also used for notifications.",
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(None, alias='phoneNumber', description="The employee's phone number.")
    extension: Optional[str] = Field(
        None, description="The employee's phone number extension."
    )
    is_all_divisions: Optional[bool] = Field(
        None,
        alias='isAllDivisions',
        description='Indicates if the employee is part of all divisions.',
    )
    division_term: Optional[str] = Field(
        None,
        alias='divisionTerm',
        description="The employee's primary division within the organization.",
    )
    additional_division_terms: Optional[List[str]] = Field(
        None,
        alias='additionalDivisionTerms',
        description="The employee's additional divisions within the organization.",
    )


class Customer2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined UUID referencing the customer.'
    )
    code: Optional[constr(min_length=1)] = Field(
        None, description='The externally defined code referencing the customer.'
    )


class Customer3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined UUID referencing the customer.'
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally defined code referencing the customer.'
    )


class CodeAndCustomer(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally defined code referencing the order.'
    )
    customer: Union[Customer2, Customer3] = Field(
        ...,
        description='The customer identifiers associated to the external invoice.',
        title='CustomerRecord',
    )


class Order(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined UUID referencing the order.'
    )
    number: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined number referencing the order.'
    )
    code_and_customer: Optional[CodeAndCustomer] = Field(
        None,
        alias='codeAndCustomer',
        description='The order code and customer identifiers associated to the external invoice.',
        title='CodeAndCustomerRecord',
    )


class Customer4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined UUID referencing the customer.'
    )
    code: Optional[constr(min_length=1)] = Field(
        None, description='The externally defined code referencing the customer.'
    )


class Customer5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined UUID referencing the customer.'
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally defined code referencing the customer.'
    )


class CodeAndCustomer1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally defined code referencing the order.'
    )
    customer: Union[Customer4, Customer5] = Field(
        ...,
        description='The customer identifiers associated to the external invoice.',
        title='CustomerRecord',
    )


class Order1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined UUID referencing the order.'
    )
    number: constr(min_length=1) = Field(
        ..., description='The internally defined number referencing the order.'
    )
    code_and_customer: Optional[CodeAndCustomer1] = Field(
        None,
        alias='codeAndCustomer',
        description='The order code and customer identifiers associated to the external invoice.',
        title='CodeAndCustomerRecord',
    )


class Customer6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined UUID referencing the customer.'
    )
    code: Optional[constr(min_length=1)] = Field(
        None, description='The externally defined code referencing the customer.'
    )


class Customer7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined UUID referencing the customer.'
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally defined code referencing the customer.'
    )


class CodeAndCustomer2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally defined code referencing the order.'
    )
    customer: Union[Customer6, Customer7] = Field(
        ...,
        description='The customer identifiers associated to the external invoice.',
        title='CustomerRecord',
    )


class Order2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined UUID referencing the order.'
    )
    number: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined number referencing the order.'
    )
    code_and_customer: CodeAndCustomer2 = Field(
        ...,
        alias='codeAndCustomer',
        description='The order code and customer identifiers associated to the external invoice.',
        title='CodeAndCustomerRecord',
    )


class Identifiers(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    order: Union[Order, Order1, Order2] = Field(
        ...,
        description='The order identifiers associated to the external invoice.',
        title='OrderRecord',
    )


class ExternalInvoicesPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    identifiers: Identifiers = Field(
        ...,
        description='The identifiers associated to an external invoice.',
        title='IdentifiersRecord',
    )
    is_invoiced_externally: Optional[bool] = Field(
        None,
        alias='isInvoicedExternally',
        description='Indicates if the order has been invoiced in an external system.',
    )
    is_settled_externally: Optional[bool] = Field(
        None,
        alias='isSettledExternally',
        description='Indicates if the invoice has been settled in an external system.',
    )


class Route6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined UUID referencing the route.'
    )
    number: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined number referencing the route.'
    )


class Route7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined UUID referencing the route.'
    )
    number: constr(min_length=1) = Field(
        ..., description='The internally defined number referencing the route.'
    )


class Carrier2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ...,
        description='The internally defined UUID referencing the carrier or vendor record assigned to the route.',
    )
    code: Optional[constr(min_length=1)] = Field(
        None,
        description='The externally defined code referencing the carrier or vendor record assigned to the route.',
    )


class Carrier3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None,
        description='The internally defined UUID referencing the carrier or vendor record assigned to the route.',
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The externally defined code referencing the carrier or vendor record assigned to the route.',
    )


class Identifiers1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    route: Union[Route6, Route7] = Field(
        ...,
        description='The identifiers of the route associated with the external voucher.',
        title='RouteRecord',
    )
    carrier: Union[Carrier2, Carrier3] = Field(
        ...,
        description='The identifiers of the carrier or vendor associated with the external voucher.',
        title='CarrierRecord',
    )


class ExternalVouchersPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    identifiers: Identifiers1 = Field(
        ...,
        description='The identifiers associated with an external voucher.',
        title='IdentifiersRecord',
    )
    is_vouchered_externally: Optional[bool] = Field(
        None,
        alias='isVoucheredExternally',
        description='Indicates if the carrier or vendor has been vouchered in an external system.',
    )
    is_settled_externally: Optional[bool] = Field(
        None,
        alias='isSettledExternally',
        description='Indicates if the voucher has been settled in an external system.',
    )


class Status(Enum):
    new = 'New'
    active = 'active'
    duplicate = 'duplicate'
    inactive = 'inactive'
    system_generated = 'systemGenerated'


class Provided(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    latitude: confloat(ge=-90.0, le=90.0) = Field(
        ..., description='The latitude coordinate.'
    )
    longitude: confloat(ge=-180.0, le=180.0) = Field(
        ..., description='The longitude coordinate.'
    )


class Coordinates(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provided: Optional[Provided] = Field(
        None, description='The provided coordinates of the address.'
    )


class Address6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The facility address type. Data Dictionary Term.',
    )
    street1: constr(min_length=1) = Field(..., description='The street address.')
    street2: Optional[str] = Field(None, description='The additional street address.')
    city: constr(min_length=1) = Field(..., description='The city of the address.')
    state: constr(min_length=1) = Field(
        ..., description='The state of the address (e.g., AZ, AR). ISO 3166-2.'
    )
    country: constr(min_length=1) = Field(
        ...,
        description='The country of the address (e.g., CAN, MEX, USA). ISO 3166-1 Alpha-3.',
    )
    postal_code: constr(min_length=1) = Field(
        ..., alias='postalCode', description='The postal code of the address.'
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description='This is where a user can flag to indicate a facility address as the `Main` address.',
    )
    coordinates: Optional[Coordinates] = Field(
        None, description='The coordinates of the address.'
    )


class InstantMessenger8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description="The facility contact's instant-messaging service type (e.g., Google, Skype, WhatsApp). Data Dictionary Term.",
    )
    user_name: constr(min_length=1) = Field(
        ...,
        alias='userName',
        description="The facility contact's instant-messaging username related to the service type. If a service type is indicated then a username must be provided.",
    )


class Contact4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The facility contact type. Data Dictionary Term.',
    )
    name: constr(min_length=1) = Field(..., description='The name of the contact.')
    email_address: Optional[EmailStr] = Field(
        None, alias='emailAddress', description='The email address of the contact.'
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(None, alias='phoneNumber', description='The phone number of the contact.')
    extension: Optional[str] = Field(
        None, description='The extension of the phone number.'
    )
    fax_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(None, alias='faxNumber', description='The fax number of the contact.')
    is_main: Optional[bool] = Field(
        None,
        alias='isMain',
        description='Indicates if the contact is the main contact associated with the facility.',
    )
    instant_messenger: Optional[InstantMessenger8] = Field(
        None,
        alias='instantMessenger',
        description="This is where the facility contact's instant-messaging fields are included.",
    )


class Identifier4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description="The facility's identifier system type (e.g., DUNS, Facility Name, Ramp Name (Spell), RMIS, SPLC). Data Dictionary Term.",
    )
    value: constr(min_length=1) = Field(
        ..., description="The value for the corresponding facility's identifier system."
    )


class Direction(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    from_: constr(min_length=1) = Field(
        ...,
        alias='from',
        description='The origin of the directions. It can either be cardinal direction (e.g., North, South) or city/state (e.g., Omaha, NE) with a geo location lookup.',
    )
    description: Optional[str] = Field(
        None, description='The title description of the set of directions.'
    )
    average_time: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='averageTime',
        description='The average time (in minutes) that it will take to arrive to the facility.',
    )
    directions: constr(min_length=1) = Field(
        ...,
        description='The details of the steps or actions to take when following a set of directions to the facility.',
    )


class AppointmentTypeTerm(Enum):
    appt = 'appt'
    notice = 'notice'
    open = 'open'


class DropTypeTerm(Enum):
    drop_empty_wait = 'dropEmptyWait'
    drop_avail = 'dropAvail'
    bobtail_hook_empty = 'bobtailHookEmpty'
    drop_loaded_bobtail = 'dropLoadedBobtail'
    drop_only = 'dropOnly'
    live = 'live'


class ScheduleTypeTerm(Enum):
    both = 'both'
    in_ = 'in'
    out = 'out'


class WorkTypeTerm(Enum):
    driver_assist = 'driverAssist'
    lumper = 'lumper'
    no_touch = 'noTouch'


class Hours(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    start_offset_ms: confloat(le=8640000000000000.0) = Field(
        ...,
        alias='startOffsetMs',
        description='The start time of the facility of the day.',
    )
    end_offset_ms: confloat(le=8640000000000000.0) = Field(
        ..., alias='endOffsetMs', description='The end time of the facility of the day.'
    )


class Monday(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours] = None


class Tuesday(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours] = None


class Wednesday(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours] = None


class Thursday(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours] = None


class Friday(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours] = None


class Saturday(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours] = None


class Sunday(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours] = None


class Schedule(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    appointment_type_term: AppointmentTypeTerm = Field(
        ...,
        alias='appointmentTypeTerm',
        description="The type of appointment that is required for the facility's schedule (e.g., Appt, Notice, Open).",
    )
    drop_type_term: DropTypeTerm = Field(
        ...,
        alias='dropTypeTerm',
        description='The drop type for how the facility would like loads being handled on their premises (e.g., Drop Avail, Live, Drop, Bobtail hook empty).',
    )
    mode_type_term: constr(min_length=1) = Field(
        ...,
        alias='modeTypeTerm',
        description='The type of transportation mode for the particular schedule (e.g., Truck, Rail, Air, Ocean). Data Dictionary Term.',
    )
    trailer_type_term: Optional[str] = Field(
        None,
        alias='trailerTypeTerm',
        description='The type of equipment being handled during a scheduled time at the facility (e.g., Reefer, Van, Flat Rack). Data Dictionary Term.',
    )
    services_type_term: Optional[str] = Field(
        None,
        alias='servicesTypeTerm',
        description="The services at the facility when the mode type is 'Rail' (e.g., Gate, Ramp Lift). It will only be applicable when the mode type is 'Rail'. Data Dictionary Term.",
    )
    schedule_type_term: ScheduleTypeTerm = Field(
        ...,
        alias='scheduleTypeTerm',
        description='The direction of the movement at the facility during the schedule (e.g., In, Out).',
    )
    work_type_term: WorkTypeTerm = Field(
        ...,
        alias='workTypeTerm',
        description='The type of work available for handling loads at the facility (e.g., Driver, Lumper, No Touch).',
    )
    size_type_term: Optional[str] = Field(
        None,
        alias='sizeTypeTerm',
        description='The size of load this facility schedule will handle (e.g., FTL, LTL, Partial). Data Dictionary Term.',
    )
    temperatures_type_term: Optional[List[str]] = Field(
        None,
        alias='temperaturesTypeTerm',
        description='The specific types of temperature (e.g., Ambient, Frozen, Refrigerated) of commodities the facility accommodates during the operating hours. Data Dictionary Term.',
    )
    monday: Optional[Monday] = Field(
        None, description='The facility weekday of Monday.'
    )
    tuesday: Optional[Tuesday] = Field(
        None, description='The facility weekday of Tuesday.'
    )
    wednesday: Optional[Wednesday] = Field(
        None, description='The facility weekday of Wednesday.'
    )
    thursday: Optional[Thursday] = Field(
        None, description='The facility weekday of Thursday.'
    )
    friday: Optional[Friday] = Field(
        None, description='The facility weekday of Friday.'
    )
    saturday: Optional[Saturday] = Field(
        None, description='The facility weekday of Saturday.'
    )
    sunday: Optional[Sunday] = Field(
        None, description='The facility weekday of Sunday.'
    )


class FacilitiesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally defined code referencing the facility.'
    )
    name: constr(min_length=1) = Field(..., description='The facility name.')
    status: Status = Field(..., description='The standing status of the facility.')
    type_term: constr(min_length=1) = Field(
        ..., alias='typeTerm', description='The user defined facility type.'
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='phoneNumber',
        description="This is where a facility's phone number will be displayed in General Information.",
    )
    addresses: List[Address6] = Field(
        ...,
        description='A collection of addresses associated with the Facility. At least one address is required.',
        min_length=1,
    )
    contacts: Optional[List[Contact4]] = Field(
        None,
        description='A collection of contacts associated with the Facility. Contacts are not required, but if a contact is included it must include one of the following fields: emailAddress, phoneNumber, faxNumber, InstantMessenger.',
    )
    scheduling_system: Optional[str] = Field(
        None,
        alias='schedulingSystem',
        description="This is where a facility's Scheduling System would be displayed in the TMS. Predefined value selected by user.",
    )
    internal_notes: Optional[str] = Field(
        None, alias='internalNotes', description='The internal free-form text notes.'
    )
    external_notes: Optional[str] = Field(
        None,
        alias='externalNotes',
        description='The external notes that will be generated on Rate Confirmations when a facility is associated to a stop.',
    )
    scale_notes: Optional[str] = Field(None, alias='scaleNotes', description='')
    is_tax_exempt: Optional[bool] = Field(
        None, alias='isTaxExempt', description='Indicates if a facility is tax exempt.'
    )
    load_from_term: Optional[str] = Field(
        None,
        alias='loadFromTerm',
        description="The facility's preference on where a truck should be loaded from (e.g., Tail Only, Side Only, Tail or Side). Data Dictionary Term.",
    )
    unload_from_term: Optional[str] = Field(
        None,
        alias='unloadFromTerm',
        description="The facility's preference on where a truck should be unloaded from (e.g., Tail Only, Side Only, Tail or Side). Data Dictionary Term.",
    )
    scheduling_contact: Optional[str] = Field(
        None,
        alias='schedulingContact',
        description='The scheduling contact at the facility.',
    )
    identifiers: Optional[List[Identifier4]] = Field(
        None,
        description='A collection of keys associated with the Facility to identify them throughout the clients organization. Identifiers are not required.',
    )
    directions: Optional[List[Direction]] = Field(
        None,
        description='A collection of objects providing directions to the facility. Directions are not required.',
    )
    schedules: Optional[List[Schedule]] = Field(
        None, description='A collection of schedules associated with the facility.'
    )


class Coordinates1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provided: Optional[Provided] = Field(
        None, description='The provided coordinates of the address.'
    )


class Address7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(None, description='The unique facility address ID.')
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if the facility address should be destroyed.',
    )
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The facility address type. Data Dictionary Term.',
    )
    street1: Optional[str] = Field(None, description='The street address.')
    street2: Optional[str] = Field(None, description='The additional street address.')
    city: Optional[str] = Field(None, description='The city of the address.')
    state: Optional[str] = Field(
        None, description='The state of the address (e.g., AZ, AR). ISO 3166-2.'
    )
    country: Optional[str] = Field(
        None,
        description='The country of the address (e.g., CAN, MEX, USA). ISO 3166-1 Alpha-3.',
    )
    postal_code: Optional[str] = Field(
        None, alias='postalCode', description='The postal code of the address.'
    )
    is_main: Optional[bool] = Field(
        None,
        alias='isMain',
        description='This is where a user can flag to indicate a facility address as the `Main` address.',
    )
    coordinates: Optional[Coordinates1] = Field(
        None, description='The coordinates of the address.'
    )


class InstantMessenger9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description="The facility contact's instant-messaging service type (e.g., Google, Skype, WhatsApp). Data Dictionary Term.",
    )
    user_name: Optional[str] = Field(
        None,
        alias='userName',
        description="The facility contact's instant-messaging username related to the service type. If a service type is indicated then a username must be provided.",
    )


class Contact5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(None, description='The unique facility contact ID.')
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if the facility contact should be destroyed.',
    )
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The facility contact type. Data Dictionary Term.',
    )
    name: Optional[str] = Field(None, description='The name of the contact.')
    email_address: Optional[EmailStr] = Field(
        None, alias='emailAddress', description='The email address of the contact.'
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(None, alias='phoneNumber', description='The phone number of the contact.')
    extension: Optional[str] = Field(
        None, description='The extension of the phone number.'
    )
    fax_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(None, alias='faxNumber', description='The fax number of the contact.')
    is_main: Optional[bool] = Field(
        None,
        alias='isMain',
        description='Indicates if the contact is the main contact associated with the facility.',
    )
    instant_messenger: Optional[InstantMessenger9] = Field(
        None,
        alias='instantMessenger',
        description="This is where the facility contact's instant-messaging fields are included.",
    )


class Identifier5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(None, description='The unique facility identifier ID.')
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if the facility identifier should be destroyed.',
    )
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description="The facility's identifier system type (e.g., DUNS, Facility Name, Ramp Name (Spell), RMIS, SPLC). Data Dictionary Term.",
    )
    value: Optional[str] = Field(
        None,
        description="The value for the corresponding facility's identifier system.",
    )


class Hours7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    start_offset_ms: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='startOffsetMs',
        description='The start time of the facility of the day.',
    )
    end_offset_ms: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='endOffsetMs',
        description='The end time of the facility of the day.',
    )


class Monday1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: Optional[bool] = Field(
        None,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours7] = None


class Tuesday1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: Optional[bool] = Field(
        None,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours7] = None


class Wednesday1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: Optional[bool] = Field(
        None,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours7] = None


class Thursday1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: Optional[bool] = Field(
        None,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours7] = None


class Friday1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: Optional[bool] = Field(
        None,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours7] = None


class Saturday1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: Optional[bool] = Field(
        None,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours7] = None


class Sunday1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: Optional[bool] = Field(
        None,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours7] = None


class Schedule1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(None, description='The unique facility schedule ID.')
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if the facility schedule should be destroyed.',
    )
    appointment_type_term: Optional[AppointmentTypeTerm] = Field(
        None,
        alias='appointmentTypeTerm',
        description="The type of appointment that is required for the facility's schedule (e.g., Appt, Notice, Open).",
    )
    drop_type_term: Optional[DropTypeTerm] = Field(
        None,
        alias='dropTypeTerm',
        description='The drop type for how the facility would like loads being handled on their premises (e.g., Drop Avail, Live, Drop, Bobtail hook empty).',
    )
    mode_type_term: Optional[str] = Field(
        None,
        alias='modeTypeTerm',
        description='The type of transportation mode for the particular schedule (e.g., Truck, Rail, Air, Ocean). Data Dictionary Term.',
    )
    size_type_term: Optional[str] = Field(
        None,
        alias='sizeTypeTerm',
        description='The size of load this facility schedule will handle (e.g., FTL, LTL, Partial). Data Dictionary Term.',
    )
    temperatures_type_term: Optional[List[str]] = Field(
        None,
        alias='temperaturesTypeTerm',
        description='The specific types of temperature (e.g., Ambient, Frozen, Refrigerated) of commodities the facility accommodates during the operating hours. Data Dictionary Term.',
    )
    trailer_type_term: Optional[str] = Field(
        None,
        alias='trailerTypeTerm',
        description='The type of equipment being handled during a scheduled time at the facility (e.g., Reefer, Van, Flat Rack). Data Dictionary Term.',
    )
    services_type_term: Optional[str] = Field(
        None,
        alias='servicesTypeTerm',
        description="The services at the facility when the mode type is 'Rail' (e.g., Gate, Ramp Lift). It will only be applicable when the mode type is 'Rail'. Data Dictionary Term.",
    )
    schedule_type_term: Optional[ScheduleTypeTerm] = Field(
        None,
        alias='scheduleTypeTerm',
        description='The direction of the movement at the facility during the schedule (e.g., In, Out).',
    )
    work_type_term: Optional[WorkTypeTerm] = Field(
        None,
        alias='workTypeTerm',
        description='The type of work available for handling loads at the facility (e.g., Driver, Lumper, No Touch).',
    )
    monday: Optional[Monday1] = Field(
        None, description='The facility weekday of Monday.'
    )
    tuesday: Optional[Tuesday1] = Field(
        None, description='The facility weekday of Tuesday.'
    )
    wednesday: Optional[Wednesday1] = Field(
        None, description='The facility weekday of Wednesday.'
    )
    thursday: Optional[Thursday1] = Field(
        None, description='The facility weekday of Thursday.'
    )
    friday: Optional[Friday1] = Field(
        None, description='The facility weekday of Friday.'
    )
    saturday: Optional[Saturday1] = Field(
        None, description='The facility weekday of Saturday.'
    )
    sunday: Optional[Sunday1] = Field(
        None, description='The facility weekday of Sunday.'
    )


class Direction1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(None, description='The unique facility direction ID.')
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if the facility direction should be destroyed.',
    )
    from_: Optional[str] = Field(
        None,
        alias='from',
        description='The origin of the directions. It can either be cardinal direction (e.g., North, South) or city/state (e.g., Omaha, NE) with a geo location lookup.',
    )
    description: Optional[str] = Field(
        None, description='The title description of the set of directions.'
    )
    average_time: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='averageTime',
        description='The average time (in minutes) that it will take to arrive to the facility.',
    )
    directions: Optional[str] = Field(
        None,
        description='The details of the steps or actions to take when following a set of directions to the facility.',
    )


class FacilitiesFacilityCodePATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: Optional[str] = Field(None, description='The facility name.')
    status: Optional[Status] = Field(
        None, description='The standing status of the facility.'
    )
    type_term: Optional[str] = Field(
        None, alias='typeTerm', description='The user defined facility type.'
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='phoneNumber',
        description="This is where a facility's phone number will be displayed in General Information.",
    )
    addresses: Optional[List[Address7]] = Field(
        None,
        description='A collection of addresses associated with the Facility. At least one address is required.',
    )
    contacts: Optional[List[Contact5]] = Field(
        None,
        description='A collection of contacts associated with the Facility. Contacts are not required, but if a contact is included it must include one of the following fields: emailAddress, phoneNumber, faxNumber, InstantMessenger.',
    )
    internal_notes: Optional[str] = Field(
        None, alias='internalNotes', description='The internal free-form text notes.'
    )
    external_notes: Optional[str] = Field(
        None,
        alias='externalNotes',
        description='The external notes that will be generated on Rate Confirmations when a facility is associated to a stop.',
    )
    scale_notes: Optional[str] = Field(None, alias='scaleNotes', description='')
    identifiers: Optional[List[Identifier5]] = Field(
        None,
        description='A collection of keys associated with the Facility to identify them throughout the clients organization. Identifiers are not required.',
    )
    is_tax_exempt: Optional[bool] = Field(
        None, alias='isTaxExempt', description='Indicates if a facility is tax exempt.'
    )
    load_from_term: Optional[str] = Field(
        None,
        alias='loadFromTerm',
        description="The facility's preference on where a truck should be loaded from (e.g., Tail Only, Side Only, Tail or Side). Data Dictionary Term.",
    )
    unload_from_term: Optional[str] = Field(
        None,
        alias='unloadFromTerm',
        description="The facility's preference on where a truck should be unloaded from (e.g., Tail Only, Side Only, Tail or Side). Data Dictionary Term.",
    )
    schedules: Optional[List[Schedule1]] = Field(
        None, description='A collection of schedules associated with the facility.'
    )
    scheduling_contact: Optional[str] = Field(
        None,
        alias='schedulingContact',
        description='The scheduling contact at the facility.',
    )
    directions: Optional[List[Direction1]] = Field(
        None,
        description='A collection of objects providing directions to the facility. Directions are not required.',
    )


class Coordinates2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provided: Optional[Provided] = Field(
        None, description='The provided coordinates of the address.'
    )


class FacilitiesFacilityCodeaddressesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The facility address type. Data Dictionary Term.',
    )
    street1: constr(min_length=1) = Field(..., description='The street address.')
    street2: Optional[str] = Field(None, description='The additional street address.')
    city: constr(min_length=1) = Field(..., description='The city of the address.')
    state: constr(min_length=1) = Field(
        ..., description='The state of the address (e.g., AZ, AR). ISO 3166-2.'
    )
    country: constr(min_length=1) = Field(
        ...,
        description='The country of the address (e.g., CAN, MEX, USA). ISO 3166-1 Alpha-3.',
    )
    postal_code: constr(min_length=1) = Field(
        ..., alias='postalCode', description='The postal code of the address.'
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description='This is where a user can flag to indicate a facility address as the `Main` address.',
    )
    coordinates: Optional[Coordinates2] = Field(
        None, description='The coordinates of the address.'
    )


class Coordinates3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provided: Optional[Provided] = Field(
        None, description='The provided coordinates of the address.'
    )


class FacilitiesFacilityCodeaddressesAddressIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The facility address type. Data Dictionary Term.',
    )
    street1: constr(min_length=1) = Field(..., description='The street address.')
    street2: Optional[str] = Field(None, description='The additional street address.')
    city: constr(min_length=1) = Field(..., description='The city of the address.')
    state: constr(min_length=1) = Field(
        ..., description='The state of the address (e.g., AZ, AR). ISO 3166-2.'
    )
    country: constr(min_length=1) = Field(
        ...,
        description='The country of the address (e.g., CAN, MEX, USA). ISO 3166-1 Alpha-3.',
    )
    postal_code: constr(min_length=1) = Field(
        ..., alias='postalCode', description='The postal code of the address.'
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description='This is where a user can flag to indicate a facility address as the `Main` address.',
    )
    coordinates: Optional[Coordinates3] = Field(
        None, description='The coordinates of the address.'
    )


class InstantMessenger10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description="The facility contact's instant-messaging service type (e.g., Google, Skype, WhatsApp). Data Dictionary Term.",
    )
    user_name: constr(min_length=1) = Field(
        ...,
        alias='userName',
        description="The facility contact's instant-messaging username related to the service type. If a service type is indicated then a username must be provided.",
    )


class FacilitiesFacilityCodecontactsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The facility contact type. Data Dictionary Term.',
    )
    name: constr(min_length=1) = Field(..., description='The name of the contact.')
    email_address: Optional[EmailStr] = Field(
        None, alias='emailAddress', description='The email address of the contact.'
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(None, alias='phoneNumber', description='The phone number of the contact.')
    extension: Optional[str] = Field(
        None, description='The extension of the phone number.'
    )
    fax_number: Optional[str] = Field(
        None, alias='faxNumber', description='The fax number of the contact.'
    )
    is_main: Optional[bool] = Field(
        None,
        alias='isMain',
        description='Indicates if the contact is the main contact associated with the facility.',
    )
    instant_messenger: Optional[InstantMessenger10] = Field(
        None,
        alias='instantMessenger',
        description="This is where the facility contact's instant-messaging fields are included.",
    )


class FacilitiesFacilityCodecontactsContactIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The facility contact type. Data Dictionary Term.',
    )
    name: constr(min_length=1) = Field(..., description='The name of the contact.')
    email_address: Optional[EmailStr] = Field(
        None, alias='emailAddress', description='The email address of the contact.'
    )
    phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(None, alias='phoneNumber', description='The phone number of the contact.')
    extension: Optional[str] = Field(
        None, description='The extension of the phone number.'
    )
    fax_number: Optional[str] = Field(
        None, alias='faxNumber', description='The fax number of the contact.'
    )
    is_main: Optional[bool] = Field(
        None,
        alias='isMain',
        description='Indicates if the contact is the main contact associated with the facility.',
    )
    instant_messenger: Optional[InstantMessenger10] = Field(
        None,
        alias='instantMessenger',
        description="This is where the facility contact's instant-messaging fields are included.",
    )


class FacilitiesFacilityCodedirectionsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    from_: constr(min_length=1) = Field(
        ...,
        alias='from',
        description='The origin of the directions. It can either be cardinal direction (e.g., North, South) or city/state (e.g., Omaha, NE) with a geo location lookup.',
    )
    description: Optional[str] = Field(
        None, description='The title description of the set of directions.'
    )
    average_time: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='averageTime',
        description='The average time (in minutes) that it will take to arrive to the facility.',
    )
    directions: constr(min_length=1) = Field(
        ...,
        description='The details of the steps or actions to take when following a set of directions to the facility.',
    )


class FacilitiesFacilityCodedirectionsDirectionIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    from_: constr(min_length=1) = Field(
        ...,
        alias='from',
        description='The origin of the directions. It can either be cardinal direction (e.g., North, South) or city/state (e.g., Omaha, NE) with a geo location lookup.',
    )
    description: Optional[str] = Field(
        None, description='The title description of the set of directions.'
    )
    average_time: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='averageTime',
        description='The average time (in minutes) that it will take to arrive to the facility.',
    )
    directions: constr(min_length=1) = Field(
        ...,
        description='The details of the steps or actions to take when following a set of directions to the facility.',
    )


class FacilitiesFacilityCodeidentifiersPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description="The facility's identifier system type (e.g., DUNS, Facility Name, Ramp Name (Spell), RMIS, SPLC). Data Dictionary Term.",
    )
    value: constr(min_length=1) = Field(
        ..., description="The value for the corresponding facility's identifier system."
    )


class FacilitiesFacilityCodeidentifiersIdentifierIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description="The facility's identifier system type (e.g., DUNS, Facility Name, Ramp Name (Spell), RMIS, SPLC). Data Dictionary Term.",
    )
    value: constr(min_length=1) = Field(
        ..., description="The value for the corresponding facility's identifier system."
    )


class Hours14(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    start_offset_ms: confloat(le=8640000000000000.0) = Field(
        ...,
        alias='startOffsetMs',
        description='The start time of the facility of the day.',
    )
    end_offset_ms: confloat(le=8640000000000000.0) = Field(
        ..., alias='endOffsetMs', description='The end time of the facility of the day.'
    )


class Monday2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours14] = None


class Tuesday2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours14] = None


class Wednesday2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours14] = None


class Thursday2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours14] = None


class Friday2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours14] = None


class Saturday2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours14] = None


class Sunday2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours14] = None


class FacilitiesFacilityCodeschedulesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    appointment_type_term: AppointmentTypeTerm = Field(
        ...,
        alias='appointmentTypeTerm',
        description="The type of appointment that is required for the facility's schedule (e.g., Appt, Notice, Open).",
    )
    drop_type_term: DropTypeTerm = Field(
        ...,
        alias='dropTypeTerm',
        description='The drop type for how the facility would like loads being handled on their premises (e.g., Drop Avail, Live, Drop, Bobtail hook empty).',
    )
    mode_type_term: constr(min_length=1) = Field(
        ...,
        alias='modeTypeTerm',
        description='The type of transportation mode for the particular schedule (e.g., Truck, Rail, Air, Ocean). Data Dictionary Term.',
    )
    trailer_type_term: Optional[str] = Field(
        None,
        alias='trailerTypeTerm',
        description='The type of equipment being handled during a scheduled time at the facility (e.g., Reefer, Van, Flat Rack). Data Dictionary Term.',
    )
    services_type_term: Optional[str] = Field(
        None,
        alias='servicesTypeTerm',
        description="The services at the facility when the mode type is 'Rail' (e.g., Gate, Ramp Lift). It will only be applicable when the mode type is 'Rail'. Data Dictionary Term.",
    )
    schedule_type_term: ScheduleTypeTerm = Field(
        ...,
        alias='scheduleTypeTerm',
        description='The direction of the movement at the facility during the schedule (e.g., In, Out).',
    )
    work_type_term: WorkTypeTerm = Field(
        ...,
        alias='workTypeTerm',
        description='The type of work available for handling loads at the facility (e.g., Driver, Lumper, No Touch).',
    )
    size_type_term: Optional[str] = Field(
        None,
        alias='sizeTypeTerm',
        description='The size of load this facility schedule will handle (e.g., FTL, LTL, Partial). Data Dictionary Term.',
    )
    temperatures_type_term: Optional[List[str]] = Field(
        None,
        alias='temperaturesTypeTerm',
        description='The specific types of temperature (e.g., Ambient, Frozen, Refrigerated) of commodities the facility accommodates during the operating hours. Data Dictionary Term.',
    )
    monday: Optional[Monday2] = Field(
        None, description='The facility weekday of Monday.'
    )
    tuesday: Optional[Tuesday2] = Field(
        None, description='The facility weekday of Tuesday.'
    )
    wednesday: Optional[Wednesday2] = Field(
        None, description='The facility weekday of Wednesday.'
    )
    thursday: Optional[Thursday2] = Field(
        None, description='The facility weekday of Thursday.'
    )
    friday: Optional[Friday2] = Field(
        None, description='The facility weekday of Friday.'
    )
    saturday: Optional[Saturday2] = Field(
        None, description='The facility weekday of Saturday.'
    )
    sunday: Optional[Sunday2] = Field(
        None, description='The facility weekday of Sunday.'
    )


class Monday3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours14] = None


class Tuesday3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours14] = None


class Wednesday3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours14] = None


class Thursday3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours14] = None


class Friday3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours14] = None


class Saturday3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours14] = None


class Sunday3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_closed: bool = Field(
        ...,
        alias='isClosed',
        description='Indicates whether the facility is open on this day. If false, the hours are required.',
    )
    hours: Optional[Hours14] = None


class FacilitiesFacilityCodeschedulesScheduleIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    appointment_type_term: AppointmentTypeTerm = Field(
        ...,
        alias='appointmentTypeTerm',
        description="The type of appointment that is required for the facility's schedule (e.g., Appt, Notice, Open).",
    )
    drop_type_term: DropTypeTerm = Field(
        ...,
        alias='dropTypeTerm',
        description='The drop type for how the facility would like loads being handled on their premises (e.g., Drop Avail, Live, Drop, Bobtail hook empty).',
    )
    mode_type_term: constr(min_length=1) = Field(
        ...,
        alias='modeTypeTerm',
        description='The type of transportation mode for the particular schedule (e.g., Truck, Rail, Air, Ocean). Data Dictionary Term.',
    )
    trailer_type_term: Optional[str] = Field(
        None,
        alias='trailerTypeTerm',
        description='The type of equipment being handled during a scheduled time at the facility (e.g., Reefer, Van, Flat Rack). Data Dictionary Term.',
    )
    services_type_term: Optional[str] = Field(
        None,
        alias='servicesTypeTerm',
        description="The services at the facility when the mode type is 'Rail' (e.g., Gate, Ramp Lift). It will only be applicable when the mode type is 'Rail'. Data Dictionary Term.",
    )
    schedule_type_term: ScheduleTypeTerm = Field(
        ...,
        alias='scheduleTypeTerm',
        description='The direction of the movement at the facility during the schedule (e.g., In, Out).',
    )
    work_type_term: WorkTypeTerm = Field(
        ...,
        alias='workTypeTerm',
        description='The type of work available for handling loads at the facility (e.g., Driver, Lumper, No Touch).',
    )
    size_type_term: Optional[str] = Field(
        None,
        alias='sizeTypeTerm',
        description='The size of load this facility schedule will handle (e.g., FTL, LTL, Partial). Data Dictionary Term.',
    )
    temperatures_type_term: Optional[List[str]] = Field(
        None,
        alias='temperaturesTypeTerm',
        description='The specific types of temperature (e.g., Ambient, Frozen, Refrigerated) of commodities the facility accommodates during the operating hours. Data Dictionary Term.',
    )
    monday: Optional[Monday3] = Field(
        None, description='The facility weekday of Monday.'
    )
    tuesday: Optional[Tuesday3] = Field(
        None, description='The facility weekday of Tuesday.'
    )
    wednesday: Optional[Wednesday3] = Field(
        None, description='The facility weekday of Wednesday.'
    )
    thursday: Optional[Thursday3] = Field(
        None, description='The facility weekday of Thursday.'
    )
    friday: Optional[Friday3] = Field(
        None, description='The facility weekday of Friday.'
    )
    saturday: Optional[Saturday3] = Field(
        None, description='The facility weekday of Saturday.'
    )
    sunday: Optional[Sunday3] = Field(
        None, description='The facility weekday of Sunday.'
    )


class Facility22(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility23(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class Identifiers2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Union[Facility22, Facility23] = Field(
        ..., description='The facility record identifier.', title='FacilityIdentifier'
    )


class Settings(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_arrival_enabled: Optional[bool] = Field(
        None,
        alias='isArrivalEnabled',
        description='Indicates if arrival geofencing is enabled for the facility.',
    )
    is_departure_enabled: Optional[bool] = Field(
        None,
        alias='isDepartureEnabled',
        description='Indicates if departure geofencing is enabled for the facility.',
    )


class TypeTerm5(Enum):
    arrival = 'arrival'
    departure = 'departure'


class MethodTerm(Enum):
    circle = 'circle'
    polygon = 'polygon'


class Coordinates4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    latitude: confloat(ge=-90.0, le=90.0) = Field(
        ..., description='The latitude coordinate.'
    )
    longitude: confloat(ge=-180.0, le=180.0) = Field(
        ..., description='The longitude coordinate.'
    )


class Radius(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    coordinates: Optional[Coordinates4] = Field(
        None, description='The coordinates of the radius.'
    )
    value: Optional[float] = Field(None, description='The value of the radius.')
    unit_term: Optional[str] = Field(
        None,
        alias='unitTerm',
        description='The unit of the radius (e.g., Miles, Kilometers) Data Dictionary Term.',
    )


class Coordinate(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    latitude: confloat(ge=-90.0, le=90.0) = Field(
        ..., description='The latitude coordinate.'
    )
    longitude: confloat(ge=-180.0, le=180.0) = Field(
        ..., description='The longitude coordinate.'
    )


class Polygon(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    coordinates: Optional[List[Coordinate]] = Field(
        None, description='The coordinates of the polygon.'
    )


class Geofence(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: TypeTerm5 = Field(
        ...,
        alias='typeTerm',
        description='The type of geofence (e.g., arrival, departure).',
    )
    method_term: Optional[MethodTerm] = Field(
        None,
        alias='methodTerm',
        description='The method of the geofence (e.g., circle, polygon).',
    )
    radius: Optional[Radius] = Field(None, description='The geofence radius.')
    polygon: Optional[Polygon] = Field(None, description='The geofence polygon.')


class FacilityGeofencesPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    identifiers: Identifiers2 = Field(
        ...,
        description='The identifiers of the entity that the geofences are related to.',
        title='IdentifiersRecord',
    )
    settings: Optional[Settings] = Field(
        None, description='The settings of the geofences.'
    )
    geofences: Optional[List[Geofence]] = Field(
        None, description='The geofence of the facility.'
    )


class FacilityIdentifiers(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID for a facility record.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code for a facility record.'
    )


class Provided4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    latitude: confloat(ge=-90.0, le=90.0) = Field(
        ..., description='The latitude of the provided coordinates.'
    )
    longitude: confloat(ge=-180.0, le=180.0) = Field(
        ..., description='The longitude of the provided coordinates.'
    )


class Coordinates5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provided: Optional[Provided4] = Field(
        None, description='The provided coordinates of the the location.'
    )


class Location7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: constr(min_length=1) = Field(..., description='The name of the location.')
    description: constr(min_length=1) = Field(
        ..., description='The description of the location.'
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of the location (e.g., Building, Lot).',
    )
    locked_type_term: Optional[str] = Field(
        None,
        alias='lockedTypeTerm',
        description='The lock type of the location (e.g., Yes, No, NA).',
    )
    guarded_type_term: Optional[str] = Field(
        None,
        alias='guardedTypeTerm',
        description='The guard type of the location (e.g., Yes, No, NA).',
    )
    check_in_method: Optional[str] = Field(
        None, alias='checkInMethod', description='The check-in method of the location.'
    )
    coordinates: Optional[Coordinates5] = Field(
        None, description='The coordinates of the location.'
    )
    directions: Optional[str] = Field(
        None, description='The directions to the location.'
    )


class FacilityLocationsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility_identifiers: FacilityIdentifiers = Field(
        ...,
        alias='facilityIdentifiers',
        description='The facility record identifiers.',
        title='FacilityLocationCreatedIdentifiers',
    )
    locations: Optional[List[Location7]] = Field(
        None, description='The location of the facility.'
    )


class Coordinates6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provided: Optional[Provided4] = Field(
        None, description='The provided coordinates of the the location.'
    )


class Location8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined UUID referencing the location.'
    )
    name: Optional[str] = Field(None, description='The name of the location.')
    description: Optional[str] = Field(
        None, description='The description of the location.'
    )
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The type of the location (e.g., Building, Lot).',
    )
    locked_type_term: Optional[str] = Field(
        None,
        alias='lockedTypeTerm',
        description='The lock type of the location (e.g., Yes, No, NA).',
    )
    guarded_type_term: Optional[str] = Field(
        None,
        alias='guardedTypeTerm',
        description='The guard type of the location (e.g., Yes, No, NA).',
    )
    check_in_method: Optional[str] = Field(
        None, alias='checkInMethod', description='The check-in method of the location.'
    )
    coordinates: Optional[Coordinates6] = Field(
        None, description='The coordinates of the location.'
    )
    directions: Optional[str] = Field(
        None, description='The directions to the location.'
    )


class FacilityLocationsPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility_identifiers: FacilityIdentifiers = Field(
        ...,
        alias='facilityIdentifiers',
        description='The facility record identifiers.',
        title='FacilityLocationPatchedIdentifiers',
    )
    locations: Optional[List[Location8]] = Field(
        None, description='The location of the facility.'
    )


class LocationIdentifiers(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined UUID for a location record.'
    )


class Accommodation(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: constr(min_length=1) = Field(
        ..., description='The name of the accommodations record.'
    )
    rating_type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='ratingTypeTerm',
        description='The rating associated with the accommodations record (e.g., 1, 2,3). Data Dictionary Term.',
    )
    notes: Optional[str] = Field(
        None, description='The notes associated with the accommodations record.'
    )


class FacilityLocationsaccommodationsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    location_identifiers: LocationIdentifiers = Field(
        ...,
        alias='locationIdentifiers',
        description='The location record identifier.',
        title='FacilityLocationAccommodationCreatedIdentifiers',
    )
    accommodations: List[Accommodation] = Field(
        ..., description='The accommodations of the location record.'
    )


class Accommodation1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ...,
        description='The internally defined UUID referencing the accommodations record.',
    )
    name: Optional[str] = Field(
        None, description='The name of the accommodations record.'
    )
    rating_type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='ratingTypeTerm',
        description='The rating associated with the accommodations record (e.g., 1, 2,3). Data Dictionary Term.',
    )
    notes: Optional[str] = Field(
        None, description='The notes associated with the accommodations record.'
    )


class FacilityLocationsaccommodationsPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    location_identifiers: LocationIdentifiers = Field(
        ...,
        alias='locationIdentifiers',
        description='The location record identifier.',
        title='FacilityLocationAccommodationPatchedIdentifiers',
    )
    accommodations: List[Accommodation1] = Field(
        ..., description='The accommodations of the location record.'
    )


class LocationIdentifiers2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined UUID referencing the location record.'
    )


class Activity(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined UUID referencing the activity record.'
    )
    name: Optional[str] = Field(None, description='The name of the activities record.')
    average_time: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='averageTime',
        description='The average time of the activities record.',
    )
    variability_term: Optional[str] = Field(
        None,
        alias='variabilityTerm',
        description='The variability of the activities record (e.g., High, Medium, Low). Data Dictionary Term.',
    )
    notes: Optional[str] = Field(
        None, description='The notes associated with the activities record.'
    )


class FacilityLocationsactivitiesPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    location_identifiers: LocationIdentifiers2 = Field(
        ...,
        alias='locationIdentifiers',
        description='The location record identifier.',
        title='FacilityLocationActivityPatchedIdentifiers',
    )
    activities: List[Activity] = Field(
        ..., description='The activities of the location.'
    )


class Activity1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: constr(min_length=1) = Field(
        ..., description='The name of the activities record.'
    )
    average_time: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='averageTime',
        description='The average time of the activities record.',
    )
    variability_term: Optional[str] = Field(
        None,
        alias='variabilityTerm',
        description='The variability of the activities record (e.g., High, Medium, Low). Data Dictionary Term.',
    )
    notes: Optional[str] = Field(
        None, description='The notes associated with the activities record.'
    )


class FacilityLocationsactivitiesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    location_identifiers: LocationIdentifiers2 = Field(
        ...,
        alias='locationIdentifiers',
        description='The location record identifier.',
        title='FacilityLocationActivityCreatedIdentifiers',
    )
    activities: List[Activity1] = Field(
        ..., description='The activities of the location.'
    )


class LocationIdentifiers4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined UUID for a location record.'
    )


class Gate(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined UUID referencing the gate record.'
    )
    name: Optional[str] = Field(None, description='The name of the gate record.')
    guard_type_term: Optional[str] = Field(
        None,
        alias='guardTypeTerm',
        description='The guard type of the gate record (e.g, Employee, ThirdParty). Data Dictionary Term.',
    )
    documentation_needed_type_terms: Optional[List[str]] = Field(
        None,
        alias='documentationNeededTypeTerms',
        description='The documents types needed for the gate record (e.g., BillofLading, NotRequired, PO). Data Dictionary Term.',
    )
    id_checked_type_terms: Optional[List[str]] = Field(
        None,
        alias='idCheckedTypeTerms',
        description='The ID types needed for the gate record (e.g., CompanyID, DriverLicense, NotRequired). Data Dictionary Term.',
    )
    guard_contact_info: Optional[str] = Field(
        None,
        alias='guardContactInfo',
        description='The guard contact info for the gate record.',
    )
    notes: Optional[str] = Field(
        None, description='The notes associated with the gate record.'
    )


class FacilityLocationsgatesPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    location_identifiers: LocationIdentifiers4 = Field(
        ...,
        alias='locationIdentifiers',
        description='The location record identifier.',
        title='FacilityLocationGatePatchedIdentifier',
    )
    gates: List[Gate] = Field(..., description='The gates of the location record.')


class Gate1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: constr(min_length=1) = Field(..., description='The name of the gate record.')
    guard_type_term: Optional[str] = Field(
        None,
        alias='guardTypeTerm',
        description='The guard type of the gate record (e.g, Employee, ThirdParty). Data Dictionary Term.',
    )
    documentation_needed_type_terms: Optional[List[str]] = Field(
        None,
        alias='documentationNeededTypeTerms',
        description='The documents types needed for the gate record (e.g., BillofLading, NotRequired, PO). Data Dictionary Term.',
    )
    id_checked_type_terms: Optional[List[str]] = Field(
        None,
        alias='idCheckedTypeTerms',
        description='The ID types needed for the gate record (e.g., CompanyID, DriverLicense, NotRequired). Data Dictionary Term.',
    )
    guard_contact_info: Optional[str] = Field(
        None,
        alias='guardContactInfo',
        description='The guard contact info for the gate record.',
    )
    notes: Optional[str] = Field(
        None, description='The notes associated with the gate record.'
    )


class FacilityLocationsgatesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    location_identifiers: LocationIdentifiers4 = Field(
        ...,
        alias='locationIdentifiers',
        description='The location record identifier.',
        title='FacilityLocationGateCreatedIdentifier',
    )
    gates: List[Gate1] = Field(..., description='The gates of the location record.')


class Owner2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ...,
        description='The internally defined UUID referencing the employee who owns the group.',
    )
    code: Optional[constr(min_length=1)] = Field(
        None,
        description='The externally defined code referencing the employee who owns the group.',
    )


class Owner3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None,
        description='The internally defined UUID referencing the employee who owns the group.',
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The externally defined code referencing the employee who owns the group.',
    )


class Employees(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined UUID referencing the employee.'
    )
    code: Optional[constr(min_length=1)] = Field(
        None, description='The externally defined code referencing the employee.'
    )


class Employees1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined UUID referencing the employee.'
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally defined code referencing the employee.'
    )


class Members(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    employees: Optional[List[Union[Employees, Employees1]]] = Field(
        ..., description='The employees in the group.'
    )


class GroupsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally defined code referencing the group.'
    )
    name: constr(min_length=1) = Field(..., description='The name of the group.')
    description: Optional[str] = Field(
        None, description='The description of the group.'
    )
    status_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='statusTerm',
        description='The status of the group (e.g., Active, Inactive). Data Dictionary Term.',
    )
    owner: Optional[Union[Owner2, Owner3]] = Field(
        None, description='The owner of the group.'
    )
    distribution_list_email: Optional[str] = Field(
        None,
        alias='distributionListEmail',
        description='The point of contact email for the group.',
    )
    purpose_term: str = Field(
        ...,
        alias='purposeTerm',
        description='The purpose of the group. Data Dictionary Term.',
    )
    type_term: str = Field(
        ..., alias='typeTerm', description='The type of group. Data Dictionary Term.'
    )
    direction_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='directionTerm',
        description='The direction of the driver coming back to the terminal or leaving the terminal (e.g., Inbound, Outbound). Data Dictionary Term.',
    )
    members: Optional[Members] = Field(None, description='The members of the group.')


class Owner4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ...,
        description='The internally defined UUID referencing the employee who owns the group.',
    )
    code: Optional[constr(min_length=1)] = Field(
        None,
        description='The externally defined code referencing the employee who owns the group.',
    )


class Owner5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None,
        description='The internally defined UUID referencing the employee who owns the group.',
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The externally defined code referencing the employee who owns the group.',
    )


class Employees2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined UUID referencing the employee.'
    )
    code: Optional[constr(min_length=1)] = Field(
        None, description='The externally defined code referencing the employee.'
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this employee should be removed from the group.',
    )


class Employees3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined UUID referencing the employee.'
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally defined code referencing the employee.'
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this employee should be removed from the group.',
    )


class Members1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    employees: Optional[List[Union[Employees2, Employees3]]] = Field(
        ..., description='The employees in the group.'
    )


class GroupsIdentifierValuePATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: Optional[str] = Field(None, description='The name of the group.')
    description: Optional[str] = Field(
        None, description='The description of the group.'
    )
    status_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='statusTerm',
        description='The status of the group (e.g., Active, Inactive). Data Dictionary Term.',
    )
    owner: Optional[Union[Owner4, Owner5]] = Field(
        None, description='The owner of the group.'
    )
    distribution_list_email: Optional[str] = Field(
        None,
        alias='distributionListEmail',
        description='The point of contact email for the group.',
    )
    direction_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='directionTerm',
        description='The direction of the driver coming back to the terminal or leaving the terminal (e.g., Inbound, Outbound). Data Dictionary Term.',
    )
    members: Optional[Members1] = Field(None, description='The members of the group.')


class Order3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the order.'
    )
    number: Optional[str] = Field(
        None, description='The internally defined number referencing the order.'
    )
    code: Optional[str] = Field(
        None,
        description='The externally defined unique identifier referencing the order.',
    )


class Route8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the route.'
    )
    number: Optional[str] = Field(
        None, description='The internally defined number referencing the route.'
    )


class Customer8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined UUID for the customer on the incident record.',
    )
    code: Optional[str] = Field(
        None,
        description='The externally defined unique customer identifier on the incident record.',
    )


class Vendor(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined UUID for the vendor associated on the route.',
    )
    code: Optional[str] = Field(
        None,
        description='The externally defined unique identifier for the vendor associated on the route.',
    )


class Facility24(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined identifier for the facility record.'
    )


class Address8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city: str = Field(..., description='The city of the address.')
    state: str = Field(..., description='The state of the address.')
    postal_code: Optional[str] = Field(
        None, alias='postalCode', description='The postal code of the address.'
    )
    country: str = Field(..., description='The country of the address.')


class Coordinates7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    latitude: float = Field(..., description='The latitude coordinate.')
    longitude: float = Field(..., description='The longitude coordinate.')


class Location9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    address: Optional[Address8] = Field(
        None, description='The address of the location.'
    )
    coordinates: Optional[Coordinates7] = Field(
        None,
        description='The coordinates of the location (overrides location address, if both are sent).',
    )


class CreatedByEmployee(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined UUID of the employee that created the incident.',
    )
    code: Optional[str] = Field(
        None,
        description='The externally defined unique identifier of the employee that created the incident record.',
    )


class NotifyEmployee(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined UUID of the employee to be notified of the incident.',
    )
    code: Optional[str] = Field(
        None,
        description='The externally defined unique identifier of the employee to be notified of the incident.',
    )


class LoadsLoadIdentifierValueincidentsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    orders: Optional[List[Order3]] = Field(
        None, description='The collection of orders.'
    )
    routes: Optional[List[Route8]] = Field(
        None, description='The collection of routes.'
    )
    customer: Optional[Customer8] = Field(None, description='The customer object.')
    vendor: Optional[Vendor] = Field(None, description='The vendor object.')
    facility: Optional[Facility24] = Field(None, description='The facility object.')
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The incident type (e.g., Accident, Late Arrival, Carrier Related). Data Dictionary Term.',
    )
    gravity_term: Optional[str] = Field(
        None,
        alias='gravityTerm',
        description='The gravity level (e.g., 1, 2, 3). Data Dictionary term.',
    )
    fault_party_term: Optional[str] = Field(
        None,
        alias='faultPartyTerm',
        description='The party at fault for the incident (e.g., Broker, Carrier, Consignee). Data Dictionary term.',
    )
    location: Optional[Location9] = Field(None, description='The location object.')
    follow_up_date_time: Optional[float] = Field(
        None,
        alias='followUpDateTime',
        description='The follow up date and time. Unix Timestamp (in milliseconds).',
    )
    is_shutdown: bool = Field(
        ...,
        alias='isShutdown',
        description='Indicates if incident caused customer shutdown.',
    )
    is_claims: bool = Field(
        ..., alias='isClaims', description='Indicates if incident results in a claim.'
    )
    is_closed: bool = Field(
        ..., alias='isClosed', description='Indicates if incident is closed.'
    )
    is_accounting: bool = Field(
        ...,
        alias='isAccounting',
        description='Indicates if it is an accounting incident. This will also cause an accounting exception to be triggered.',
    )
    created_by_employee: Optional[CreatedByEmployee] = Field(
        None,
        alias='createdByEmployee',
        description='The created by employee object for the incident.',
    )
    summary: constr(min_length=1) = Field(
        ..., description='The summary of the incident.'
    )
    description: Optional[str] = Field(
        None, description='The detailed description of the incident.'
    )
    notify_employees: Optional[List[NotifyEmployee]] = Field(
        None, alias='notifyEmployees', description='The collection of employees.'
    )


class NotifyEmployee1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined UUID of the employee that created the incident.',
    )
    code: Optional[str] = Field(
        None,
        description='The externally defined unique identifier of the employee that created the incident.',
    )


class LoadsincidentsIncidentIdPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    follow_up_date_time: Optional[float] = Field(
        None,
        alias='followUpDateTime',
        description='The follow up date and time. Unix Timestamp (in milliseconds).',
    )
    is_claims: Optional[bool] = Field(
        None, alias='isClaims', description='Indicates if incident results in a claim.'
    )
    is_shutdown: Optional[bool] = Field(
        None,
        alias='isShutdown',
        description='Indicates if incident caused customer shutdown.',
    )
    is_closed: Optional[bool] = Field(
        None, alias='isClosed', description='Indicates if incident is closed.'
    )
    is_accounting: Optional[bool] = Field(
        None,
        alias='isAccounting',
        description='Indicates if it is an accounting incident. This will also cause an accounting exception to be triggered.',
    )
    notify_employees: Optional[List[NotifyEmployee1]] = Field(
        None, alias='notifyEmployees', description='The collection of employees.'
    )
    update_description: str = Field(
        ...,
        alias='updateDescription',
        description='The updated description of an incident that can be sent for an existing incident record.',
    )


class UnitTerm10(Enum):
    mph = 'mph'
    kph = 'kph'


class Speed(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the speed of the asset.'
    )
    unit_term: UnitTerm10 = Field(
        ..., alias='unitTerm', description='The unit of measure.'
    )


class UnitTerm11(Enum):
    mi = 'mi'
    km = 'km'


class Odometer(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the odometer of the asset.'
    )
    unit_term: UnitTerm11 = Field(
        ..., alias='unitTerm', description='The unit of measure.'
    )
    odometer_jump: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='odometerJump',
        description='Amount the odometer jumped if it breached the engine data odometer jump threshold in the CVD configuration.',
    )


class DistanceDiff(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value of the distance'
    )
    unit_term: UnitTerm11 = Field(
        ..., alias='unitTerm', description='The unit of measure.'
    )


class TotalDistance(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value of the distance'
    )
    unit_term: UnitTerm11 = Field(
        ..., alias='unitTerm', description='The unit of measure.'
    )


class Gps(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    accuracy: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        description='Horizontal position accuracy estimation. Lower integer values indicate higher confidence of GPS accuracy.',
    )
    number_satellites: Optional[confloat(ge=0.0)] = Field(
        None,
        alias='numberSatellites',
        description='Total number of satellites that the GPS receiver utilized to record location data.',
    )
    is_valid: Optional[bool] = Field(
        None,
        alias='isValid',
        description='Indicates a valid GPS readings from the CVD (true = valid, GPS readings were received, false = invalid or did not receive valid GPS readings).',
    )
    distance_diff: Optional[DistanceDiff] = Field(None, alias='distanceDiff')
    total_distance: Optional[TotalDistance] = Field(None, alias='totalDistance')
    horizontal_dilution_of_precision: Optional[
        confloat(ge=0.0, le=8640000000000000.0)
    ] = Field(
        None,
        alias='horizontalDilutionOfPrecision',
        description='A measure of the geometric quality of a GPS satellite configuration in the sky. HDOP is a factor in determining the relative accuracy of a horizontal position.',
    )


class UnitTerm14(Enum):
    gal = 'gal'
    l = 'l'


class TotalUsed(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the fuel used by the asset.'
    )
    unit_term: UnitTerm14 = Field(
        ..., alias='unitTerm', description='The unit of measure.'
    )


class Fuel(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    level_percent: Optional[confloat(ge=0.0, le=100.0)] = Field(
        None,
        alias='levelPercent',
        description='Latest fuel tank reading measured in percentage (0-100).',
    )
    total_used: Optional[TotalUsed] = Field(None, alias='totalUsed')


class UnitTerm15(Enum):
    f = 'f'
    c = 'c'


class AmbientTemperature(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=-8640000000000000.0, le=8640000000000000.0) = Field(
        ..., description='The value for the temperature.'
    )
    unit_term: UnitTerm15 = Field(
        ..., alias='unitTerm', description='The unit of measure.'
    )


class IdlePeriod(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    start_date_time: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        alias='startDateTime',
        description='The start date and time of the idle. Unix timestamp (in milliseconds).',
    )
    duration: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        description='The duration of the idle period in seconds with up to two decimals.',
    )
    latitude: Optional[confloat(ge=-90.0, le=90.0)] = Field(
        None, description='The latitude of the idle period.'
    )
    longitude: Optional[confloat(ge=-180.0, le=180.0)] = Field(
        None, description='The longitude of the idle period.'
    )


class UnitTerm16(Enum):
    mi = 'mi'
    km = 'km'


class Distance(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value of the distance'
    )
    unit_term: UnitTerm16 = Field(
        ..., alias='unitTerm', description='The unit of measure.'
    )


class RelativePosition(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city: Optional[str] = Field(
        None,
        description='TThe closest city/town with a population of 5000 people or more at the time of record.',
    )
    state: Optional[constr(min_length=2, max_length=2)] = Field(
        None, description='2-character state code or province of the asset location.'
    )
    country: Optional[constr(min_length=3, max_length=3)] = Field(
        None,
        description='3-Character Country code - ISO 3166-1 alpha-3 of the asset location.',
    )
    direction: Optional[str] = Field(
        None,
        description='Ordinal, cardinal, and secondary intercardinal directions of a Compass Rose (e.x N, NNE, NE, ENE).',
    )
    distance: Optional[Distance] = None


class Location10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    latitude: confloat(ge=-90.0, le=90.0) = Field(
        ...,
        description='Latest latitude reading from the connected vehicle device (CVD) at time of record.',
    )
    longitude: confloat(ge=-180.0, le=180.0) = Field(
        ...,
        description='Latest longitude reading from the connected vehicle device (CVD) at time of record.',
    )
    description: Optional[str] = Field(
        None,
        description='Short description of the relative location of the asset at time of record.',
    )
    state: Optional[constr(min_length=2, max_length=2)] = Field(
        None,
        description='2-character state code or province of the asset location using ISO 3166:2 standards.',
    )
    country: Optional[constr(min_length=3, max_length=3)] = Field(
        None,
        description='3-Character Country code of the asset location using\xa0 ISO 3166-1 alpha-3 standards.',
    )
    relative_position: Optional[RelativePosition] = Field(
        None, alias='relativePosition'
    )


class PowerUnit(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    vehicle_identification_number: Optional[str] = Field(
        None,
        alias='vehicleIdentificationNumber',
        description='The VIN number for the asset.',
    )
    code: constr(min_length=1) = Field(
        ..., description='The external ID assigned to the asset.'
    )
    source_vehicle_code: Optional[str] = Field(
        None, alias='sourceVehicleCode', description='The unique id assigned by source.'
    )


class Identifiers3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    number: Optional[str] = Field(None, description='The trailer number.')
    prefix: Optional[constr(min_length=3, max_length=4)] = Field(
        None, description='A 3-4 letter code which comes before the trailer number.'
    )
    serial_number: Optional[str] = Field(
        None, alias='serialNumber', description='The serial number of the trailer.'
    )


class Trailer2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The externally defined trailer code assigned by the client to the trailer resource within MasterMind.',
    )
    source_trailer_code: Optional[str] = Field(
        None, alias='sourceTrailerCode', description='The unique id assigned by source.'
    )
    identifiers: Optional[Identifiers3] = Field(
        None, description='', title='Identifiers'
    )


class PingSource(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally defined unique identifier for source.'
    )
    power_unit: Optional[PowerUnit] = Field(None, alias='powerUnit')
    trailer: Optional[Trailer2] = None


class Device(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    serial: Optional[str] = Field(None, description='The device serial ID.')
    source_code: constr(min_length=1) = Field(
        ...,
        alias='sourceCode',
        description='The externally defined unique ID for the device.',
    )
    type: Optional[str] = Field(
        None, description='The type of device that submitted the location ping.'
    )
    health: Optional[str] = Field(None, description='The health status of the device.')


class Driver4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    source_code: Optional[str] = Field(
        None,
        alias='sourceCode',
        description='The code used by the source system to uniquely identify the driver.',
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally defined unique ID for the driver.'
    )


class CargoStateTerm(Enum):
    loaded = 'loaded'
    unloaded = 'unloaded'


class UnitTerm17(Enum):
    f = 'f'
    c = 'c'


class ActualTemp(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=-8640000000000000.0, le=8640000000000000.0) = Field(
        ..., description='The value for the temperature.'
    )
    unit_term: UnitTerm17 = Field(
        ..., alias='unitTerm', description='The unit of measure.'
    )


class SetTemp(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=-8640000000000000.0, le=8640000000000000.0) = Field(
        ..., description='The value for the temperature.'
    )
    unit_term: UnitTerm17 = Field(
        ..., alias='unitTerm', description='The unit of measure.'
    )


class ReturnTemp(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=-8640000000000000.0, le=8640000000000000.0) = Field(
        ..., description='The value for the temperature.'
    )
    unit_term: UnitTerm17 = Field(
        ..., alias='unitTerm', description='The unit of measure.'
    )


class DischargeTemp(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=-8640000000000000.0, le=8640000000000000.0) = Field(
        ..., description='The value for the temperature.'
    )
    unit_term: UnitTerm17 = Field(
        ..., alias='unitTerm', description='The unit of measure.'
    )


class Temperature(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    zone: Optional[str] = Field(
        None,
        description='The number of the zone which the temperature is being recorded.',
    )
    configuration: Optional[str] = Field(
        None, description='The configuration of the reefer set for the current route.'
    )
    monitoring_code: Optional[str] = Field(
        None,
        alias='monitoringCode',
        description='The monitoring code to reference for the reefer trailer to ensure the right temps are happening.',
    )
    device_source_code: Optional[str] = Field(
        None,
        alias='deviceSourceCode',
        description='Refers back to the device being used to gague the temperature.',
    )
    actual_temp: Optional[ActualTemp] = Field(None, alias='actualTemp')
    set_temp: Optional[SetTemp] = Field(None, alias='setTemp')
    return_temp: Optional[ReturnTemp] = Field(None, alias='returnTemp')
    discharge_temp: Optional[DischargeTemp] = Field(None, alias='dischargeTemp')


class Trailer3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_hooked: Optional[bool] = Field(
        None,
        alias='isHooked',
        description='Indicates whether the trailer is hooked to a power unit.',
    )
    cargo_state_term: Optional[CargoStateTerm] = Field(
        None,
        alias='cargoStateTerm',
        description='Indicates whether the trailer has been loaded/unloaded.',
    )
    humidity: Optional[confloat(ge=0.0, le=100.0)] = Field(
        None,
        description='Indicates the humidty of the trailer as a percentage. Limited to a value of 0-100',
    )
    temperatures: Optional[List[Temperature]] = None


class Ping(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=2) = Field(
        ...,
        description='The externally defined unique identifier for the event record.',
    )
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The type of heartbeat event (e.x. Periodic Update, Startup, etc).',
    )
    create_date_time: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        alias='createDateTime',
        description='The date and time when the heartbeat was recorded. Unix timestamp (in milliseconds).',
    )
    message_received_date_time: Optional[confloat(ge=0.0, le=8640000000000000.0)] = (
        Field(
            None,
            alias='messageReceivedDateTime',
            description='When data was available from source. Unix timestamp (in milliseconds).',
        )
    )
    heading: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        description='Latest direction (in degrees) the asset was heading, as defined as the compass direction in which the longitudinal axis of the power or trailer unit points.',
    )
    is_ignition: Optional[bool] = Field(
        None,
        alias='isIgnition',
        description='Indicates the ignition status (true = ignition on, false = ignition off).',
    )
    rpm: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None, description='Latest RPM reading from the asset.'
    )
    engine_hours: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='engineHours',
        description='Latest reading of total lifetime engine hours from the asset.',
    )
    engine_hours_jump: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='engineHoursJump',
        description='The difference in engine hours from the last reading. Helps to identify tampering and exceptions related to total engine hours.',
    )
    is_wheels_in_motion: Optional[bool] = Field(
        None,
        alias='isWheelsInMotion',
        description='Indicates if the wheels were in motion (true = wheels were in motion, false = wheels were not in motion).',
    )
    switched_battery_voltage: Optional[str] = Field(
        None,
        alias='switchedBatteryVoltage',
        description='Battery potential measured at the input of the electronic control unit supplied through a keyswitch or similar switching device. Also known as Keyswitch Battery Potential.',
    )
    speed: Optional[Speed] = None
    odometer: Optional[Odometer] = None
    gps: Optional[Gps] = None
    fuel: Optional[Fuel] = None
    ambient_temperature: Optional[AmbientTemperature] = Field(
        None, alias='ambientTemperature'
    )
    idle_periods: Optional[List[IdlePeriod]] = Field(
        None,
        alias='idlePeriods',
        description='This field describes location and duration around when a driver was idle.',
    )
    location: Location10 = Field(
        ...,
        description='Object of asset location at time of heartbeat.',
        title='Location',
    )
    ping_source: PingSource = Field(
        ...,
        alias='pingSource',
        description='The client resource used as the source of the GPS Location Ping data such as Power Unit, Trailer or Cell Phone.',
        title='PingSource',
    )
    devices: Optional[List[Device]] = Field(
        None, description='Data about the devices installed on the asset.'
    )
    drivers: Optional[List[Driver4]] = Field(None, description='Data about the driver.')
    trailer: Optional[Trailer3] = Field(
        None,
        description='Object containing various temperatures of the trailer.',
        title='TrailerRecord',
    )


class LocationPingsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    pings: List[Ping] = Field(..., description='The pings object to support bulk post.')


class OrderCreditStatus(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_order_credit_bypass: bool = Field(
        ...,
        alias='isOrderCreditBypass',
        description="Indicates if the Order should bypass the customer's credit status regardless if it is in an approved, hold, or denied status.",
    )


class UnitTerm21(Enum):
    ft = 'ft'
    in_ = 'in'
    m = 'm'
    km = 'km'
    mi = 'mi'


class ExternalOrderDistance(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    unit_term: UnitTerm21 = Field(
        ...,
        alias='unitTerm',
        description='The distance term used to measure the distance (e.g., miles, kilometers).',
        title='ExternalOrderDistanceUnitTerm',
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value of the distance.'
    )


class TrailerTypeTerm(RootModel[constr(min_length=1)]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: constr(min_length=1) = Field(
        ..., description='The types of trailers required (e.g., van, reefer, flatbed).'
    )


class MinimumLength1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the minimum required length of equipment.'
    )
    unit_term: UnitTerm21 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the minimum required length of equipment.',
        title='MinLengthUnitTerm',
    )


class Width1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The minimum required width of equipment.'
    )
    unit_term: UnitTerm21 = Field(
        ...,
        alias='unitTerm',
        description='The value for the required width of equipment.',
        title='WidthUnitTerm',
    )


class Height1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the required height of equipment.'
    )
    unit_term: UnitTerm21 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the required height of equipment.',
        title='HeightUnitTerm',
    )


class Dimensions1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    minimum_length: Optional[MinimumLength1] = Field(
        None,
        alias='minimumLength',
        description='The minimum required length of equipment.',
        title='MinimumLengthRecord',
    )
    width: Optional[Width1] = Field(
        None,
        description='This is the width and unit values for the trailer.',
        title='WidthRecord',
    )
    height: Optional[Height1] = Field(
        None,
        description='The minimum required height of equipment.',
        title='HeightRecord',
    )


class Equipment1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    trailer_type_terms: List[TrailerTypeTerm] = Field(
        ..., alias='trailerTypeTerms', min_length=1
    )
    dimensions: Optional[Dimensions1] = Field(
        None,
        description='The dimensional requirements for equipment.',
        title='DimensionsRecord',
    )


class ReasonCode(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The reason the order was put on hold or cancelled.',
    )
    term_value: Optional[constr(min_length=1)] = Field(
        None,
        alias='termValue',
        description='The value for the reason the order was put on hold or cancelled.',
    )


class UnitTerm25(Enum):
    g = 'g'
    kg = 'kg'
    lbs = 'lbs'
    st = 'st'
    tons = 'tons'
    tonnes = 'tonnes'


class ExpectedWeight(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value amount for the expected weight of a commodity.'
    )
    unit_term: UnitTerm25 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected weight of a commodity.',
        title='ExpectedWeightUnitTerm',
    )


class UnitTerm26(Enum):
    usd = 'USD'
    cad = 'CAD'
    mxn = 'MXN'


class CommodityValue(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value amount for the commodity value.'
    )
    unit_term: UnitTerm26 = Field(
        ..., alias='unitTerm', description='The currency code for the commodity value.'
    )


class AssociatedStop(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined unique identifier for a stop record that associates to a commodity.',
    )
    code: Optional[str] = Field(
        None,
        description='The externally defined unique identifier for a stop record that associates to a commodity.',
    )
    assigned_expected_weight: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='assignedExpectedWeight',
        description='The portion of Weight of the commodity planned for that stop. The unit term is derived from the order level.',
    )
    assigned_expected_pieces: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='assignedExpectedPieces',
        description='The portion of Pieces of the commodity planned for that stop. The unit term is derived from the order level.',
    )
    assigned_handling_count: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='assignedHandlingCount',
        description='The portion of Handling Units of the commodity planned for that stop. The unit term is derived from the order level.',
    )
    actual_weight: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='actualWeight',
        description='The weight of that commodity actually reported at that stop. The unit term is derived from the order level.',
    )
    actual_pieces: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='actualPieces',
        description='The number of pieces of the commodity actually reported at that stop. The unit term is derived from the order level.',
    )


class UnitTerm27(Enum):
    f = 'f'
    c = 'c'


class PreCoolTo(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The value amount for a specific temperature to set the refridgerated trailer to before arriving at the shipper.',
    )
    unit_term: UnitTerm27 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for a specific temperature to set the refridgerated trailer to before arriving at the shipper.',
        title='PreCoolToUnit',
    )


class MinimumTemperature(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The value amount for the minimum temperature the commodity must be kept at.',
    )
    unit_term: UnitTerm27 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the minimum temperature the commodity must be kept at.',
        title='MinimumTemperatureUnit',
    )


class MaximumTemperature(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The value amount for the maximum temperature a commodity can reach.',
    )
    unit_term: UnitTerm27 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the maximum temperature a commodity can reach.',
        title='MaximumTemperatureUnit',
    )


class TemperatureSettingTermEnum(Enum):
    continuous = 'continuous'
    cycle = 'cycle'


class TemperatureSettingTerm(RootModel[Optional[TemperatureSettingTermEnum]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Optional[TemperatureSettingTermEnum] = Field(
        None,
        description='Indicates if the refrigerated trailer temperature control must run continuous or if it can cycle on and off.',
    )


class HazmatPackagingGroupTermEnum(Enum):
    i = 'I'
    ii = 'II'
    iii = 'III'


class HazmatPackagingGroupTerm(RootModel[Optional[HazmatPackagingGroupTermEnum]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Optional[HazmatPackagingGroupTermEnum] = Field(
        None,
        description='Identifies a grouping of substance and the degree of danger they present.',
    )


class UnitTerm30(Enum):
    ft = 'ft'
    in_ = 'in'
    cm = 'cm'
    m = 'm'


class Length2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected length of a commodity.'
    )
    unit_term: UnitTerm30 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected length of a commodity.',
        title='ExpectedLengthUnitTerm',
    )


class Width2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected width of a commodity.'
    )
    unit_term: UnitTerm30 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected width of a commodity.',
        title='ExpectedWidthUnitTerm',
    )


class Height2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected height of a commodity.'
    )
    unit_term: UnitTerm30 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected height of a commodity.',
        title='ExpectedHeightUnitTerm',
    )


class ExpectedDimensions(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    length: Optional[Length2] = Field(
        None,
        description='The expected length of a commodity.',
        title='ExpectedLengthRecord',
    )
    width: Optional[Width2] = Field(
        None,
        description='The expected width of a commodity.',
        title='ExpectedWidthRecord',
    )
    height: Optional[Height2] = Field(
        None,
        description='The expected height of a commodity.',
        title='ExpectedHeightRecord',
    )


class ExpectedLinear(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected linear dimensions of a commodity.'
    )
    unit_term: UnitTerm30 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected linear dimensions of a commodity, (e.g., feet, inches).',
        title='ExpectedLinearUnitTerm',
    )


class UnitTerm34(Enum):
    in3 = 'in3'
    ft3 = 'ft3'
    cm3 = 'cm3'
    m3 = 'm3'


class ExpectedCube(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        description='The value for the expected the cubic dimensions of a commodity.',
    )
    unit_term: UnitTerm34 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected cubic dimensions of a commodity.',
        title='ExpectedCubeUnitTerm',
    )


class UnitTerm35(Enum):
    lb_in3 = 'lb/in3'
    lb_ft3 = 'lb/ft3'
    cwt_ft3 = 'cwt/ft3'
    kg_cm3 = 'kg/cm3'
    kg_m3 = 'kg/m3'


class ExpectedDensity(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected density of a commodity.'
    )
    unit_term: UnitTerm35 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected density of a commodity.',
        title='ExpectedDensityUnitTerm',
    )


class UnitTerm36(Enum):
    f = 'f'
    c = 'c'


class HazmatFlashpointTemp(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The value of the temperature the hazardous material will catch fire.',
    )
    unit_term: UnitTerm36 = Field(
        ..., alias='unitTerm', description='The unit of measurement of the temperature.'
    )


class Commodity(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The internally defined unique identifier of commodities to be shipped for an order.',
    )
    description: constr(min_length=1) = Field(
        ..., description='The description of commodities to be shipped for an order.'
    )
    expected_weight: ExpectedWeight = Field(
        ...,
        alias='expectedWeight',
        description='The expected weight for a commodity.',
        title='ExpectedWeightRecord',
    )
    expected_pieces: Optional[int] = Field(
        None,
        alias='expectedPieces',
        description='The expected number of pieces for a commodity.',
    )
    number: Optional[int] = Field(
        None, description='The number of pieces of a commodity.'
    )
    packaging_unit: Optional[str] = Field(
        None,
        alias='packagingUnit',
        description='The unit of measurement for the number of pieces of a commodity (e.g., pallet, drum, crate).',
    )
    load_on_term: Optional[str] = Field(
        None,
        alias='loadOnTerm',
        description='Identifies how the freight should be loaded on the trailer.',
    )
    is_hazmat: Optional[bool] = Field(
        None,
        alias='isHazmat',
        description='Identifies if there are hazardous materials for a commodity.',
    )
    is_temp_controlled: Optional[bool] = Field(
        None,
        alias='isTempControlled',
        description='Identifies if a commodity requires its temperature to be controlled.',
    )
    stcc_code: Optional[constr(min_length=1)] = Field(
        None,
        alias='stccCode',
        description='The Standard Transportation Commodity Code is a publication containing specific product information used on shipping documents.',
    )
    stop_codes: Optional[List[str]] = Field(None, alias='stopCodes')
    commodity_value: Optional[CommodityValue] = Field(
        None,
        alias='commodityValue',
        description='Identifies the total value of an individual commodity in case a claim needs to be filed for it.',
    )
    associated_stops: Optional[List[AssociatedStop]] = Field(
        None,
        alias='associatedStops',
        description='Identifies if a commodity is associated with a particular stop.',
    )
    is_top_loadable: Optional[bool] = Field(
        None,
        alias='isTopLoadable',
        description='Identifies if a commodity can be loaded on top of other commodities.',
    )
    is_bottom_loadable: Optional[bool] = Field(
        None,
        alias='isBottomLoadable',
        description='Identifies if a commodity can be loaded on the bottom of other commodities.',
    )
    pre_cool_to: Optional[PreCoolTo] = Field(
        None,
        alias='preCoolTo',
        description='Identifies a specific temperature to set the refridgerated trailer to before arriving at the shipper.',
    )
    minimum_temperature: Optional[MinimumTemperature] = Field(
        None,
        alias='minimumTemperature',
        description='Identifies the minimum temperature the commodity must be kept at.',
    )
    maximum_temperature: Optional[MaximumTemperature] = Field(
        None,
        alias='maximumTemperature',
        description='Identifies the maximum temperature a commodity can reach.',
    )
    temperature_setting_term: Optional[TemperatureSettingTerm] = Field(
        None,
        alias='temperatureSettingTerm',
        description='Indicates if the refrigerated trailer temperature control must run continuous or if it can cycle on and off.',
    )
    hazmat_class_term: Optional[str] = Field(
        None,
        alias='hazmatClassTerm',
        description='Identifies which hazardous materials class a commodity belongs to.',
    )
    hazmat_packaging_group_term: Optional[HazmatPackagingGroupTerm] = Field(
        None,
        alias='hazmatPackagingGroupTerm',
        description='Identifies a grouping of substance and the degree of danger they present.',
    )
    hazmat_united_nations_number: Optional[constr(min_length=1)] = Field(
        None,
        alias='hazmatUnitedNationsNumber',
        description='A four digit number that identify dangerous goods or hazardous substances.',
    )
    hazmat_phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='hazmatPhoneNumber',
        description='The emergency response telephone number for hazardous materials.',
    )
    expected_dimensions: Optional[ExpectedDimensions] = Field(
        None,
        alias='expectedDimensions',
        description='The expected dimensions of a commodity.',
    )
    expected_linear: Optional[ExpectedLinear] = Field(
        None,
        alias='expectedLinear',
        description='The expected linear dimensions of a commodity.',
    )
    expected_cube: Optional[ExpectedCube] = Field(
        None,
        alias='expectedCube',
        description='The expected cubic dimensions of a commodity.',
    )
    expected_density: Optional[ExpectedDensity] = Field(
        None,
        alias='expectedDensity',
        description='The expected density of a commodity.',
    )
    expected_class_term: Optional[str] = Field(
        None,
        alias='expectedClassTerm',
        description='Identifies the expected freight class code that uses a classification system for commodities transported via LTL freight shipping; the lower the freight class, the lower the shipping price.',
    )
    expected_nmfc: Optional[constr(min_length=1)] = Field(
        None,
        alias='expectedNMFC',
        description='Identifies the expected National Motor Freight Classification code which is a designation used to group commodities.',
    )
    make: Optional[constr(min_length=1)] = Field(
        None, description='Identifies the make of a commodity.'
    )
    model: Optional[constr(min_length=1)] = Field(
        None, description='Identifies the model of a commodity.'
    )
    is_over_dimensional: Optional[bool] = Field(
        None,
        alias='isOverDimensional',
        description='Indicates if a commodity is over dimensional.',
    )
    serial_numbers: Optional[List[str]] = Field(None, alias='serialNumbers')
    year: Optional[confloat(le=8640000000000000.0)] = Field(
        None, description='Identifies the year of a commodity.'
    )
    hazmat_contact_name: Optional[str] = Field(
        None,
        alias='hazmatContactName',
        description='The Emergency Contact Name for hazardous materials.',
    )
    is_hazmat_placard_required: Optional[bool] = Field(
        None,
        alias='isHazmatPlacardRequired',
        description='Indicates if a Hazmat Placard is required on the trailer.',
    )
    hazmat_flashpoint_temp: Optional[HazmatFlashpointTemp] = Field(
        None,
        alias='hazmatFlashpointTemp',
        description='Indicates at what temperature the hazardous material will catch fire.',
    )
    piece_type_term: Optional[str] = Field(
        None,
        alias='pieceTypeTerm',
        description='The pieces contained within the larger handling unit (e.g., boxes).',
    )
    handling_unit_term: Optional[str] = Field(
        None,
        alias='handlingUnitTerm',
        description='The unit that the carrier is responsible for moving (e.g., pallet, drum, crate).',
    )
    handling_unit_count: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='handlingUnitCount',
        description='Number of handling units expected.',
    )
    is_do_not_stack: Optional[bool] = Field(
        None,
        alias='isDoNotStack',
        description='Indicates that the commodity is not to be stacked when loaded.',
    )
    tag_terms: Optional[List[str]] = Field(None, alias='tagTerms')


class RatePerUnit(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    amount: confloat(le=8640000000000000.0) = Field(
        ..., description='The value amount of the rate per unit calculation.'
    )
    currency_code_term: constr(min_length=1) = Field(
        ...,
        alias='currencyCodeTerm',
        description='The currency code for the rate per unit calculation.',
    )


class RateLineItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ..., description='Identifies the rate line item value for an order record.'
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='Identifies the rate line item code for an order record.',
    )
    rate_per_unit: RatePerUnit = Field(
        ...,
        alias='ratePerUnit',
        description='The amount of the rate per unit calculation.',
        title='RateLineMoneyRecord',
    )
    units: confloat(le=8640000000000000.0) = Field(
        ..., description='The number of units for the rate per unit calculation.'
    )


class CargoInsurance(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    amount: confloat(le=8640000000000000.0) = Field(
        ..., description='The value amount of cargo insurance.'
    )
    currency_code_term: constr(min_length=1) = Field(
        ...,
        alias='currencyCodeTerm',
        description='The currency code for the cargo insurance.',
    )


class Reference(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: constr(min_length=1) = Field(
        ..., description='The value amount of a reference number.'
    )
    qualifier_term: constr(min_length=1) = Field(
        ...,
        alias='qualifierTerm',
        description='Identifies the type of reference number (e.g., BOL, PO, shipment id).',
    )


class AssociatedRep(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    employee_code: constr(min_length=1) = Field(
        ...,
        alias='employeeCode',
        description='The externally defined unique identifier for an employee record.',
    )
    customer_rep_type_term: constr(min_length=1) = Field(
        ...,
        alias='customerRepTypeTerm',
        description='Identifies the type of employee for an employee record.',
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description='Indicates if this employee is the main contact.',
    )


class Facility25(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility26(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class CityState8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city: constr(min_length=1) = Field(..., description='The city of the address.')
    state: constr(min_length=2, max_length=3) = Field(
        ..., description='The state of the address (e.g., AZ, AR). ISO 3166-2.'
    )
    county: Optional[str] = Field(None, description='The county of the address.')
    country: constr(min_length=3, max_length=3) = Field(
        ...,
        description='The country of the address (e.g., CAN, MEX, USA). ISO 3166-1 Alpha-3.',
    )


class Coordinates8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    latitude: confloat(ge=-90.0, le=90.0) = Field(
        ..., description='The latitude coordinate.'
    )
    longitude: confloat(ge=-180.0, le=180.0) = Field(
        ..., description='The longitude coordinate.'
    )


class Location11(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Union[Facility25, Facility26] = Field(
        ..., description='The location of the facility.', title='StopCreateFacility'
    )
    city_state: Optional[CityState8] = Field(
        None,
        alias='cityState',
        description='The location of the city and state.',
        title='StopCreateCityState',
    )
    coordinates: Optional[Coordinates8] = Field(
        None, description='The coordinates of the location.', title='Coordinates'
    )
    facility_code: Optional[str] = Field(
        None,
        alias='facilityCode',
        description='The externally defined unique identifier for a facility record.',
    )


class Facility27(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility28(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class Location12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility27, Facility28]] = Field(
        None, description='The location of the facility.', title='StopCreateFacility'
    )
    city_state: CityState8 = Field(
        ...,
        alias='cityState',
        description='The location of the city and state.',
        title='StopCreateCityState',
    )
    coordinates: Optional[Coordinates8] = Field(
        None, description='The coordinates of the location.', title='Coordinates'
    )
    facility_code: Optional[str] = Field(
        None,
        alias='facilityCode',
        description='The externally defined unique identifier for a facility record.',
    )


class Facility29(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility30(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class Location13(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility29, Facility30]] = Field(
        None, description='The location of the facility.', title='StopCreateFacility'
    )
    city_state: Optional[CityState8] = Field(
        None,
        alias='cityState',
        description='The location of the city and state.',
        title='StopCreateCityState',
    )
    coordinates: Coordinates8 = Field(
        ..., description='The coordinates of the location.', title='Coordinates'
    )
    facility_code: Optional[str] = Field(
        None,
        alias='facilityCode',
        description='The externally defined unique identifier for a facility record.',
    )


class Facility31(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility32(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class Location14(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility31, Facility32]] = Field(
        None, description='The location of the facility.', title='StopCreateFacility'
    )
    city_state: Optional[CityState8] = Field(
        None,
        alias='cityState',
        description='The location of the city and state.',
        title='StopCreateCityState',
    )
    coordinates: Optional[Coordinates8] = Field(
        None, description='The coordinates of the location.', title='Coordinates'
    )
    facility_code: str = Field(
        ...,
        alias='facilityCode',
        description='The externally defined unique identifier for a facility record.',
    )


class ScheduleTypeTerm4(Enum):
    appt = 'appt'
    notice = 'notice'
    open = 'open'


class WorkTerm(Enum):
    driver_assist = 'driverAssist'
    lumper = 'lumper'
    no_touch = 'noTouch'


class DriverTarget(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    start_date_time: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ...,
        alias='startDateTime',
        description='The driver target start date and time associated with a stop. Unix timestamp (in milliseconds).',
    )
    end_date_time: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ...,
        alias='endDateTime',
        description='The driver target end date and time associated with a stop. Unix timestamp (in milliseconds).',
    )


class Stop1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally defined unique identifier for a stop record.'
    )
    sequence_number: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        alias='sequenceNumber',
        description='Identifies the sequence number for a stop in a series of stops.',
    )
    location: Union[Location11, Location12, Location13, Location14]
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='The type of stop (e.g., pickup, delivery).',
        title='StopTypeTerm',
    )
    available_start_date_time: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ...,
        alias='availableStartDateTime',
        description='The earliest available start date and time associated with a stop. Unix timestamp (in milliseconds).',
    )
    available_end_date_time: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ...,
        alias='availableEndDateTime',
        description='The latest available start date and time associated with a stop. Unix timestamp (in milliseconds).',
    )
    schedule_type_term: ScheduleTypeTerm4 = Field(
        ...,
        alias='scheduleTypeTerm',
        description='The type of scheduling for the stop location (e.g., appointment, open).',
        title='ScheduleTypeTerm',
    )
    live_drop_term: LiveDropTerm = Field(
        ...,
        alias='liveDropTerm',
        description='Indicates the planned activity at a stop (e.g., live, drop, hook).',
        title='LiveDropTerm',
    )
    work_term: WorkTerm = Field(
        ...,
        alias='workTerm',
        description='Indicates the key services at a stop (e.g., no touch, driver assist, lumper).',
        title='WorkTerm',
    )
    unload_from_term: Optional[str] = Field(
        None,
        alias='unloadFromTerm',
        description='Indicates how the stop will unload the trailer.',
    )
    load_from_term: Optional[str] = Field(
        None,
        alias='loadFromTerm',
        description='Indicates how the stop will load the trailer.',
    )
    notes: Optional[str] = Field(
        None, description='Notes or comments associated with a stop.'
    )
    requested_date: Optional[date] = Field(
        None, alias='requestedDate', description='The requested date of a stop.'
    )
    appointment_start_date_time: Optional[confloat(ge=1.0, le=8640000000000000.0)] = (
        Field(
            None,
            alias='appointmentStartDateTime',
            description='The earliest appointment start date and time associated with a stop. Unix timestamp (in milliseconds).',
        )
    )
    appointment_end_date_time: Optional[confloat(ge=1.0, le=8640000000000000.0)] = (
        Field(
            None,
            alias='appointmentEndDateTime',
            description='The latest appointment start date and time associated with a stop. Unix timestamp (in milliseconds).',
        )
    )
    appointment_requested_with: Optional[str] = Field(
        None,
        alias='appointmentRequestedWith',
        description='Identifies with whom the appointment was requested with.',
    )
    appointment_requested_confirm_with: Optional[str] = Field(
        None,
        alias='appointmentRequestedConfirmWith',
        description='Identifies with whom the appointment was confirmed with.',
    )
    is_confirmed_appointment: Optional[bool] = Field(
        None,
        alias='isConfirmedAppointment',
        description='Indicates if the appointment as been confirmed.',
    )
    requirement_terms: Optional[List[constr(min_length=1)]] = Field(
        None,
        alias='requirementTerms',
        description='Identifies if there are any special requirements associated to a stop record (e.g., food grade, lift gate, liquor permit).',
    )
    references: Optional[List[Reference]] = Field(
        None, description='A list of reference numbers associated to a stop.'
    )
    total_pallet_count: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='totalPalletCount',
        description='The number of the total number of pallets for a stop record.',
    )
    seal_number: Optional[str] = Field(
        None,
        alias='sealNumber',
        description='The seal number to lock the trailer for a stop record.',
    )
    bol_number: Optional[str] = Field(
        None,
        alias='bolNumber',
        description='The bill of lading number for a stop record.',
    )
    driver_target: Optional[DriverTarget] = Field(
        None,
        alias='driverTarget',
        description='The drivertarget field provide a clear understanding of the exact date and time driver should arrive at a facility.',
    )
    commodity_stop_designation_term: Optional[str] = Field(
        None,
        alias='commodityStopDesignationTerm',
        description='The relationship between this stop and the commodities assigned to it (e.g. Origin or Destination).',
    )


class OrdersPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally defined unique identifier for an order record.'
    )
    source: Optional[str] = Field(
        None,
        description='The system that is being used to create the order in MasterMind. This field should only be used if clients have multiple proprietary systems that are used to create orders via API. MasterMind will populate this as Manual, Load repeat, EDI, or API in all other scenarios.',
    )
    customer_code: constr(min_length=1) = Field(
        ...,
        alias='customerCode',
        description='The externally defined unique identifier for a customer record.',
    )
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The type of order (e.g., Empty Movement, Import, Export).',
    )
    bill_to_code: Optional[str] = Field(
        None,
        alias='billToCode',
        description='The internally defined unique identifier for a billing code.',
    )
    activation_status_term: constr(min_length=1) = Field(
        ...,
        alias='activationStatusTerm',
        description='The activation status for an order record, a user will identify action needed on the order.',
    )
    is_financial_disable: Optional[bool] = Field(
        None,
        alias='isFinancialDisable',
        description="Indicates if an order's financials are disabled which will disable any invoices from being processed within MasterMind for this order.",
    )
    order_credit_status: Optional[OrderCreditStatus] = Field(
        None,
        alias='orderCreditStatus',
        description="Details about the customer's credit on the order.",
    )
    tender_status_term: constr(min_length=1) = Field(
        ...,
        alias='tenderStatusTerm',
        description='The status of soliciting bids for an order record (e.g., accepted, declined).',
    )
    mode_term: constr(min_length=1) = Field(
        ...,
        alias='modeTerm',
        description='The mode of transportation required (e.g., truck, rail, air).',
    )
    size_term: constr(min_length=1) = Field(
        ...,
        alias='sizeTerm',
        description='The truckload size of an order record (e.g., FTL, LTL, partial).',
    )
    is_mastered_system: Optional[bool] = Field(
        None,
        alias='isMasteredSystem',
        description='Indicates if the order is mastered or originated in MasterMind.',
    )
    external_order_distance: Optional[ExternalOrderDistance] = Field(
        None,
        alias='externalOrderDistance',
        description='Will override MasterMinds system-calculated miles. Used when there are contracts that are priced based on pre-determined mileage.',
    )
    equipment: Equipment1 = Field(
        ..., description='The type of equipment needed.', title='EquipmentRecord'
    )
    reason_code: Optional[ReasonCode] = Field(
        None,
        alias='reasonCode',
        description='Indicates when an order is set to hold or canceled, this is related to the Order Activation Status.',
        title='ReasonCodeTermRecord',
    )
    commodities: Optional[List[Commodity]] = None
    requirement_terms: Optional[List[constr(min_length=1)]] = Field(
        None, alias='requirementTerms'
    )
    tender_from_customer_code: Optional[str] = Field(
        None,
        alias='tenderFromCustomerCode',
        description='Identifies the customer code that is soliciting bids for an order record.',
    )
    quote_type_term: Optional[str] = Field(
        None,
        alias='quoteTypeTerm',
        description='Identifies the type of quote (e.g., spot, committed).',
    )
    price_tier_term: Optional[str] = Field(
        None,
        alias='priceTierTerm',
        description='Identifies the type of price tier (e.g., primary, spot, backup).',
    )
    relation_term: Optional[str] = Field(
        None,
        alias='relationTerm',
        description='Identifies the type of order relationship.',
    )
    division_term: Optional[str] = Field(
        None,
        alias='divisionTerm',
        description='Identifies the division type of the client (e.g., asset, brokerage).',
    )
    business_unit_term: Optional[str] = Field(
        None,
        alias='businessUnitTerm',
        description='Identifies the planned business unit of the client.',
    )
    project_term: Optional[str] = Field(
        None,
        alias='projectTerm',
        description='Identifies the segmented freight focused on a specific project.',
    )
    segment_code: Optional[str] = Field(
        None,
        alias='segmentCode',
        description='Identifies a way to create further segmentation of freight that cannot be accomplished by the way of Division, Project or Dedicated Fleet Program.',
    )
    service_level_term: Optional[str] = Field(
        None,
        alias='serviceLevelTerm',
        description='Identifies the service level of an order (e.g., standard, expedited).',
    )
    notes: Optional[str] = Field(
        None, description='Notes or comments associated with an order record.'
    )
    payment_term: Optional[str] = Field(
        None,
        alias='paymentTerm',
        description='Indicated how the payment will be made for an order record (e.g., collect, prepaid).',
    )
    rate_line_items: Optional[List[RateLineItem]] = Field(
        None,
        alias='rateLineItems',
        description='An itemized list of expenditures the customer will pay for an order record.',
    )
    cargo_insurance: Optional[CargoInsurance] = Field(
        None,
        alias='cargoInsurance',
        description='The amount of cargo insurance required for this load to cover the replacement cost of freight if damaged or destroyed in transit.',
        title='CargoInsuranceMoneyRecord',
    )
    references: Optional[List[Reference]] = None
    associated_reps: Optional[List[AssociatedRep]] = Field(None, alias='associatedReps')
    brace_count: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='braceCount',
        description='The number of bracing required for the load.',
    )
    brace_type_terms: Optional[List[constr(min_length=1)]] = Field(
        None,
        alias='braceTypeTerms',
        description='The type of bracing required for the load.',
    )
    invoice_notes: Optional[str] = Field(
        None,
        alias='invoiceNotes',
        description='Notes or comments associated with an order invoice record.',
    )
    number_of_pallets: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='numberOfPallets',
        description='The number of pallets for an order record.',
    )
    scac: Optional[str] = Field(
        None,
        description='Identifies the Standard Carrier Alpha Code which is a two to four letter code used to identify transportation companies.',
    )
    scac_term: Optional[str] = Field(
        None,
        alias='scacTerm',
        description='Identifies the Standard Carrier Alpha Code which is a two to four letter code used to identify transportation companies. The client defined tenant SCAC.',
    )
    tarp_count: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='tarpCount',
        description='The number of tarps required for the load.',
    )
    tarp_type_term: Optional[str] = Field(
        None,
        alias='tarpTypeTerm',
        description='The type of tarps required for the load (e.g., lumber, steel).',
    )
    stops: Optional[List[Stop1]] = None


class UnitTerm37(Enum):
    ft = 'ft'
    in_ = 'in'
    m = 'm'
    km = 'km'
    mi = 'mi'


class ExternalOrderDistance1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    unit_term: UnitTerm37 = Field(
        ...,
        alias='unitTerm',
        description='The distance term used to measure the distance (e.g., miles, kilometers).',
        title='ExternalOrderDistanceUnitTerm',
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value of the distance.'
    )


class MinimumLength2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the minimum required length of equipment.'
    )
    unit_term: UnitTerm37 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the minimum required length of equipment.',
        title='MinLengthUnitTerm',
    )


class Width3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the required width of equipment.'
    )
    unit_term: UnitTerm37 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the required width of equipment.',
        title='WidthUnitTerm',
    )


class Height3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the required height of equipment.'
    )
    unit_term: UnitTerm37 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the required height of equipment.',
        title='HeightUnitTerm',
    )


class Dimensions2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    minimum_length: Optional[MinimumLength2] = Field(
        None,
        alias='minimumLength',
        description='The minimum required length of equipment.',
        title='MinimumLengthFullPatchRecord',
    )
    width: Optional[Width3] = Field(
        None,
        description='The minimum required width of equipment.',
        title='WidthFullPatchRecord',
    )
    height: Optional[Height3] = Field(
        None,
        description='The minimum required height of equipment.',
        title='HeightFullPatchRecord',
    )


class Equipment2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    trailer_type_terms: List[str] = Field(..., alias='trailerTypeTerms', min_length=1)
    dimensions: Optional[Dimensions2] = Field(
        None,
        description='The dimensional requirements for equipment.',
        title='DimensionsFullPatchRecord',
    )


class UnitTerm41(Enum):
    g = 'g'
    kg = 'kg'
    lbs = 'lbs'
    st = 'st'
    tons = 'tons'
    tonnes = 'tonnes'


class ExpectedWeight1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value amount for the expected weight of a commodity.'
    )
    unit_term: UnitTerm41 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected weight of a commodity.',
        title='ExpectedWeightCommodityCreateUnitTerm',
    )


class UnitTerm42(Enum):
    usd = 'USD'
    cad = 'CAD'
    mxn = 'MXN'


class CommodityValue1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value amount for the commodity value.'
    )
    unit_term: UnitTerm42 = Field(
        ..., alias='unitTerm', description='The currency code for the commodity value.'
    )


class UnitTerm43(Enum):
    f = 'f'
    c = 'c'


class PreCoolTo1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The value amount for a specific temperature to set the refridgerated trailer to before arriving at the shipper.',
    )
    unit_term: UnitTerm43 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for a specific temperature to set the refridgerated trailer to before arriving at the shipper.',
        title='PreCoolToUnit',
    )


class MinimumTemperature1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The value amount for the minimum temperature the commodity must be kept at.',
    )
    unit_term: UnitTerm43 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the minimum temperature the commodity must be kept at.',
        title='MinimumTemperatureUnit',
    )


class MaximumTemperature1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The value amount for the maximum temperature a commodity can reach.',
    )
    unit_term: UnitTerm43 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the maximum temperature a commodity can reach.',
        title='MaximumTemperatureUnit',
    )


class TemperatureSettingTerm1Enum(Enum):
    continuous = 'continuous'
    cycle = 'cycle'


class TemperatureSettingTerm1(RootModel[Optional[TemperatureSettingTerm1Enum]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Optional[TemperatureSettingTerm1Enum] = Field(
        None,
        description='Indicates if the refrigerated trailer temperature control must run continuous or if it can cycle on and off.',
    )


class HazmatPackagingGroupTerm1Enum(Enum):
    i = 'I'
    ii = 'II'
    iii = 'III'


class HazmatPackagingGroupTerm1(RootModel[Optional[HazmatPackagingGroupTerm1Enum]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Optional[HazmatPackagingGroupTerm1Enum] = None


class UnitTerm46(Enum):
    ft = 'ft'
    in_ = 'in'
    cm = 'cm'
    m = 'm'


class Length3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected length of a commodity.'
    )
    unit_term: UnitTerm46 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected length of a commodity.',
        title='ExpectedLengthUnitTerm',
    )


class Width4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected width of a commodity.'
    )
    unit_term: UnitTerm46 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected width of a commodity.',
        title='ExpectedWidthUnitTerm',
    )


class Height4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected height of a commodity.'
    )
    unit_term: UnitTerm46 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected height of a commodity.',
        title='ExpectedHeightUnitTerm',
    )


class ExpectedDimensions1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    length: Optional[Length3] = Field(
        None,
        description='The expected length of a commodity.',
        title='ExpectedLengthCommodityPatchRecord',
    )
    width: Optional[Width4] = Field(
        None,
        description='The expected width of a commodity.',
        title='ExpectedWidthCommodityFullPatchRecord',
    )
    height: Optional[Height4] = Field(
        None,
        description='The expected height of a commodity.',
        title='ExpectedHeightCommodityFullPatchRecord',
    )


class ExpectedLinear1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected linear dimensions of a commodity.'
    )
    unit_term: UnitTerm46 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected linear dimensions of a commodity, (e.g., feet, inches).',
        title='ExpectedLinearUnitTerm',
    )


class UnitTerm50(Enum):
    in3 = 'in3'
    ft3 = 'ft3'
    cm3 = 'cm3'
    m3 = 'm3'


class ExpectedCube1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        description='The value for the expected the cubic dimensions of a commodity.',
    )
    unit_term: UnitTerm50 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected cubic dimensions of a commodity.',
        title='ExpectedCubeUnitTerm',
    )


class UnitTerm51(Enum):
    lb_in3 = 'lb/in3'
    lb_ft3 = 'lb/ft3'
    cwt_ft3 = 'cwt/ft3'
    kg_cm3 = 'kg/cm3'
    kg_m3 = 'kg/m3'


class ExpectedDensity1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected density of a commodity.'
    )
    unit_term: UnitTerm51 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected density of a commodity.',
        title='ExpectedDensityUnitTerm',
    )


class UnitTerm52(Enum):
    f = 'f'
    c = 'c'


class HazmatFlashpointTemp1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The value of the temperature the hazardous material will catch fire.',
    )
    unit_term: UnitTerm52 = Field(
        ..., alias='unitTerm', description='The unit of measurement of the temperature.'
    )


class Commodity1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this commodity should be destroyed.',
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined unique identifier for a commodity record.',
    )
    code: Optional[constr(min_length=1)] = Field(
        None,
        description='The internally defined unique identifier of commodities to be shipped for an order.',
    )
    description: Optional[constr(min_length=1)] = Field(
        None, description='The description of commodities to be shipped for an order.'
    )
    expected_weight: Optional[ExpectedWeight1] = Field(
        None,
        alias='expectedWeight',
        description='The expected weight for a commodity.',
        title='ExpectedWeightCommodityPatchRecord',
    )
    expected_pieces: Optional[int] = Field(
        None,
        alias='expectedPieces',
        description='The expected number of pieces for a commodity.',
    )
    number: Optional[int] = Field(
        None, description='The number of pieces of a commodity.'
    )
    packaging_unit: Optional[str] = Field(
        None,
        alias='packagingUnit',
        description='The unit of measurement for the number of pieces of a commodity (e.g., pallet, drum, crate).',
    )
    load_on_term: Optional[str] = Field(
        None,
        alias='loadOnTerm',
        description='Identifies how the freight should be loaded on the trailer.',
    )
    is_hazmat: Optional[bool] = Field(
        None,
        alias='isHazmat',
        description='Identifies if there are hazardous materials for a commodity.',
    )
    is_temp_controlled: Optional[bool] = Field(
        None,
        alias='isTempControlled',
        description='Identifies if a commodity requires its temperature to be controlled.',
    )
    stcc_code: Optional[constr(min_length=1)] = Field(
        None,
        alias='stccCode',
        description='The Standard Transportation Commodity Code is a publication containing specific product information used on shipping documents.',
    )
    stop_codes: Optional[List[str]] = Field(None, alias='stopCodes')
    commodity_value: Optional[CommodityValue1] = Field(
        None,
        alias='commodityValue',
        description='Identifies the total value of an individual commodity in case a claim needs to be filed for it.',
    )
    associated_stops: Optional[List[AssociatedStop]] = Field(
        None,
        alias='associatedStops',
        description='Identifies if a commodity is associated with a particular stop.',
    )
    is_top_loadable: Optional[bool] = Field(
        None,
        alias='isTopLoadable',
        description='Identifies if a commodity can be loaded on top of other commodities.',
    )
    is_bottom_loadable: Optional[bool] = Field(
        None,
        alias='isBottomLoadable',
        description='Identifies if a commodity can be loaded on the bottom of other commodities.',
    )
    pre_cool_to: Optional[PreCoolTo1] = Field(
        None,
        alias='preCoolTo',
        description='Identifies a specific temperature to set the refridgerated trailer to before arriving at the shipper.',
    )
    minimum_temperature: Optional[MinimumTemperature1] = Field(
        None,
        alias='minimumTemperature',
        description='Identifies the minimum temperature the commodity must be kept at.',
    )
    maximum_temperature: Optional[MaximumTemperature1] = Field(
        None,
        alias='maximumTemperature',
        description='Identifies the maximum temperature a commodity can reach.',
    )
    temperature_setting_term: Optional[TemperatureSettingTerm1] = Field(
        None,
        alias='temperatureSettingTerm',
        description='Indicates if the refrigerated trailer temperature control must run continuous or if it can cycle on and off.',
    )
    hazmat_class_term: Optional[str] = Field(
        None,
        alias='hazmatClassTerm',
        description='Identifies which hazardous materials class a commodity belongs to.',
    )
    hazmat_packaging_group_term: Optional[HazmatPackagingGroupTerm1] = Field(
        None, alias='hazmatPackagingGroupTerm'
    )
    hazmat_united_nations_number: Optional[constr(min_length=1)] = Field(
        None,
        alias='hazmatUnitedNationsNumber',
        description='A four digit number that identify dangerous goods or hazardous substances.',
    )
    hazmat_phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='hazmatPhoneNumber',
        description='The emergency response telephone number forhazardous materials.',
    )
    expected_dimensions: Optional[ExpectedDimensions1] = Field(
        None,
        alias='expectedDimensions',
        description='The expected dimensions of a commodity.',
    )
    expected_linear: Optional[ExpectedLinear1] = Field(
        None,
        alias='expectedLinear',
        description='The expected linear dimensions of a commodity.',
    )
    expected_cube: Optional[ExpectedCube1] = Field(
        None,
        alias='expectedCube',
        description='The expected cubic dimensions of a commodity.',
    )
    expected_density: Optional[ExpectedDensity1] = Field(
        None,
        alias='expectedDensity',
        description='The expected density of a commodity.',
    )
    expected_class_term: Optional[str] = Field(
        None,
        alias='expectedClassTerm',
        description='Identifies the expected freight class code that uses a classification system for commodities transported via LTL freight shipping; the lower the freight class, the lower the shipping price.',
    )
    expected_nmfc: Optional[constr(min_length=1)] = Field(
        None,
        alias='expectedNMFC',
        description='Identifies the expected National Motor Freight Classification code which is a designation used to group commodities.',
    )
    make: Optional[constr(min_length=1)] = Field(
        None, description='Identifies the make of a commodity.'
    )
    model: Optional[constr(min_length=1)] = Field(
        None, description='Identifies the model of a commodity.'
    )
    is_over_dimensional: Optional[bool] = Field(
        None,
        alias='isOverDimensional',
        description='Indicates if a commodity is over dimensional.',
    )
    serial_numbers: Optional[List[str]] = Field(None, alias='serialNumbers')
    year: Optional[confloat(le=8640000000000000.0)] = Field(
        None, description='Identifies the year of a commodity.'
    )
    hazmat_contact_name: Optional[str] = Field(
        None,
        alias='hazmatContactName',
        description='The Emergency Contact Name for hazardous materials.',
    )
    is_hazmat_placard_required: Optional[bool] = Field(
        None,
        alias='isHazmatPlacardRequired',
        description='Indicates if a Hazmat Placard is required on the trailer.',
    )
    hazmat_flashpoint_temp: Optional[HazmatFlashpointTemp1] = Field(
        None,
        alias='hazmatFlashpointTemp',
        description='Indicates at what temperature the hazardous material will catch fire.',
    )
    piece_type_term: Optional[str] = Field(
        None,
        alias='pieceTypeTerm',
        description='The pieces contained within the larger handling unit (e.g., boxes).',
    )
    handling_unit_term: Optional[str] = Field(
        None,
        alias='handlingUnitTerm',
        description='The unit that the carrier is responsible for moving (e.g., pallet, drum, crate).',
    )
    handling_unit_count: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='handlingUnitCount',
        description='Number of handling units expected.',
    )
    is_do_not_stack: Optional[bool] = Field(
        None,
        alias='isDoNotStack',
        description='Indicates that the commodity is not to be stacked when loaded.',
    )
    tag_terms: Optional[List[str]] = Field(None, alias='tagTerms')


class RateLineItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this rate line item should be destroyed.',
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined unique identifier for a rate line item record.',
    )
    code: Optional[constr(min_length=1)] = Field(
        None, description='Identifies the rate line item value for an order record.'
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='Identifies the rate line item code for an order record.',
    )
    rate_per_unit: Optional[RatePerUnit] = Field(
        None,
        alias='ratePerUnit',
        description='The amount of the rate per unit calculation.',
        title='RateLineMoneyPatchRecord',
    )
    units: Optional[confloat(le=8640000000000000.0)] = Field(
        None, description='The number of units for the rate per unit calculation.'
    )


class Reference2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this reference should be destroyed.',
    )
    id: Optional[str] = Field(
        None,
        description='The externally defined unique identifier for a reference record.',
    )
    value: Optional[constr(min_length=1)] = Field(
        None, description='The value amount of a reference number.'
    )
    qualifier_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='qualifierTerm',
        description='Identifies the type of reference number (e.g., BOL, PO, shipment id).',
    )


class AssociatedRep1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this associated rep should be destroyed.',
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined unique identifier for an employee record.',
    )
    employee_code: Optional[constr(min_length=1)] = Field(
        None,
        alias='employeeCode',
        description='The externally defined unique identifier for an employee record.',
    )
    customer_rep_type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='customerRepTypeTerm',
        description='Identifies the type of employee for an employee record.',
    )
    is_main: Optional[bool] = Field(
        None,
        alias='isMain',
        description='Indicates if this employee is the main contact.',
    )


class Facility33(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class CityState12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city: Optional[str] = Field(None, description='The city of the address.')
    state: Optional[constr(min_length=2, max_length=3)] = Field(
        None, description='The state of the address (e.g., AZ, AR). ISO 3166-2.'
    )
    county: Optional[str] = Field(None, description='The county of the address.')
    country: Optional[constr(min_length=3, max_length=3)] = Field(
        None,
        description='The country of the address (e.g., CAN, MEX, USA). ISO 3166-1 Alpha-3.',
    )


class Location15(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Facility33] = Field(
        None, description='The location of the facility.', title='StopPatchFacility'
    )
    city_state: Optional[CityState12] = Field(
        None,
        alias='cityState',
        description='The location of the city and state.',
        title='StopPatchCityState',
    )
    coordinates: Optional[Coordinates8] = Field(
        None,
        description='The coordinates of the location.',
        title='StopPatchCoordinates',
    )
    facility_code: Optional[str] = Field(
        None,
        alias='facilityCode',
        description='The externally defined unique identifier for a facility record.',
    )


class Stop2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this stop should be destroyed.',
    )
    id: Optional[constr(min_length=1)] = Field(
        None,
        description='The internally defined unique identifier for a route stop record.',
    )
    code: Optional[constr(min_length=1)] = Field(
        None, description='The externally defined unique identifier for a stop record.'
    )
    sequence_number: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='sequenceNumber',
        description='Identifies the sequence number for a stop in a series of stops.',
    )
    location: Optional[Location15] = Field(
        None,
        description='Identifies the location for a stop record.',
        title='LocationPatchRecord',
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='The type of stop (e.g., pickup, delivery).',
        title='StopTypeTerm',
    )
    available_start_date_time: Optional[confloat(ge=1.0, le=8640000000000000.0)] = (
        Field(
            None,
            alias='availableStartDateTime',
            description='The earliest available start date and time associated with a stop. Unix timestamp (in milliseconds).',
        )
    )
    available_end_date_time: Optional[confloat(ge=1.0, le=8640000000000000.0)] = Field(
        None,
        alias='availableEndDateTime',
        description='The latest available start date and time associated with a stop. Unix timestamp (in milliseconds).',
    )
    schedule_type_term: Optional[ScheduleTypeTerm4] = Field(
        None,
        alias='scheduleTypeTerm',
        description='The type of scheduling for the stop location (e.g., appointment, open).',
        title='ScheduleTypeTerm',
    )
    live_drop_term: Optional[LiveDropTerm] = Field(
        None,
        alias='liveDropTerm',
        description='Indicates the planned activity at a stop (e.g., live, drop, hook).',
        title='LiveDropTerm',
    )
    work_term: Optional[WorkTerm] = Field(
        None,
        alias='workTerm',
        description='Indicates the key services at a stop (e.g., no touch, driver assist, lumper).',
        title='WorkTerm',
    )
    unload_from_term: Optional[str] = Field(
        None,
        alias='unloadFromTerm',
        description='Indicates how the stop will unload the trailer.',
    )
    load_from_term: Optional[str] = Field(
        None,
        alias='loadFromTerm',
        description='Indicates how the stop will load the trailer.',
    )
    notes: Optional[str] = Field(
        None, description='Notes or comments associated with a stop.'
    )
    requested_date: Optional[date] = Field(
        None, alias='requestedDate', description='The requested date of a stop.'
    )
    appointment_start_date_time: Optional[confloat(ge=1.0, le=8640000000000000.0)] = (
        Field(
            None,
            alias='appointmentStartDateTime',
            description='The earliest appointment start date and time associated with a stop. Unix timestamp (in milliseconds).',
        )
    )
    appointment_end_date_time: Optional[confloat(ge=1.0, le=8640000000000000.0)] = (
        Field(
            None,
            alias='appointmentEndDateTime',
            description='The latest appointment start date and time associated with a stop. Unix timestamp (in milliseconds).',
        )
    )
    appointment_requested_with: Optional[str] = Field(
        None,
        alias='appointmentRequestedWith',
        description='Identifies with whom the appointment was requested with.',
    )
    appointment_requested_confirm_with: Optional[str] = Field(
        None,
        alias='appointmentRequestedConfirmWith',
        description='Identifies with whom the appointment was confirmed with.',
    )
    is_confirmed_appointment: Optional[bool] = Field(
        None,
        alias='isConfirmedAppointment',
        description='Indicates if the appointment as been confirmed.',
    )
    requirement_terms: Optional[List[str]] = Field(None, alias='requirementTerms')
    references: Optional[List[Reference2]] = Field(
        None, description='A list of reference numbers associated to a stop.'
    )
    total_pallet_count: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='totalPalletCount',
        description='The number of the total number of pallets for a stop record.',
    )
    seal_number: Optional[str] = Field(
        None,
        alias='sealNumber',
        description='The seal number to lock the trailer for a stop record.',
    )
    bol_number: Optional[str] = Field(
        None,
        alias='bolNumber',
        description='The bill of lading number for a stop record.',
    )
    commodity_stop_designation_term: Optional[str] = Field(
        None,
        alias='commodityStopDesignationTerm',
        description='The relationship between this stop and the commodities assigned to it (e.g. Origin or Destination).',
    )


class OrdersIdentifierValuePATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    customer_code: Optional[str] = Field(
        None,
        alias='customerCode',
        description='The externally defined unique identifier for a customer record.',
    )
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The type of order (e.g., Empty Movement, Import, Export).',
    )
    bill_to_code: Optional[str] = Field(
        None,
        alias='billToCode',
        description='The internally defined unique identifier for a billing code.',
    )
    activation_status_term: Optional[str] = Field(
        None,
        alias='activationStatusTerm',
        description='The activation status for an order record, a user will identify action needed on the order.',
    )
    is_financial_disable: Optional[bool] = Field(
        None,
        alias='isFinancialDisable',
        description="Indicates if an order's financials are disabled which will disable any invoices from being processed within MasterMind for this order.",
    )
    order_credit_status: Optional[OrderCreditStatus] = Field(
        None,
        alias='orderCreditStatus',
        description="Details about the customer's credit on the order.",
    )
    tender_status_term: Optional[str] = Field(
        None,
        alias='tenderStatusTerm',
        description='The status of soliciting bids for an order record (e.g., accepted, declined).',
    )
    mode_term: Optional[str] = Field(
        None,
        alias='modeTerm',
        description='The mode of transportation required (e.g., truck, rail, air).',
    )
    size_term: Optional[str] = Field(
        None,
        alias='sizeTerm',
        description='The truckload size of an order record (e.g., FTL, LTL, partial).',
    )
    is_mastered_system: Optional[bool] = Field(
        None,
        alias='isMasteredSystem',
        description='Indicates if the order is mastered or originated in MasterMind.',
    )
    external_order_distance: Optional[ExternalOrderDistance1] = Field(
        None,
        alias='externalOrderDistance',
        description='Will override MasterMinds system-calculated miles. Used when there are contracts that are priced based on pre-determined mileage.',
    )
    equipment: Optional[Equipment2] = Field(
        None, description='The type of equipment needed.'
    )
    reason_code: Optional[ReasonCode] = Field(None, alias='reasonCode')
    requirement_terms: Optional[List[str]] = Field(None, alias='requirementTerms')
    tender_from_customer_code: Optional[str] = Field(
        None,
        alias='tenderFromCustomerCode',
        description='Identifies the customer code that is soliciting bids for an order record.',
    )
    quote_type_term: Optional[str] = Field(
        None,
        alias='quoteTypeTerm',
        description='Identifies the type of quote (e.g., spot, committed).',
    )
    price_tier_term: Optional[str] = Field(
        None,
        alias='priceTierTerm',
        description='Identifies the type of price tier (e.g., primary, spot, backup).',
    )
    relation_term: Optional[str] = Field(
        None,
        alias='relationTerm',
        description='Identifies the type of order relationship.',
    )
    division_term: Optional[str] = Field(
        None,
        alias='divisionTerm',
        description='Identifies the division type of the client (e.g., asset, brokerage).',
    )
    business_unit_term: Optional[str] = Field(
        None,
        alias='businessUnitTerm',
        description='Identifies the planned business unit of the client.',
    )
    project_term: Optional[str] = Field(
        None,
        alias='projectTerm',
        description='Identifies the segmented freight focused on a specific project.',
    )
    segment_code: Optional[str] = Field(
        None,
        alias='segmentCode',
        description='Identifies a way to create further segmentation of freight that cannot be accomplished by the way of Division, Project or Dedicated Fleet Program.',
    )
    service_level_term: Optional[str] = Field(
        None,
        alias='serviceLevelTerm',
        description='Identifies the service level of an order (e.g., standard, expedited).',
    )
    notes: Optional[str] = Field(
        None, description='Notes or comments associated with an order record.'
    )
    payment_term: Optional[str] = Field(
        None,
        alias='paymentTerm',
        description='Indicated how the payment will be made for an order record (e.g., collect, prepaid).',
    )
    cargo_insurance: Optional[CargoInsurance] = Field(
        None,
        alias='cargoInsurance',
        description='The amount of cargo insurance required for this load to cover the replacement cost of freight if damaged or destroyed in transit.',
    )
    brace_count: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='braceCount',
        description='The number of bracing required for the load.',
    )
    brace_type_terms: Optional[List[constr(min_length=1)]] = Field(
        None,
        alias='braceTypeTerms',
        description='The type of bracing required for the load.',
    )
    invoice_notes: Optional[str] = Field(
        None,
        alias='invoiceNotes',
        description='Notes or comments associated with an order invoice record.',
    )
    number_of_pallets: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='numberOfPallets',
        description='The number of pallets for an order record.',
    )
    scac: Optional[str] = Field(
        None,
        description='Identifies the Standard Carrier Alpha Code which is a two to four letter code used to identify transportation companies.',
    )
    scac_term: Optional[str] = Field(
        None,
        alias='scacTerm',
        description='Identifies the Standard Carrier Alpha Code which is a two to four letter code used to identify transportation companies. The client defined tenant SCAC.',
    )
    tarp_count: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='tarpCount',
        description='The number of tarps required for the load.',
    )
    tarp_type_term: Optional[str] = Field(
        None,
        alias='tarpTypeTerm',
        description='The type of tarps required for the load (e.g., lumber, steel).',
    )
    commodities: Optional[List[Commodity1]] = Field(
        None, description='A collection of commodities to be shipped for an order.'
    )
    rate_line_items: Optional[List[RateLineItem1]] = Field(
        None,
        alias='rateLineItems',
        description='An itemized list of expenditures the customer will pay for an order record.',
    )
    references: Optional[List[Reference2]] = Field(
        None, description='A list of reference numbers associated to an order record.'
    )
    associated_reps: Optional[List[AssociatedRep1]] = Field(
        None,
        alias='associatedReps',
        description='A list of employees associated with an order record.',
    )
    stops: Optional[List[Stop2]] = Field(
        None,
        description='A list of locations of the pick ups and deliveries for an order record.',
    )


class OrdersIdentifierValueassociatedRepsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    employee_code: constr(min_length=1) = Field(
        ...,
        alias='employeeCode',
        description='The externally defined unique identifier for an employee record.',
    )
    customer_rep_type_term: constr(min_length=1) = Field(
        ...,
        alias='customerRepTypeTerm',
        description='Identifies the type of employee for an employee record.',
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description='Indicates if this employee is the main contact.',
    )


class OrdersIdentifierValueassociatedRepsRepIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    employee_code: constr(min_length=1) = Field(
        ...,
        alias='employeeCode',
        description='The externally defined unique identifier for an employee record.',
    )
    customer_rep_type_term: constr(min_length=1) = Field(
        ...,
        alias='customerRepTypeTerm',
        description='Identifies the type of employee for an employee record.',
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description='Indicates if this employee is the main contact.',
    )


class UnitTerm53(Enum):
    g = 'g'
    kg = 'kg'
    lbs = 'lbs'
    st = 'st'
    tons = 'tons'
    tonnes = 'tonnes'


class ExpectedWeight2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value amount for the expected weight of a commodity.'
    )
    unit_term: UnitTerm53 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected weight of a commodity.',
        title='ExpectedWeightCommodityCreateUnitTerm',
    )


class UnitTerm54(Enum):
    usd = 'USD'
    cad = 'CAD'
    mxn = 'MXN'


class CommodityValue2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value amount for the commodity value.'
    )
    unit_term: UnitTerm54 = Field(
        ..., alias='unitTerm', description='The currency code for the commodity value.'
    )


class UnitTerm55(Enum):
    f = 'f'
    c = 'c'


class PreCoolTo2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The value amount for a specific temperature to set the refridgerated trailer to before arriving at the shipper.',
    )
    unit_term: UnitTerm55 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for a specific temperature to set the refridgerated trailer to before arriving at the shipper.',
        title='PreCoolToUnit',
    )


class MinimumTemperature2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The value amount for the minimum temperature the commodity must be kept at.',
    )
    unit_term: UnitTerm55 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the minimum temperature the commodity must be kept at.',
        title='MinimumTemperatureUnit',
    )


class MaximumTemperature2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The value amount for the maximum temperature a commodity can reach.',
    )
    unit_term: UnitTerm55 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the maximum temperature a commodity can reach.',
        title='MaximumTemperatureUnit',
    )


class TemperatureSettingTerm2Enum(Enum):
    continuous = 'continuous'
    cycle = 'cycle'


class TemperatureSettingTerm2(RootModel[Optional[TemperatureSettingTerm2Enum]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Optional[TemperatureSettingTerm2Enum] = Field(
        None,
        description='Indicates if the refrigerated trailer temperature control must run continuous or if it can cycle on and off.',
    )


class HazmatPackagingGroupTerm2Enum(Enum):
    i = 'I'
    ii = 'II'
    iii = 'III'


class HazmatPackagingGroupTerm2(RootModel[Optional[HazmatPackagingGroupTerm2Enum]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Optional[HazmatPackagingGroupTerm2Enum] = None


class UnitTerm58(Enum):
    ft = 'ft'
    in_ = 'in'
    cm = 'cm'
    m = 'm'


class Length4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected length of a commodity.'
    )
    unit_term: UnitTerm58 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected length of a commodity.',
        title='ExpectedLengthUnitTerm',
    )


class Width5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected width of a commodity.'
    )
    unit_term: UnitTerm58 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected width of a commodity.',
        title='ExpectedWidthUnitTerm',
    )


class Height5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected height of a commodity.'
    )
    unit_term: UnitTerm58 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected height of a commodity.',
        title='ExpectedHeightUnitTerm',
    )


class ExpectedDimensions2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    length: Optional[Length4] = Field(
        None,
        description='The expected length of a commodity.',
        title='ExpectedLengthCommodityCreateRecord',
    )
    width: Optional[Width5] = Field(
        None,
        description='The expected width of a commodity.',
        title='ExpectedWidthCommodityCreateRecord',
    )
    height: Optional[Height5] = Field(
        None,
        description='The expected height of a commodity.',
        title='ExpectedHeightCommodityCreateRecord',
    )


class ExpectedLinear2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected linear dimensions of a commodity.'
    )
    unit_term: UnitTerm58 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected linear dimensions of a commodity, (e.g., feet, inches).',
        title='ExpectedLinearUnitTerm',
    )


class UnitTerm62(Enum):
    in3 = 'in3'
    ft3 = 'ft3'
    cm3 = 'cm3'
    m3 = 'm3'


class ExpectedCube2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        description='The value for the expected the cubic dimensions of a commodity.',
    )
    unit_term: UnitTerm62 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected cubic dimensions of a commodity.',
        title='ExpectedCubeUnitTerm',
    )


class UnitTerm63(Enum):
    lb_in3 = 'lb/in3'
    lb_ft3 = 'lb/ft3'
    cwt_ft3 = 'cwt/ft3'
    kg_cm3 = 'kg/cm3'
    kg_m3 = 'kg/m3'


class ExpectedDensity2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected density of a commodity.'
    )
    unit_term: UnitTerm63 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected density of a commodity.',
        title='ExpectedDensityUnitTerm',
    )


class UnitTerm64(Enum):
    f = 'f'
    c = 'c'


class HazmatFlashpointTemp2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The value of the temperature the hazardous material will catch fire.',
    )
    unit_term: UnitTerm64 = Field(
        ..., alias='unitTerm', description='The unit of measurement of the temperature.'
    )


class OrdersIdentifierValuecommoditiesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The internally defined unique identifier of commodities to be shipped for an order.',
    )
    description: constr(min_length=1) = Field(
        ..., description='The description of commodities to be shipped for an order.'
    )
    expected_weight: ExpectedWeight2 = Field(
        ...,
        alias='expectedWeight',
        description='The expected weight for a commodity.',
        title='ExpectedWeightCommodityCreateRecord',
    )
    expected_pieces: Optional[int] = Field(
        None,
        alias='expectedPieces',
        description='The expected number of pieces for a commodity.',
    )
    number: Optional[int] = Field(
        None, description='The number of pieces of a commodity.'
    )
    packaging_unit: Optional[str] = Field(
        None,
        alias='packagingUnit',
        description='The unit of measurement for the number of pieces of a commodity (e.g., pallet, drum, crate).',
    )
    load_on_term: Optional[str] = Field(
        None,
        alias='loadOnTerm',
        description='Identifies how the freight should be loaded on the trailer.',
    )
    is_hazmat: Optional[bool] = Field(
        None,
        alias='isHazmat',
        description='Identifies if there are hazardous materials for a commodity.',
    )
    is_temp_controlled: Optional[bool] = Field(
        None,
        alias='isTempControlled',
        description='Identifies if a commodity requires its temperature to be controlled.',
    )
    stcc_code: Optional[constr(min_length=1)] = Field(
        None,
        alias='stccCode',
        description='The Standard Transportation Commodity Code is a publication containing specific product information used on shipping documents.',
    )
    stop_codes: Optional[List[str]] = Field(None, alias='stopCodes')
    commodity_value: Optional[CommodityValue2] = Field(
        None,
        alias='commodityValue',
        description='Identifies the total value of an individual commodity in case a claim needs to be filed for it.',
    )
    associated_stops: Optional[List[AssociatedStop]] = Field(
        None,
        alias='associatedStops',
        description='Identifies if a commodity is associated with a particular stop.',
    )
    is_top_loadable: Optional[bool] = Field(
        None,
        alias='isTopLoadable',
        description='Identifies if a commodity can be loaded on top of other commodities.',
    )
    is_bottom_loadable: Optional[bool] = Field(
        None,
        alias='isBottomLoadable',
        description='Identifies if a commodity can be loaded on the bottom of other commodities.',
    )
    pre_cool_to: Optional[PreCoolTo2] = Field(
        None,
        alias='preCoolTo',
        description='Identifies a specific temperature to set the refridgerated trailer to before arriving at the shipper.',
    )
    minimum_temperature: Optional[MinimumTemperature2] = Field(
        None,
        alias='minimumTemperature',
        description='Identifies the minimum temperature the commodity must be kept at.',
    )
    maximum_temperature: Optional[MaximumTemperature2] = Field(
        None,
        alias='maximumTemperature',
        description='Identifies the maximum temperature a commodity can reach.',
    )
    temperature_setting_term: Optional[TemperatureSettingTerm2] = Field(
        None,
        alias='temperatureSettingTerm',
        description='Indicates if the refrigerated trailer temperature control must run continuous or if it can cycle on and off.',
    )
    hazmat_class_term: Optional[str] = Field(
        None,
        alias='hazmatClassTerm',
        description='Identifies which hazardous materials class a commodity belongs to.',
    )
    hazmat_packaging_group_term: Optional[HazmatPackagingGroupTerm2] = Field(
        None, alias='hazmatPackagingGroupTerm'
    )
    hazmat_united_nations_number: Optional[constr(min_length=1)] = Field(
        None,
        alias='hazmatUnitedNationsNumber',
        description='A four digit number that identify dangerous goods or hazardous substances.',
    )
    hazmat_phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='hazmatPhoneNumber',
        description='The emergency response telephone number forhazardous materials.',
    )
    expected_dimensions: Optional[ExpectedDimensions2] = Field(
        None,
        alias='expectedDimensions',
        description='The expected dimensions of a commodity.',
    )
    expected_linear: Optional[ExpectedLinear2] = Field(
        None,
        alias='expectedLinear',
        description='The expected linear dimensions of a commodity.',
    )
    expected_cube: Optional[ExpectedCube2] = Field(
        None,
        alias='expectedCube',
        description='The expected cubic dimensions of a commodity.',
    )
    expected_density: Optional[ExpectedDensity2] = Field(
        None,
        alias='expectedDensity',
        description='The expected density of a commodity.',
    )
    expected_class_term: Optional[str] = Field(
        None,
        alias='expectedClassTerm',
        description='Identifies the expected freight class code that uses a classification system for commodities transported via LTL freight shipping; the lower the freight class, the lower the shipping price.',
    )
    expected_nmfc: Optional[constr(min_length=1)] = Field(
        None,
        alias='expectedNMFC',
        description='Identifies the expected National Motor Freight Classification code which is a designation used to group commodities.',
    )
    make: Optional[constr(min_length=1)] = Field(
        None, description='Identifies the make of a commodity.'
    )
    model: Optional[constr(min_length=1)] = Field(
        None, description='Identifies the model of a commodity.'
    )
    is_over_dimensional: Optional[bool] = Field(
        None,
        alias='isOverDimensional',
        description='Indicates if a commodity is over dimensional.',
    )
    serial_numbers: Optional[List[str]] = Field(None, alias='serialNumbers')
    year: Optional[confloat(le=8640000000000000.0)] = Field(
        None, description='Identifies the year of a commodity.'
    )
    hazmat_contact_name: Optional[str] = Field(
        None,
        alias='hazmatContactName',
        description='The Emergency Contact Name for hazardous materials.',
    )
    is_hazmat_placard_required: Optional[bool] = Field(
        None,
        alias='isHazmatPlacardRequired',
        description='Indicates if a Hazmat Placard is required on the trailer.',
    )
    hazmat_flashpoint_temp: Optional[HazmatFlashpointTemp2] = Field(
        None,
        alias='hazmatFlashpointTemp',
        description='Indicates at what temperature the hazardous material will catch fire.',
    )
    piece_type_term: Optional[str] = Field(
        None,
        alias='pieceTypeTerm',
        description='The pieces contained within the larger handling unit (e.g., boxes).',
    )
    handling_unit_term: Optional[str] = Field(
        None,
        alias='handlingUnitTerm',
        description='The unit that the carrier is responsible for moving (e.g., pallet, drum, crate).',
    )
    handling_unit_count: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='handlingUnitCount',
        description='Number of handling units expected.',
    )
    is_do_not_stack: Optional[bool] = Field(
        None,
        alias='isDoNotStack',
        description='Indicates that the commodity is not to be stacked when loaded.',
    )
    tag_terms: Optional[List[str]] = Field(None, alias='tagTerms')


class UnitTerm65(Enum):
    g = 'g'
    kg = 'kg'
    lbs = 'lbs'
    st = 'st'
    tons = 'tons'
    tonnes = 'tonnes'


class ExpectedWeight3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value amount for the expected weight of a commodity.'
    )
    unit_term: UnitTerm65 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected weight of a commodity.',
        title='ExpectedWeightCommodityUpdateUnitTerm',
    )


class UnitTerm66(Enum):
    usd = 'USD'
    cad = 'CAD'
    mxn = 'MXN'


class CommodityValue3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value amount for the commodity value.'
    )
    unit_term: UnitTerm66 = Field(
        ..., alias='unitTerm', description='The currency code for the commodity value.'
    )


class UnitTerm67(Enum):
    f = 'f'
    c = 'c'


class PreCoolTo3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The value amount for a specific temperature to set the refridgerated trailer to before arriving at the shipper.',
    )
    unit_term: UnitTerm67 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for a specific temperature to set the refridgerated trailer to before arriving at the shipper.',
        title='PreCoolToUnit',
    )


class MinimumTemperature3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The value amount for the minimum temperature the commodity must be kept at.',
    )
    unit_term: UnitTerm67 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the minimum temperature the commodity must be kept at.',
        title='MinimumTemperatureUnit',
    )


class MaximumTemperature3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The value amount for the maximum temperature a commodity can reach.',
    )
    unit_term: UnitTerm67 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the maximum temperature a commodity can reach.',
        title='MaximumTemperatureUnit',
    )


class TemperatureSettingTerm3Enum(Enum):
    continuous = 'continuous'
    cycle = 'cycle'


class TemperatureSettingTerm3(RootModel[Optional[TemperatureSettingTerm3Enum]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Optional[TemperatureSettingTerm3Enum] = Field(
        None,
        description='Indicates if the refrigerated trailer temperature control must run continuous or if it can cycle on and off.',
    )


class HazmatPackagingGroupTerm3Enum(Enum):
    i = 'I'
    ii = 'II'
    iii = 'III'


class HazmatPackagingGroupTerm3(RootModel[Optional[HazmatPackagingGroupTerm3Enum]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Optional[HazmatPackagingGroupTerm3Enum] = None


class UnitTerm70(Enum):
    ft = 'ft'
    in_ = 'in'
    cm = 'cm'
    m = 'm'


class Length5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected length of a commodity.'
    )
    unit_term: UnitTerm70 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected length of a commodity.',
        title='ExpectedLengthUnitTerm',
    )


class Width6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected width of a commodity.'
    )
    unit_term: UnitTerm70 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected width of a commodity.',
        title='ExpectedWidthUnitTerm',
    )


class Height6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected height of a commodity.'
    )
    unit_term: UnitTerm70 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected height of a commodity.',
        title='ExpectedHeightUnitTerm',
    )


class ExpectedDimensions3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    length: Optional[Length5] = Field(
        None,
        description='The expected length of a commodity.',
        title='ExpectedLengthCommodityUpdateRecord',
    )
    width: Optional[Width6] = Field(
        None,
        description='The expected width of a commodity.',
        title='ExpectedWidthCommodityUpdateRecord',
    )
    height: Optional[Height6] = Field(
        None,
        description='The expected height of a commodity.',
        title='ExpectedHeightCommodityUpdateRecord',
    )


class ExpectedLinear3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected linear dimensions of a commodity.'
    )
    unit_term: UnitTerm70 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected linear dimensions of a commodity, (e.g., feet, inches).',
        title='ExpectedLinearUnitTerm',
    )


class UnitTerm74(Enum):
    in3 = 'in3'
    ft3 = 'ft3'
    cm3 = 'cm3'
    m3 = 'm3'


class ExpectedCube3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        description='The value for the expected the cubic dimensions of a commodity.',
    )
    unit_term: UnitTerm74 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected cubic dimensions of a commodity.',
        title='ExpectedCubeUnitTerm',
    )


class UnitTerm75(Enum):
    lb_in3 = 'lb/in3'
    lb_ft3 = 'lb/ft3'
    cwt_ft3 = 'cwt/ft3'
    kg_cm3 = 'kg/cm3'
    kg_m3 = 'kg/m3'


class ExpectedDensity3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the expected density of a commodity.'
    )
    unit_term: UnitTerm75 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the expected density of a commodity.',
        title='ExpectedDensityUnitTerm',
    )


class UnitTerm76(Enum):
    f = 'f'
    c = 'c'


class HazmatFlashpointTemp3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The value of the temperature the hazardous material will catch fire.',
    )
    unit_term: UnitTerm76 = Field(
        ..., alias='unitTerm', description='The unit of measurement of the temperature.'
    )


class OrdersIdentifierValuecommoditiesCommodityIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Optional[constr(min_length=1)] = Field(
        None,
        description='The internally defined unique identifier of commodities to be shipped for an order.',
    )
    description: constr(min_length=1) = Field(
        ..., description='The description of commodities to be shipped for an order.'
    )
    expected_weight: ExpectedWeight3 = Field(
        ...,
        alias='expectedWeight',
        description='The value amount for the expected weight of a commodity.',
        title='ExpectedWeightCommodityUpdateRecord',
    )
    expected_pieces: Optional[int] = Field(
        None,
        alias='expectedPieces',
        description='The expected number of pieces for a commodity.',
    )
    number: Optional[int] = Field(
        None, description='The number of pieces of a commodity.'
    )
    packaging_unit: Optional[str] = Field(
        None,
        alias='packagingUnit',
        description='The unit of measurement for the number of pieces of a commodity (e.g., pallet, drum, crate).',
    )
    load_on_term: Optional[str] = Field(
        None,
        alias='loadOnTerm',
        description='Identifies how the freight should be loaded on the trailer.',
    )
    is_hazmat: Optional[bool] = Field(
        None,
        alias='isHazmat',
        description='Identifies if there are hazardous materials for a commodity.',
    )
    is_temp_controlled: Optional[bool] = Field(
        None,
        alias='isTempControlled',
        description='Identifies if a commodity requires its temperature to be controlled.',
    )
    stcc_code: Optional[constr(min_length=1)] = Field(
        None,
        alias='stccCode',
        description='The Standard Transportation Commodity Code is a publication containing specific product information used on shipping documents.',
    )
    stop_codes: Optional[List[str]] = Field(None, alias='stopCodes')
    commodity_value: Optional[CommodityValue3] = Field(
        None,
        alias='commodityValue',
        description='Identifies the total value of an individual commodity in case a claim needs to be filed for it.',
    )
    associated_stops: Optional[List[AssociatedStop]] = Field(
        None,
        alias='associatedStops',
        description='Identifies if a commodity is associated with a particular stop.',
    )
    is_top_loadable: Optional[bool] = Field(
        None,
        alias='isTopLoadable',
        description='Identifies if a commodity can be loaded on top of other commodities.',
    )
    is_bottom_loadable: Optional[bool] = Field(
        None,
        alias='isBottomLoadable',
        description='Identifies if a commodity can be loaded on the bottom of other commodities.',
    )
    pre_cool_to: Optional[PreCoolTo3] = Field(
        None,
        alias='preCoolTo',
        description='Identifies a specific temperature to set the refridgerated trailer to before arriving at the shipper.',
    )
    minimum_temperature: Optional[MinimumTemperature3] = Field(
        None,
        alias='minimumTemperature',
        description='Identifies the minimum temperature the commodity must be kept at.',
    )
    maximum_temperature: Optional[MaximumTemperature3] = Field(
        None,
        alias='maximumTemperature',
        description='Identifies the maximum temperature a commodity can reach.',
    )
    temperature_setting_term: Optional[TemperatureSettingTerm3] = Field(
        None,
        alias='temperatureSettingTerm',
        description='Indicates if the refrigerated trailer temperature control must run continuous or if it can cycle on and off.',
    )
    hazmat_class_term: Optional[str] = Field(
        None,
        alias='hazmatClassTerm',
        description='Identifies which hazardous materials class a commodity belongs to.',
    )
    hazmat_packaging_group_term: Optional[HazmatPackagingGroupTerm3] = Field(
        None, alias='hazmatPackagingGroupTerm'
    )
    hazmat_united_nations_number: Optional[constr(min_length=1)] = Field(
        None,
        alias='hazmatUnitedNationsNumber',
        description='A four digit number that identify dangerous goods or hazardous substances.',
    )
    hazmat_phone_number: Optional[
        constr(
            pattern=r'^((\([\d]{3}\)\s[\d]{3}-[\d]{4})|([\d]{10})|(\+[1-9][\d]{1,14}))$'
        )
    ] = Field(
        None,
        alias='hazmatPhoneNumber',
        description='The emergency response telephone number forhazardous materials.',
    )
    expected_dimensions: Optional[ExpectedDimensions3] = Field(
        None,
        alias='expectedDimensions',
        description='The expected dimensions of a commodity.',
    )
    expected_linear: Optional[ExpectedLinear3] = Field(
        None,
        alias='expectedLinear',
        description='The expected linear dimensions of a commodity.',
    )
    expected_cube: Optional[ExpectedCube3] = Field(
        None,
        alias='expectedCube',
        description='The expected cubic dimensions of a commodity.',
    )
    expected_density: Optional[ExpectedDensity3] = Field(
        None,
        alias='expectedDensity',
        description='The expected density of a commodity.',
    )
    expected_class_term: Optional[str] = Field(
        None,
        alias='expectedClassTerm',
        description='Identifies the expected freight class code that uses a classification system for commodities transported via LTL freight shipping; the lower the freight class, the lower the shipping price.',
    )
    expected_nmfc: Optional[constr(min_length=1)] = Field(
        None,
        alias='expectedNMFC',
        description='Identifies the expected National Motor Freight Classification code which is a designation used to group commodities.',
    )
    make: Optional[constr(min_length=1)] = Field(
        None, description='Identifies the make of a commodity.'
    )
    model: Optional[constr(min_length=1)] = Field(
        None, description='Identifies the model of a commodity.'
    )
    is_over_dimensional: Optional[bool] = Field(
        None,
        alias='isOverDimensional',
        description='Indicates if a commodity is over dimensional.',
    )
    serial_numbers: Optional[List[str]] = Field(None, alias='serialNumbers')
    year: Optional[confloat(le=8640000000000000.0)] = Field(
        None, description='Identifies the year of a commodity.'
    )
    hazmat_contact_name: Optional[str] = Field(
        None,
        alias='hazmatContactName',
        description='The Emergency Contact Name for hazardous materials.',
    )
    is_hazmat_placard_required: Optional[bool] = Field(
        None,
        alias='isHazmatPlacardRequired',
        description='Indicates if a Hazmat Placard is required on the trailer.',
    )
    hazmat_flashpoint_temp: Optional[HazmatFlashpointTemp3] = Field(
        None,
        alias='hazmatFlashpointTemp',
        description='Indicates at what temperature the hazardous material will catch fire.',
    )
    piece_type_term: Optional[str] = Field(
        None,
        alias='pieceTypeTerm',
        description='The pieces contained within the larger handling unit (e.g., boxes).',
    )
    handling_unit_term: Optional[str] = Field(
        None,
        alias='handlingUnitTerm',
        description='The unit that the carrier is responsible for moving (e.g., pallet, drum, crate).',
    )
    handling_unit_count: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='handlingUnitCount',
        description='Number of handling units expected.',
    )
    is_do_not_stack: Optional[bool] = Field(
        None,
        alias='isDoNotStack',
        description='Indicates that the commodity is not to be stacked when loaded.',
    )
    tag_terms: Optional[List[str]] = Field(None, alias='tagTerms')


class OrdersIdentifierValuerateLineItemsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ..., description='Identifies the rate line item value for an order record.'
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='Identifies the rate line item code for an order record.',
    )
    rate_per_unit: RatePerUnit = Field(
        ...,
        alias='ratePerUnit',
        description='The amount of the rate per unit calculation.',
        title='RateLineMoneyCreatedRecord',
    )
    units: confloat(le=8640000000000000.0) = Field(
        ..., description='The number of units for the rate per unit calculation.'
    )


class OrdersIdentifierValuerateLineItemsRateLineItemIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Optional[constr(min_length=1)] = Field(
        None, description='Identifies the rate line item value for an order record.'
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='Identifies the rate line item code for an order record.',
    )
    rate_per_unit: RatePerUnit = Field(
        ...,
        alias='ratePerUnit',
        description='The amount of the rate per unit calculation.',
        title='RateLineMoneyUpdatedRecord',
    )
    units: confloat(le=8640000000000000.0) = Field(
        ..., description='The number of units for the rate per unit calculation.'
    )


class OrdersIdentifierValuereferencesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: constr(min_length=1) = Field(
        ..., description='The value amount of a reference number.'
    )
    qualifier_term: constr(min_length=1) = Field(
        ...,
        alias='qualifierTerm',
        description='Identifies the type of reference number (e.g., BOL, PO, shipment id).',
    )


class OrdersIdentifierValuereferencesReferenceIdPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: constr(min_length=1) = Field(
        ..., description='The value amount of a reference number.'
    )
    qualifier_term: constr(min_length=1) = Field(
        ...,
        alias='qualifierTerm',
        description='Identifies the type of reference number (e.g., BOL, PO, shipment id).',
    )


class EntityType(Enum):
    customer = 'customer'
    carrier = 'carrier'
    facility = 'facility'
    driver = 'driver'


class Identifiers4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally-defined UUID of the primary entity.'
    )
    code: Optional[str] = Field(
        None,
        description='The externally-defined code of the primary entity that is searchable on the TMS.',
    )


class PrimaryEntity(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    entity_type: EntityType = Field(
        ...,
        alias='entityType',
        description='This is establishing the type of entity of the primary entity (e.g. Customer, Carrier, or Facility).',
    )
    identifiers: Identifiers4 = Field(
        ...,
        description='The identifier object to pass in either an internally-defined ID or the externally-defined code for the primary entity.',
        title='RelationshipIdentifiersRecord',
    )


class Identifiers5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='An internally-defined UUID referencing the customer.'
    )
    code: Optional[str] = Field(
        None,
        description='The externally-defined code exposed on the UI that can be searched throughout the TMS.',
    )


class CustomerCustomerRelationship(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally-defined UUID of the customer-customer relationship.',
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this relationship Code should be removed.',
    )
    identifiers: Optional[Identifiers5] = Field(
        None,
        description='The identifier object to pass in either an internally-defined ID or the externally-defined code for establishing a relationship to another customer record.',
    )
    relationship_type: Optional[constr(min_length=1)] = Field(
        None,
        alias='relationshipType',
        description='The type of relationship between the customers.',
    )
    note: Optional[str] = Field(None, description='Any notes about the relationship.')
    is_active: Optional[bool] = Field(
        None,
        alias='isActive',
        description='Indicates if the relationship is active or inactive.',
    )


class Identifiers6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='An internally-defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None,
        description='The externally-defined code exposed on the UI that can be searched throughout the TMS.',
    )


class CustomersCustomer(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='An internally-defined UUID of the customers customer.'
    )
    code: Optional[str] = Field(
        None,
        description='The uniqueID exposed on the UI that can be searched throughout the TMS.',
    )


class ProvidedCoordinates(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    latitude: confloat(ge=-90.0, le=90.0) = Field(
        ..., description='The latitude coordinate.'
    )
    longitude: confloat(ge=-180.0, le=180.0) = Field(
        ..., description='The longitude coordinate.'
    )


class StopTypeEdiCode(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='An internally-defined UUID of the Stop Type EDI Code.'
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this Stop Type EDI Code should be removed.',
    )
    stop_type_term: Optional[str] = Field(
        None,
        alias='stopTypeTerm',
        description='The type of stop (e.g., pickup, delivery).',
    )
    qualifier: Optional[str] = Field(
        None,
        description='The identification code that provides more specific framing for a stop type term. This may be used to describe the relationship and what the code value means.',
    )
    edi_code: Optional[str] = Field(
        None,
        alias='ediCode',
        description="The EDI code that identifies a party or other code. This creates a unique shared definition between a client's system and MasterMind to identify common facilities this Customer record uses.",
    )


class LiveDropTypeTermEnum(Enum):
    live = 'live'
    drop_empty_wait = 'dropEmptyWait'
    drop_loaded_wait = 'dropLoadedWait'
    bobtail_hook_empty = 'bobtailHookEmpty'
    bobtail_hook_loaded = 'bobtailHookLoaded'
    drop_empty_hook_loaded = 'dropEmptyHookLoaded'
    drop_loaded_hook_empty = 'dropLoadedHookEmpty'
    drop_loaded_bobtail = 'dropLoadedBobtail'
    drop_empty_bobtail = 'dropEmptyBobtail'
    drop_avail = 'dropAvail'
    drop_only = 'dropOnly'


class LiveDropTypeTerm(RootModel[Optional[LiveDropTypeTermEnum]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Optional[LiveDropTypeTermEnum] = Field(
        None,
        description='Indicates what type of Stop Event is available at the Facility.',
    )


class UnitTerm77(Enum):
    hours = 'hours'
    days = 'days'


class PickupAllowableFreeTime(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: float = Field(..., description='The amount of time free time for pickup.')
    unit_term: UnitTerm77 = Field(
        ..., alias='unitTerm', description='The measurement time.'
    )


class DeliveryAllowableFreeTime(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: float = Field(..., description='The amount of time free time for delivery.')
    unit_term: UnitTerm77 = Field(
        ..., alias='unitTerm', description='The measurement time.'
    )


class CustomerFacilityRelationship(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally-defined UUID of the customer-facility relationship.',
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this relationship should be removed.',
    )
    identifiers: Optional[Identifiers6] = Field(
        None,
        description='The identifier object to pass in either the ID or the code for establishing a relationship to a facility record.',
    )
    customers_customer: Optional[CustomersCustomer] = Field(
        None, alias='customersCustomer', description="The customer's customer."
    )
    scheduling_system_type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='schedulingSystemTypeTerm',
        description='The type of scheduling system that a Facility uses.',
    )
    provided_coordinates: Optional[ProvidedCoordinates] = Field(
        None,
        alias='providedCoordinates',
        description='The coordinates of the customer facility relationship.',
    )
    scheduling_url: Optional[str] = Field(
        None, alias='schedulingURL', description='The scheduling system website.'
    )
    is_pickup: Optional[bool] = Field(
        None,
        alias='isPickup',
        description='Indicates that the facility allows pick-ups.',
    )
    pickup_codes: Optional[List[str]] = Field(
        None,
        alias='pickupCodes',
        description='The pickup codes that coincide with the scheduling system.',
    )
    is_delivery: Optional[bool] = Field(
        None,
        alias='isDelivery',
        description='Indicates that the facility allows deliveries.',
    )
    delivery_codes: Optional[List[str]] = Field(
        None,
        alias='deliveryCodes',
        description='The delivery codes that coincide with the scheduling system.',
    )
    stop_type_edi_codes: Optional[List[StopTypeEdiCode]] = Field(
        None,
        alias='stopTypeEdiCodes',
        description='Identifies type of stop and the relationship between the customer and a facility record.',
    )
    live_drop_type_term: Optional[LiveDropTypeTerm] = Field(
        None,
        alias='liveDropTypeTerm',
        description='Indicates what type of Stop Event is available at the Facility.',
    )
    special_requirements_and_equipment_type_term: Optional[constr(min_length=1)] = (
        Field(
            None,
            alias='specialRequirementsAndEquipmentTypeTerm',
            description='Indicates if the facility handles any special equipment or requirements.',
        )
    )
    pickup_allowable_free_time: Optional[PickupAllowableFreeTime] = Field(
        None,
        alias='pickupAllowableFreeTime',
        description='The amount of time free time the facility allows for pickups.',
    )
    delivery_allowable_free_time: Optional[DeliveryAllowableFreeTime] = Field(
        None,
        alias='deliveryAllowableFreeTime',
        description='The amount of time free time the facility allows for delivery.',
    )


class Identifiers7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='An internally-defined UUID for a carrier record.'
    )
    code: Optional[str] = Field(
        None, description='The externally-defined code for a carrier record.'
    )


class CarrierCarrierRelationship(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally-defined UUID of the carrier to carrier relationship.',
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this relationship should be removed.',
    )
    identifiers: Optional[Identifiers7] = Field(
        None,
        description='The identifier object to pass in either an internally-defined ID or the externally-defined code for establishing a relationship to another carrier record.',
    )
    relationship_type: Optional[constr(min_length=1)] = Field(
        None,
        alias='relationshipType',
        description='Identifies the type of relationship between the carriers.',
    )
    note: Optional[str] = Field(None, description='Any notes about the relationship.')
    is_active: Optional[bool] = Field(
        None,
        alias='isActive',
        description='Indicates if the relationship is active or not.',
    )


class Identifiers8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the driver.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the driver.'
    )


class Address9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city: constr(min_length=1) = Field(..., description='The city of the address.')
    state: constr(min_length=2, max_length=3) = Field(
        ..., description='The state of the address (e.g., AZ, AR). ISO 3166-2.'
    )
    country: constr(min_length=3, max_length=3) = Field(
        ...,
        description='The country of the address (e.g., CAN, MEX, USA). ISO 3166-1 Alpha-3.',
    )


class Start(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    date: Optional[date] = Field(
        None,
        description='The planned start date of the relationship. Format YYYY-MM-DD.',
    )
    time: Optional[conint(ge=1, le=2147483647)] = Field(
        None,
        description='The planned start time of the relationship. Format is offset from midnight (in milliseconds).',
    )
    address: Optional[Address9] = Field(
        None, description='The address associated to the start of the relationship.'
    )


class End(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    date: Optional[date] = Field(
        None, description='The planned end date of the relationship. Format YYYY-MM-DD.'
    )
    time: Optional[conint(ge=1, le=2147483647)] = Field(
        None,
        description='The planned end time of the relationship. Format is offset from midnight (in milliseconds).',
    )
    address: Optional[Address9] = Field(
        None, description='The address associated to the end of the relationship.'
    )
    reason_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='reasonTerm',
        description='The planned end reason of the relationship (e.g., Pairing With A New Teammate, Changing To A Solo).',
    )


class Planned(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    start: Optional[Start] = Field(
        None, description='The planned start of the relationship.'
    )
    end: Optional[End] = Field(None, description='The planned end of the relationship.')


class DriverDriverRelationship(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined UUID referencing the driver to driver relationship.',
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this relationship should be removed.',
    )
    identifiers: Identifiers8 = Field(
        ...,
        description='The identifiers that establish a relationship to another driver record.',
        title='DriverDriverIdentifiersRecord',
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='Identifies the type of relationship between the drivers (e.g., Partner, Trainer). Data Dictionary Term.',
    )
    status_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='statusTerm',
        description='Identifies the status of relationship between the drivers (e.g., Inactive, Planned). Data Dictionary Term.',
    )
    planned: Optional[Planned] = Field(
        None,
        description='The collection of fields related to the start and end of the relationship.',
    )
    notes: Optional[str] = Field(
        None, description='The notes associated to the relationship.'
    )


class RelationshipsPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    primary_entity: PrimaryEntity = Field(
        ...,
        alias='primaryEntity',
        description='The primary entity where the relationships are being established. Once relationships are established they will appear in both records.',
        title='PrimaryEntityRecord',
    )
    customer_customer_relationships: Optional[List[CustomerCustomerRelationship]] = (
        Field(
            None,
            alias='customerCustomerRelationships',
            description='A collection of customer relationships with a customer.',
        )
    )
    customer_facility_relationships: Optional[List[CustomerFacilityRelationship]] = (
        Field(
            None,
            alias='customerFacilityRelationships',
            description='A collection of facility relationships with a customer.',
        )
    )
    carrier_carrier_relationships: Optional[List[CarrierCarrierRelationship]] = Field(
        None,
        alias='carrierCarrierRelationships',
        description='A collection of carrier relationships with another carrier.',
    )
    driver_driver_relationships: Optional[List[DriverDriverRelationship]] = Field(
        None,
        alias='driverDriverRelationships',
        description='The collection of driver relationships with another driver.',
    )


class Route9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID for a route record.'
    )
    number: Optional[str] = Field(
        None, description='The internally defined unique number for a route record.'
    )


class Carrier4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID for a carrier record.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code for a carrier record.'
    )


class Identifiers9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    route: Route9 = Field(..., description='The route record.', title='RouteRecord')
    carrier: Carrier4 = Field(
        ...,
        description='The carrier record associated with this route record.',
        title='CarrierRecord',
    )


class TypeTerm6(Enum):
    other = 'other'
    tonu = 'tonu'
    carrier = 'carrier'


class RouteVendorReference(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if an existing reference should be deleted.',
    )
    id: Optional[str] = Field(
        None,
        description='The internally-defined unique identifier for a route reference record.',
    )
    qualifier_term: Optional[str] = Field(
        None,
        alias='qualifierTerm',
        description='The type of reference number (e.g., Carrier Pro #, Waybill #, PU Ref #, etc.)',
    )
    value: Optional[str] = Field(None, description='The value of a reference number.')


class AssociatedRep2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID of the associated rep.'
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates whether the existing associated rep should be removed from the route-vendor.',
    )
    employee_code: Optional[str] = Field(
        None,
        alias='employeeCode',
        description='The externally defined unique identifier for an employee record.',
    )
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The type of associated rep on the route-vendor (e.g. Carrier Manager, Fleet Manager, etc).',
    )
    is_main: Optional[bool] = Field(
        None,
        alias='isMain',
        description='Indicates whether the associated rep is the main rep for the route-vendor.',
    )


class CostPerUnit(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    amount: float = Field(
        ..., description='The amount for a cost line item record calculation.'
    )
    currency_code_term: str = Field(
        ...,
        alias='currencyCodeTerm',
        description='The currency code for the cost line item record calculation.',
    )


class Stop3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID for a stop record.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code for a stop record.'
    )


class Driver5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID of the driver record.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code of the driver record.'
    )


class CostLineItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID for a cost line item record.'
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this cost line item should be destroyed.',
    )
    cost_type_term: Optional[str] = Field(
        None,
        alias='costTypeTerm',
        description='Identifies the type of cost line item record (e.g., flat rate, linehaul, scale ticket, tolls).',
    )
    cost_per_unit: Optional[CostPerUnit] = Field(
        None,
        alias='costPerUnit',
        description='Identifies the amount and currency for a cost line item record.',
    )
    units: Optional[float] = Field(
        None,
        description='The number of units for the cost line item record calculation.',
    )
    stop: Optional[Stop3] = Field(
        None,
        description='Identifies the stop record associated with this cost line item record.',
    )
    driver: Optional[Driver5] = Field(
        None,
        description='Identifies the driver record associated with this cost line item record.',
    )


class RouteVendorPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    identifiers: Identifiers9 = Field(
        ..., description='Identifiers of route vendor.', title='IdentifierRecord'
    )
    type_term: Optional[TypeTerm6] = Field(
        None,
        alias='typeTerm',
        description='The type of route vendor on the route (Other, TONU).',
    )
    executing_division_term: Optional[str] = Field(
        None,
        alias='executingDivisionTerm',
        description='The division that represents the route vendor.',
    )
    is_financial_disable: Optional[bool] = Field(
        None,
        alias='isFinancialDisable',
        description='Indicates if invoicing or vouchering should be disabled for the route vendor on the route. Typically used if an external system is being used for Accounts Payable and Receivables.',
    )
    route_vendor_references: Optional[List[RouteVendorReference]] = Field(
        None,
        alias='routeVendorReferences',
        description='A list of reference numbers associated to a route vendor on a route.',
    )
    associated_reps: Optional[List[AssociatedRep2]] = Field(
        None,
        alias='associatedReps',
        description='A collection of associated reps with the route-vendor on the route.',
    )
    notes: Optional[str] = Field(
        None,
        description='Any vendor notes associated with the additional vendor on the route.',
    )
    cost_line_items: Optional[List[CostLineItem]] = Field(
        None,
        alias='costLineItems',
        description='An itemized list of expenditures the carrier is billing for on a route record.',
    )


class Identifiers10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    route: Route9 = Field(..., description='The route record.', title='CreateRoute')
    carrier: Carrier4 = Field(
        ...,
        description='The carrier record associated with this route record.',
        title='CreateCarrier',
    )


class TypeTerm7(Enum):
    other = 'other'
    tonu = 'tonu'


class RouteVendorReference1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    qualifier_term: str = Field(
        ...,
        alias='qualifierTerm',
        description='The type of reference number (e.g., Carrier Pro #, Waybill #, PU Ref #, etc.)',
    )
    value: constr(min_length=1) = Field(
        ..., description='The value of a reference number.'
    )


class AssociatedRep3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    employee_code: constr(min_length=1) = Field(
        ...,
        alias='employeeCode',
        description='The externally defined unique identifier for an employee record.',
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of associated rep on the route-vendor (e.g. Carrier Manager, Fleet Manager, etc).',
    )
    is_main: bool = Field(
        ...,
        alias='isMain',
        description='Indicates whether the associated rep is the main rep for the route-vendor.',
    )


class CostLineItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    cost_type_term: str = Field(
        ...,
        alias='costTypeTerm',
        description='Identifies the type of cost line item record (e.g., flat rate, linehaul, scale ticket, tolls).',
    )
    cost_per_unit: CostPerUnit = Field(
        ...,
        alias='costPerUnit',
        description='Identifies the amount and currency for a cost line item record.',
        title='CreateCostPerUnit',
    )
    units: float = Field(
        ...,
        description='The number of units for the cost line item record calculation.',
    )
    stop: Optional[Stop3] = Field(
        None,
        description='Identifies the stop record associated with this cost line item record.',
    )
    driver: Optional[Driver5] = Field(
        None,
        description='Identifies the driver record associated with this cost line item record.',
    )


class RouteVendorPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    identifiers: Identifiers10 = Field(
        ..., description='Identifiers of route vendor.', title='CreateIdentifier'
    )
    type_term: TypeTerm7 = Field(
        ...,
        alias='typeTerm',
        description='The type of route vendor on the route (Other, TONU).',
    )
    booking_source_type_term: Optional[str] = Field(
        None,
        alias='bookingSourceTypeTerm',
        description='The internal or external system that was used to add the route vendor to the route.',
    )
    executing_division_term: Optional[str] = Field(
        None,
        alias='executingDivisionTerm',
        description='The division that represents the route vendor.',
    )
    is_financial_disable: bool = Field(
        ...,
        alias='isFinancialDisable',
        description='Indicates if invoicing or vouchering should be disabled for the route vendor on the route. Typically used if an external system is being used for Accounts Payable and Receivables.',
    )
    route_vendor_references: Optional[List[RouteVendorReference1]] = Field(
        None,
        alias='routeVendorReferences',
        description='A list of reference numbers associated to a route vendor on a route.',
    )
    associated_reps: Optional[List[AssociatedRep3]] = Field(
        None,
        alias='associatedReps',
        description='A collection of associated reps with the route-vendor on the route.',
    )
    notes: Optional[str] = Field(
        None,
        description='Any vendor notes associated with the additional vendor on the route.',
    )
    cost_line_items: Optional[List[CostLineItem1]] = Field(
        None,
        alias='costLineItems',
        description='An itemized list of expenditures the carrier is billing for on a route record.',
    )


class Identifiers11(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    load_id: constr(min_length=1) = Field(
        ...,
        alias='loadId',
        description='The internally defined unique identifier for a load.',
    )


class UnitTerm79(Enum):
    ft = 'ft'
    in_ = 'in'
    m = 'm'
    km = 'km'
    mi = 'mi'


class MinimumLength3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The value for the minimum required length of equipment.'
    )
    unit_term: UnitTerm79 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the minimum required length of equipment.',
        title='MinLengthUnitTerm',
    )


class Width7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='The minimum required width of equipment.'
    )
    unit_term: UnitTerm79 = Field(
        ...,
        alias='unitTerm',
        description='The value for the required width of equipment.',
        title='WidthUnitTerm',
    )


class Height7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=0.0, le=8640000000000000.0)
    unit_term: UnitTerm79 = Field(
        ...,
        alias='unitTerm',
        description='The unit of measurement for the required height of equipment.',
        title='HeightUnitTerm',
    )


class Dimensions3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    minimum_length: Optional[MinimumLength3] = Field(
        None,
        alias='minimumLength',
        description='The minimum required length of equipment.',
    )
    width: Optional[Width7] = Field(
        None,
        description='The minimum required width of equipment.',
        title='WidthRecord',
    )
    height: Optional[Height7] = Field(
        None,
        description='The minimum required height of equipment.',
        title='HeightRecord',
    )


class Equipment3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    trailer_type_terms: Optional[List[str]] = Field(
        None, alias='trailerTypeTerms', min_length=1
    )
    dimensions: Optional[Dimensions3] = Field(
        None, description='The dimensional requirements for equipment.'
    )


class MaxCost(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    currency_code_term: constr(min_length=1) = Field(
        ..., alias='currencyCodeTerm', description='This represents currency code.'
    )
    amount: float = Field(..., description='This represents amount.')


class OverMaxCost(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    currency_code_term: constr(min_length=1) = Field(
        ..., alias='currencyCodeTerm', description='This represents currency code.'
    )
    amount: float = Field(..., description='This represents amount.')


class CargoInsurance2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    currency_code_term: constr(min_length=1) = Field(
        ..., alias='currencyCodeTerm', description='This represents currency code.'
    )
    amount: float = Field(..., description='This represents amount.')


class Facility34(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility35(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class CityState13(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city: constr(min_length=1) = Field(..., description='The city of the address.')
    state: constr(min_length=2, max_length=3) = Field(
        ..., description='The state of the address (e.g., AZ, AR). ISO 3166-2.'
    )
    county: Optional[str] = Field(None, description='The county of the address.')
    country: constr(min_length=3, max_length=3) = Field(
        ...,
        description='The country of the address (e.g., CAN, MEX, USA). ISO 3166-1 Alpha-3.',
    )


class Location16(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility34, Facility35]] = Field(
        ..., description='The location of the facility.'
    )
    city_state: Optional[CityState13] = Field(
        None, alias='cityState', description='The location of the city and state.'
    )
    coordinates: Optional[Coordinates8] = Field(
        None, description='The coordinates of the location.'
    )
    facility_code: Optional[str] = Field(
        None,
        alias='facilityCode',
        description='The externally defined unique identifier for a facility record.',
    )


class Facility36(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility37(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class Location17(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility36, Facility37]] = Field(
        None, description='The location of the facility.'
    )
    city_state: Optional[CityState13] = Field(
        ..., alias='cityState', description='The location of the city and state.'
    )
    coordinates: Optional[Coordinates8] = Field(
        None, description='The coordinates of the location.'
    )
    facility_code: Optional[str] = Field(
        None,
        alias='facilityCode',
        description='The externally defined unique identifier for a facility record.',
    )


class Facility38(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility39(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class Location18(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility38, Facility39]] = Field(
        None, description='The location of the facility.'
    )
    city_state: Optional[CityState13] = Field(
        None, alias='cityState', description='The location of the city and state.'
    )
    coordinates: Optional[Coordinates8] = Field(
        ..., description='The coordinates of the location.'
    )
    facility_code: Optional[str] = Field(
        None,
        alias='facilityCode',
        description='The externally defined unique identifier for a facility record.',
    )


class Facility40(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility41(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class Location19(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility40, Facility41]] = Field(
        None, description='The location of the facility.'
    )
    city_state: Optional[CityState13] = Field(
        None, alias='cityState', description='The location of the city and state.'
    )
    coordinates: Optional[Coordinates8] = Field(
        None, description='The coordinates of the location.'
    )
    facility_code: str = Field(
        ...,
        alias='facilityCode',
        description='The externally defined unique identifier for a facility record.',
    )


class Reference4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The externally defined unique identifier for a reference record.',
    )
    value: str = Field(..., description='The value amount of a reference number.')
    qualifier_term: str = Field(
        ...,
        alias='qualifierTerm',
        description='Identifies the type of reference number (e.g., BOL, PO, shipment id).',
    )


class Stop5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined unique identifier for a stop record.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined unique identifier for a stop record.'
    )
    sequence_number: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ...,
        alias='sequenceNumber',
        description='The externally defined unique identifier for a stop record.',
    )
    type_term: constr(min_length=1) = Field(
        ..., alias='typeTerm', description='The type of stop (e.g., pickup, delivery).'
    )
    available_start_date_time: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ...,
        alias='availableStartDateTime',
        description='The earliest available start date and time associated with a stop. Unix timestamp (in milliseconds).',
    )
    available_end_date_time: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ...,
        alias='availableEndDateTime',
        description='The latest available start date and time associated with a stop. Unix timestamp (in milliseconds).',
    )
    schedule_type_term: ScheduleTypeTerm4 = Field(
        ...,
        alias='scheduleTypeTerm',
        description='The type of scheduling for the stop location (e.g., appointment, open).',
        title='ScheduleTypeTerm',
    )
    live_drop_term: LiveDropTerm = Field(
        ...,
        alias='liveDropTerm',
        description='Indicates the planned activity at a stop (e.g., live, drop, hook).',
        title='LiveDropTerm',
    )
    work_term: WorkTerm = Field(
        ...,
        alias='workTerm',
        description='Indicates the key services at a stop (e.g., no touch, driver assist, lumper).',
        title='WorkTerm',
    )
    unload_from_term: Optional[str] = Field(
        None,
        alias='unloadFromTerm',
        description='Indicates how the stop will unload the trailer.',
    )
    load_from_term: Optional[str] = Field(
        None,
        alias='loadFromTerm',
        description='Indicates how the stop will load the trailer.',
    )
    notes: Optional[str] = Field(
        None, description='Indicates how the stop will load the trailer.'
    )
    requested_date: Optional[str] = Field(
        None, alias='requestedDate', description='The requested date of a stop.'
    )
    appointment_start_date_time: Optional[confloat(ge=1.0, le=8640000000000000.0)] = (
        Field(
            None,
            alias='appointmentStartDateTime',
            description='The earliest appointment start date and time associated with a stop.  Unix timestamp (in milliseconds).',
        )
    )
    appointment_end_date_time: Optional[confloat(ge=1.0, le=8640000000000000.0)] = (
        Field(
            None,
            alias='appointmentEndDateTime',
            description='The latest appointment start date and time associated with a stop.  Unix timestamp (in milliseconds).',
        )
    )
    appointment_requested_with: Optional[str] = Field(
        None,
        alias='appointmentRequestedWith',
        description='Identifies with whom the appointment was requested with.',
    )
    appointment_requested_confirm_with: Optional[str] = Field(
        None,
        alias='appointmentRequestedConfirmWith',
        description='Identifies with whom the appointment was confirmed with.',
    )
    is_confirmed_appointment: Optional[bool] = Field(
        None,
        alias='isConfirmedAppointment',
        description='Indicates if the appointment as been confirmed.',
    )
    total_pallet_count: Optional[float] = Field(
        None,
        alias='totalPalletCount',
        description='The number of the total number of pallets for a stop record.',
    )
    seal_number: Optional[float] = Field(
        None,
        alias='sealNumber',
        description='The seal number to lock the trailer for a stop record.',
    )
    bol_number: Optional[str] = Field(
        None,
        alias='bolNumber',
        description='The bill of lading number for a stop record.',
    )
    is_order_stop: Optional[bool] = Field(
        None,
        alias='isOrderStop',
        description='Indicates of an associated stop on the route is also an order stop, meaning it is the origin or destination of the order.',
    )
    requirement_terms: Optional[List[str]] = Field(
        None, alias='requirementTerms', min_length=1
    )
    location: Union[Location16, Location17, Location18, Location19] = Field(
        ...,
        description='Identifies the location for a stop record.',
        title='StopPutLocationRecord',
    )
    references: Optional[List[Reference4]] = Field(
        None, description='A list of reference numbers associated to a stop.'
    )


class Reference5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined unique identifier for a reference record.',
    )
    value: constr(min_length=1) = Field(
        ..., description='The value amount of a reference number.'
    )
    qualifier_term: constr(min_length=1) = Field(
        ...,
        alias='qualifierTerm',
        description='Identifies the type of reference number (e.g., Quote #, Trip #, Reservation #).',
    )


class Route11(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined unique identifier for a route record.'
    )
    number: Optional[constr(min_length=1)] = Field(
        None, description='The externally defined unique identifier for a route record.'
    )
    segment_code: Optional[constr(min_length=1)] = Field(
        None,
        alias='segmentCode',
        description='A Segment Code is a way to create further segmentation of freight that cannot be accomplished by way of Division, Project, or Dedicated Fleet Program.',
    )
    sequence_number: float = Field(
        ...,
        alias='sequenceNumber',
        description='The particular order in which related routes follow each other.',
    )
    activation_status_term: str = Field(
        ...,
        alias='activationStatusTerm',
        description='The activation status for a route record.',
    )
    division_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='divisionTerm',
        description='The division type of the client (e.g., asset, brokerage).',
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='Identifies the mode of transport for a route record (e.g., OTR, IMDL, drayage, air).',
    )
    mode_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='modeTerm',
        description='The type of transportation required for this route (e.g., truck, rail, air).',
    )
    size_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='sizeTerm',
        description='The truckload size of a route record (e.g., FTL, LTL, partial).',
    )
    is_hot_route: Optional[bool] = Field(
        None,
        alias='isHotRoute',
        description='Identifies if the route needs to be transported immediately.',
    )
    tarp_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='tarpTerm',
        description='The type of tarps required for the load (e.g., lumber, steel).',
    )
    tarp_count: Optional[float] = Field(
        None,
        alias='tarpCount',
        description='The number of tarps required for the load.',
    )
    bracing_terms: Optional[List[str]] = Field(
        None,
        alias='bracingTerms',
        description='The type of bracing required for the load.',
    )
    bracing_count: Optional[float] = Field(
        None,
        alias='bracingCount',
        description='The number of bracing required for the load.',
    )
    additional_division_terms: Optional[List[str]] = Field(
        None, alias='additionalDivisionTerms'
    )
    equipment: Optional[Equipment3] = Field(
        None, description='The type of equipment needed.'
    )
    max_cost: Optional[MaxCost] = Field(
        None, alias='maxCost', description='The maximum cost for the route.'
    )
    over_max_cost: Optional[OverMaxCost] = Field(
        None,
        alias='overMaxCost',
        description='The amount over maximum cost the route will allow.',
    )
    cargo_insurance: Optional[CargoInsurance2] = Field(
        None,
        alias='cargoInsurance',
        description='The amount of cargo insurance required for this load to cover the replacement cost of freight if damaged or destroyed in transit.',
    )
    stops: Optional[List[Stop5]] = Field(
        None,
        description='A list of locations of the pick ups and deliveries for an order record.',
    )
    references: Optional[List[Reference5]] = None


class Stop6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined unique identifier for a stop record.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined unique identifier for a stop record.'
    )


class StopRelationship(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    stops: Optional[List[Stop6]] = Field(
        None, description='A list of stops that are in a relationship.'
    )


class RoutesPUT(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    identifiers: Identifiers11 = Field(
        ...,
        description='An object containing one to many indentifier load ids.',
        title='IdentiferPutRecord',
    )
    routes: List[Route11] = Field(
        ..., description='An object containing one to many route detail objects.'
    )
    stop_relationships: Optional[List[StopRelationship]] = Field(
        None, alias='stopRelationships', description='A list of stop relationships.'
    )


class Position(Enum):
    before = 'before'
    after = 'after'


class Identifier6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined unique identifier for a stop record.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined unique identifier for a stop record.'
    )


class Identifier7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined unique identifier for a stop record.'
    )
    code: str = Field(
        ..., description='The externally defined unique identifier for a stop record.'
    )


class Sequence(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    position: Position = Field(
        ...,
        description='Identifies if want the new stop to be before or after the stop identified.',
    )
    identifier: Union[Identifier6, Identifier7] = Field(
        ..., description='Identifies the stop.', title='Identifier'
    )


class Facility42(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description='The externally defined unique identifier for a facility record.',
    )
    code: Optional[str] = Field(
        None,
        description='A unique facility code that is exposed on the UI that can be searched throughout the TMS.',
    )


class Facility43(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The externally defined unique identifier for a facility record.',
    )
    code: str = Field(
        ...,
        description='A unique facility code that is exposed on the UI that can be searched throughout the TMS.',
    )


class Location20(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility42, Facility43]] = Field(
        ..., description='The location of the facility.'
    )
    city_state: Optional[CityState13] = Field(
        None, alias='cityState', description='The location of the city and state.'
    )
    coordinates: Optional[Coordinates8] = Field(
        None, description='The coordinates of the location.'
    )


class Facility44(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description='The externally defined unique identifier for a facility record.',
    )
    code: Optional[str] = Field(
        None,
        description='A unique facility code that is exposed on the UI that can be searched throughout the TMS.',
    )


class Facility45(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The externally defined unique identifier for a facility record.',
    )
    code: str = Field(
        ...,
        description='A unique facility code that is exposed on the UI that can be searched throughout the TMS.',
    )


class Location21(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility44, Facility45]] = Field(
        None, description='The location of the facility.'
    )
    city_state: Optional[CityState13] = Field(
        ..., alias='cityState', description='The location of the city and state.'
    )
    coordinates: Optional[Coordinates8] = Field(
        None, description='The coordinates of the location.'
    )


class Facility46(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description='The externally defined unique identifier for a facility record.',
    )
    code: Optional[str] = Field(
        None,
        description='A unique facility code that is exposed on the UI that can be searched throughout the TMS.',
    )


class Facility47(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None,
        description='The externally defined unique identifier for a facility record.',
    )
    code: str = Field(
        ...,
        description='A unique facility code that is exposed on the UI that can be searched throughout the TMS.',
    )


class Location22(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility46, Facility47]] = Field(
        None, description='The location of the facility.'
    )
    city_state: Optional[CityState13] = Field(
        None, alias='cityState', description='The location of the city and state.'
    )
    coordinates: Optional[Coordinates8] = Field(
        ..., description='The coordinates of the location.'
    )


class ScheduleTypeTerm7(Enum):
    open = 'open'
    appt = 'appt'
    notice = 'notice'


class DriverTarget1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    start_date_time: conint(ge=1, le=2147483647999) = Field(
        ...,
        alias='startDateTime',
        description='Identifies the earliest start date and time a driver is expected to arrive at the facility by. Format is Unix Timestamp (in milliseconds).',
    )
    end_date_time: conint(ge=1, le=2147483647999) = Field(
        ...,
        alias='endDateTime',
        description='Identifies the latest date and time a driver is expected to arrive at the facility by. Format is Unix Timestamp (in milliseconds).',
    )


class Reference6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: str = Field(..., description='The value amount of a reference number.')
    qualifier_term: constr(min_length=1) = Field(
        ...,
        alias='qualifierTerm',
        description='Identifies the type of reference number (e.g., BOL, PO, shipment id).',
    )


class RoutesRouteIdentifierValuestopsPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    route_id: Optional[str] = Field(
        None, alias='routeId', description='The internally defined UUID of the route.'
    )
    route_number: Optional[str] = Field(
        None,
        alias='routeNumber',
        description='The internal route number displayed in MasterMind.',
    )
    code: constr(min_length=1) = Field(
        ..., description='The externally defined unique identifier for a stop record.'
    )
    sequence: Optional[Sequence] = Field(
        None,
        description='Identifies the sequence number for a stop in a series of stops. If this object is omitted, the stop will be added as the final stop on the route where applicable.',
        title='Sequence',
    )
    location: Union[Location20, Location21, Location22] = Field(
        ..., description='Identifies the location for a stop.', title='Location'
    )
    type_term: constr(min_length=1) = Field(
        ..., alias='typeTerm', description='The type of stop (e.g., pickup, delivery).'
    )
    available_start_date_time: conint(ge=1, le=2147483647999) = Field(
        ...,
        alias='availableStartDateTime',
        description='The earliest available start date and time associated with a stop.',
    )
    available_end_date_time: conint(ge=1, le=2147483647999) = Field(
        ...,
        alias='availableEndDateTime',
        description='The earliest available end date and time associated with a stop.',
    )
    schedule_type_term: ScheduleTypeTerm7 = Field(
        ...,
        alias='scheduleTypeTerm',
        description='The type of scheduling for the stop location (e.g., appointment, open).',
    )
    live_drop_term: LiveDropTerm = Field(
        ...,
        alias='liveDropTerm',
        description='Indicates the planned activity at a stop (e.g., live, drop, hook).',
    )
    work_term: WorkTerm = Field(
        ...,
        alias='workTerm',
        description='Indicates the key services at a stop (e.g., no touch, driver assist, lumper).',
    )
    unload_from_term: Optional[str] = Field(
        None,
        alias='unloadFromTerm',
        description='Indicates how the stop will unload the trailer.',
    )
    load_from_term: Optional[str] = Field(
        None,
        alias='loadFromTerm',
        description='Indicates how the stop will load the trailer.',
    )
    notes: Optional[str] = Field(
        None, description='Notes or comments associated with a stop.'
    )
    requested_date: Optional[str] = Field(
        None, alias='requestedDate', description='The requested date of a stop.'
    )
    appointment_start_date_time: Optional[conint(ge=1, le=2147483647999)] = Field(
        None,
        alias='appointmentStartDateTime',
        description='The earliest appointment start date and time associated with a stop.',
    )
    appointment_end_date_time: Optional[conint(ge=1, le=2147483647999)] = Field(
        None,
        alias='appointmentEndDateTime',
        description='The latest appointment start date and time associated with a stop.',
    )
    appointment_requested_with: Optional[str] = Field(
        None,
        alias='appointmentRequestedWith',
        description='Identifies with whom the appointment was requested with.',
    )
    appointment_requested_confirm_with: Optional[str] = Field(
        None,
        alias='appointmentRequestedConfirmWith',
        description='Identifies with whom the appointment was confirmed with.',
    )
    is_confirmed_appointment: Optional[bool] = Field(
        None,
        alias='isConfirmedAppointment',
        description='Indicates if the appointment as been confirmed.',
    )
    driver_target: Optional[DriverTarget1] = Field(
        None, alias='driverTarget', title='DriverTarget'
    )
    requirement_terms: Optional[List[str]] = Field(
        None,
        alias='requirementTerms',
        description='An itemized list of special requirements associated with a stop.',
    )
    references: Optional[List[Reference6]] = Field(
        None, description='A list of reference numbers associated to a stop.'
    )
    total_pallet_count: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='totalPalletCount',
        description='The number of the total number of pallets for a stop record.',
    )
    seal_number: Optional[str] = Field(
        None,
        alias='sealNumber',
        description='The seal number to lock the trailer for a stop record.',
    )
    bol_number: Optional[str] = Field(
        None,
        alias='bolNumber',
        description='The bill of lading number for a stop record.',
    )
    is_order_stop: Optional[bool] = Field(
        None,
        alias='isOrderStop',
        description='Indicates if an associated stop on the route is also an order stop, meaning it is the origin or destination of the order.',
    )


class LateReason(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code_term: str = Field(
        ...,
        alias='codeTerm',
        description='The reason the stop event will be late (e.g. Accident, Carrier - Mechanical Issue). Data dictionary term.',
    )


class Actual(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    date_time: confloat(le=8640000000000000.0) = Field(
        ...,
        alias='dateTime',
        description='The dateTime when a stop event was completed.',
    )
    late_reason: Optional[LateReason] = Field(
        None,
        alias='lateReason',
        description='A reason for why the stop event will be late.',
    )


class ManualExpected(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    date_time: confloat(le=8640000000000000.0) = Field(
        ...,
        alias='dateTime',
        description='The dateTime when a stop event is expected to be completed from a user.',
    )


class Trailer4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Optional[str] = Field(
        None,
        description='The externally defined unique identifier of the trailer stored in MasterMind.',
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined UUID of the trailer stored in MasterMind.',
    )
    number: Optional[str] = Field(
        None,
        description='An object used to assign a trailer number that is not a resource from within MasterMind.',
    )
    index: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The index number for a trailer assigned to a route. This should be provided across all objects and not overlap.',
    )


class RoutesRouteIdentifierValuestopsStopIdentifierValueTypeTermPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    notes: Optional[str] = Field(
        None, description='Notes pertaining to the stop event.'
    )
    actual: Optional[Actual] = Field(
        None, description='Details about when the stop event was actually completed.'
    )
    manual_expected: Optional[ManualExpected] = Field(
        None,
        alias='manualExpected',
        description="Any dateTime when a stop event is expected to be completed based on a user's knowledge.",
    )
    trailers: Optional[List[Trailer4]] = Field(
        None,
        description='The trailers that are physically attached to the tractor at the stop event.',
    )


class LateReason1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code_term: Optional[str] = Field(
        None,
        alias='codeTerm',
        description='The reason the stop event will be late (e.g. Accident, Carrier - Mechanical Issue). Data dictionary term.',
    )


class Actual1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    date_time: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='dateTime',
        description='The dateTime when a stop event was completed.',
    )
    late_reason: Optional[LateReason1] = Field(
        None,
        alias='lateReason',
        description='A reason for why the stop event will be late.',
    )


class ManualExpected1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    date_time: Optional[confloat(le=8640000000000000.0)] = Field(
        None,
        alias='dateTime',
        description='The dateTime when a stop event is expected to be completed from a user.',
    )


class Trailer5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if the trailer should be removed from the stop event.',
    )
    code: Optional[str] = Field(
        None,
        description='The externally defined unique identifier of the trailer stored in MasterMind.',
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined UUID of the trailer stored in MasterMind.',
    )
    number: Optional[str] = Field(
        None,
        description='An object used to assign a trailer number that is not a resource from within MasterMind.',
    )
    index: confloat(le=8640000000000000.0) = Field(
        ...,
        description='The index number for a trailer assigned to a route. This should be provided across all objects and not overlap.',
    )


class RoutesRouteIdentifierValuestopsStopIdentifierValueTypeTermPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    notes: Optional[str] = Field(
        None, description='Notes pertaining to the stop event.'
    )
    actual: Optional[Actual1] = Field(
        None, description='Details about when the stop event was actually completed.'
    )
    manual_expected: Optional[ManualExpected1] = Field(
        None,
        alias='manualExpected',
        description="Any dateTime when a stop event is expected to be completed based on a user's knowledge.",
    )
    trailers: Optional[List[Trailer5]] = Field(
        None,
        description='The trailers that are physically attached to the tractor at the stop event.',
    )


class AdditionalDivisionTerm(RootModel[constr(min_length=1)]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: constr(min_length=1) = Field(
        ...,
        description='The additional division type of the client (e.g., asset, brokerage).',
    )


class MinimumLength4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    unit_term: UnitTerm79 = Field(
        ..., alias='unitTerm', description='This represents unit of measurement.'
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='This represents measurement value.'
    )


class Width8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    unit_term: UnitTerm79 = Field(
        ..., alias='unitTerm', description='This represents unit of measurement.'
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='This represents measurement value.'
    )


class Height8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    unit_term: UnitTerm79 = Field(
        ..., alias='unitTerm', description='This represents unit of measurement.'
    )
    value: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='This represents measurement value.'
    )


class Dimensions4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    minimum_length: Optional[MinimumLength4] = Field(
        None,
        alias='minimumLength',
        description='The minimum required length of equipment.',
    )
    width: Optional[Width8] = Field(
        None, description='The minimum required width of equipment.'
    )
    height: Optional[Height8] = Field(
        None, description='The minimum required height of equipment.'
    )


class Equipment4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    trailer_type_terms: Optional[List[str]] = Field(None, alias='trailerTypeTerms')
    dimensions: Optional[Dimensions4] = Field(
        None, description='The dimensional requirements for equipment.'
    )


class MaxCost1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    currency_code_term: constr(min_length=1) = Field(
        ..., alias='currencyCodeTerm', description='This represents currency code.'
    )
    amount: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='This represents amount.'
    )


class OverMaxCost1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    currency_code_term: constr(min_length=1) = Field(
        ..., alias='currencyCodeTerm', description='This represents currency code.'
    )
    amount: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='This represents amount.'
    )


class CargoInsurance3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    currency_code_term: constr(min_length=1) = Field(
        ..., alias='currencyCodeTerm', description='This represents currency code.'
    )
    amount: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='This represents amount.'
    )


class Reference7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='The internally defined unique identifier for a reference record.',
    )
    id: Optional[str] = Field(
        None,
        description='The internally defined unique identifier for a reference record.',
    )
    value: Optional[constr(min_length=1)] = Field(
        None, description='The value amount of a reference number.'
    )
    qualifier_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='qualifierTerm',
        description='Identifies the type of reference number (e.g., Quote #, Trip #, Reservation #).',
    )


class RoutesRouteNumberPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    segment_code: Optional[constr(min_length=1)] = Field(
        None,
        alias='segmentCode',
        description='A Segment Code is a way to create further segmentation of freight that cannot be accomplished by way of Division, Project, or Dedicated Fleet Program.',
    )
    activation_status_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='activationStatusTerm',
        description='The activation status for a route record.',
    )
    additional_division_terms: Optional[List[AdditionalDivisionTerm]] = Field(
        None, alias='additionalDivisionTerms'
    )
    division_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='divisionTerm',
        description='The division type of the client (e.g., asset, brokerage).',
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='Identifies the mode of transport for a route record (e.g., OTR, IMDL, drayage, air).',
    )
    mode_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='modeTerm',
        description='The type of transportation required for this route (e.g., truck, rail, air).',
    )
    size_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='sizeTerm',
        description='The truckload size of a route record (e.g., FTL, LTL, partial).',
    )
    equipment: Optional[Equipment4] = None
    max_cost: Optional[MaxCost1] = Field(
        None,
        alias='maxCost',
        description='The maximum cost that the brokerage is will to pay for the route.',
    )
    over_max_cost: Optional[OverMaxCost1] = Field(
        None,
        alias='overMaxCost',
        description='The amount over maximum cost the route has gone.',
    )
    cargo_insurance: Optional[CargoInsurance3] = Field(
        None,
        alias='cargoInsurance',
        description='The amount of cargo insurance required for this load to cover the replacement cost of freight if damaged or destroyed in transit.',
    )
    is_hot_route: Optional[bool] = Field(
        None,
        alias='isHotRoute',
        description='Identifies if the route needs to be transported immediately.',
    )
    tarp_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='tarpTerm',
        description='The type of tarps required for the load (e.g., lumber, steel).',
    )
    tarp_count: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='tarpCount',
        description='The number of tarps required for the load.',
    )
    bracing_terms: Optional[List[str]] = Field(
        None,
        alias='bracingTerms',
        description='The type of bracing required for the load.',
    )
    bracing_count: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='bracingCount',
        description='The number of bracing required for the load.',
    )
    references: Optional[List[Reference7]] = None


class Amount(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    amount: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='Amount of the Vendor Invoice.'
    )
    currency_code_term: str = Field(
        ...,
        alias='currencyCodeTerm',
        description='Data Dictionary Term. The currency of this vendor invoice.',
    )


class Approver(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    email_address: Optional[EmailStr] = Field(
        None,
        alias='emailAddress',
        description='Email of the user that approved the vendor invoice.',
    )


class RemitAddress(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    address_line1: Optional[constr(min_length=1)] = Field(
        None, alias='addressLine1', description='First line of the street name.'
    )
    address_line2: Optional[constr(min_length=1)] = Field(
        None, alias='addressLine2', description='Second line of the street name.'
    )
    city: Optional[constr(min_length=1)] = Field(
        None, description='City of the address.'
    )
    state: Optional[constr(min_length=2, max_length=3)] = Field(
        None,
        description='State of the address (e.g., AZ, AR, AGU). ISO alpha-2, alpha-3.',
    )
    country: Optional[constr(min_length=3, max_length=3)] = Field(
        None,
        description='Country code of the address (e.g., CAN, MEX, USA). ISO alpha-3.',
    )
    postal_code: Optional[constr(min_length=1)] = Field(
        None, alias='postalCode', description='Postal Code of the address.'
    )


class ChargeDetail(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of charge associated with the invoice (e.g. Driver Assist, Fuel Surcharge, etc).',
    )
    code: constr(min_length=1) = Field(
        ..., description='The internally defined code for a type of charge.'
    )
    currency_code_term: str = Field(
        ..., alias='currencyCodeTerm', description='The currency of the charge.'
    )
    costper_unit: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., alias='costperUnit', description='Cost per unit of the charge.'
    )
    quantity: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., description='Total quantity or units of the charge.'
    )
    total_cost: confloat(ge=0.0, le=8640000000000000.0) = Field(
        ..., alias='totalCost', description='Total cost of the charge.'
    )


class RoutesRouteNumbercarriersCarrierCodeinvoicesPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The external provided code which will uniquely identify a Vendor Invoice.',
    )
    vendor_invoice_status_term: str = Field(
        ...,
        alias='vendorInvoiceStatusTerm',
        description='Data Dictionary Term. This is the `Status` of the vendor invoice.',
    )
    amount: Amount = Field(
        ..., description='Amount of the vendor invoice.', title='Amount'
    )
    approval_date: Optional[date] = Field(
        None,
        alias='approvalDate',
        description='Date the Vendor Invoice was set to Approved. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.',
    )
    comments: Optional[str] = Field(
        None, description='Comments to be appended to the vendor invoice.'
    )
    received_date: date = Field(
        ...,
        alias='receivedDate',
        description='Date the Vendor Invoice was received from the carrier. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.',
    )
    invoice_date: date = Field(
        ...,
        alias='invoiceDate',
        description='Date on the Vendor Invoice Document. Format is from RFC 3339, section 5.6 which is YYYY-MM-DD.',
    )
    is_quick_pay: Optional[bool] = Field(
        None,
        alias='isQuickPay',
        description='Indicates if a vendor invoice is to be paid via QuickPay.',
    )
    vendor_invoice_number: constr(min_length=1) = Field(
        ...,
        alias='vendorInvoiceNumber',
        description='User defined number associated to this Vendor Invoice.',
    )
    approver: Optional[Approver] = Field(
        None, description='Approver of the vendor invoice.'
    )
    remit_address: Optional[RemitAddress] = Field(
        None,
        alias='remitAddress',
        description='The remittance address to use for the vendor invoice, if applicable.',
    )
    charge_details: Optional[List[ChargeDetail]] = Field(
        None,
        alias='chargeDetails',
        description='The charges associated with a vendor invoice from an external source.',
    )


class Drivers(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    sequence_number: confloat(le=8640000000000000.0) = Field(
        ...,
        alias='sequenceNumber',
        description='The sequence number for a driver assigned to a route.',
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The externally defined code for the driver that can be searched throughout the TMS.',
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined driver UUID.'
    )
    bypass_reason_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='bypassReasonTerm',
        description='The list of reasons that can be sent in to override soft driver assignment validation failures (e.g. Booked Through API, Driver Variance, etc). Data Dictionary Term.',
    )


class Drivers1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    sequence_number: confloat(le=8640000000000000.0) = Field(
        ...,
        alias='sequenceNumber',
        description='The sequence number for a driver assigned to a route.',
    )
    code: Optional[constr(min_length=1)] = Field(
        None,
        description='The externally defined code for the driver that can be searched throughout the TMS.',
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined driver UUID.'
    )
    bypass_reason_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='bypassReasonTerm',
        description='The list of reasons that can be sent in to override soft driver assignment validation failures (e.g. Booked Through API, Driver Variance, etc). Data Dictionary Term.',
    )


class Tractor4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: str = Field(
        ...,
        description='The externally defined code for the tractor that can be searched throughout the TMS.',
    )
    id: str = Field(..., description='The internally defined tractor UUID.')


class CityState20(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city: constr(min_length=1) = Field(..., description='The city of the location.')
    state: constr(min_length=2, max_length=3) = Field(
        ..., description='The state of the location (e.g., AZ, AR). ISO 3166-2.'
    )


class ReadyLocation(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city_state: CityState20 = Field(
        ..., alias='cityState', title='CreatedResourceAssignmentCityStateRecord'
    )
    coordinates: Optional[Coordinates8] = Field(
        None, description='The coordinates of the ready location.'
    )


class ReadyLocation1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city_state: Optional[CityState20] = Field(
        None, alias='cityState', title='CreatedResourceAssignmentCityStateRecord'
    )
    coordinates: Optional[Coordinates8] = Field(
        ..., description='The coordinates of the ready location.'
    )


class Identifiers12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Optional[str] = Field(
        None, description='Externally defined trailer identifier.'
    )
    id: Optional[str] = Field(None, description='Internally defined trailer UUID.')
    number: Optional[str] = Field(
        None,
        description='The free form text field representing the Trailer Number assigned to the route.',
    )


class ResourceType(Enum):
    carrier = 'Carrier'
    fleet = 'Fleet'


class Length6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ..., description='The value of the length.'
    )
    unit_term: str = Field(
        ..., alias='unitTerm', description='The unit of measurement for the length.'
    )


class Width9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ..., description='The value of the width.'
    )
    unit_term: str = Field(
        ..., alias='unitTerm', description='The unit of measurement for the width.'
    )


class Height9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ..., description='The value of the height.'
    )
    unit_term: str = Field(
        ..., alias='unitTerm', description='The unit of measurement for the height.'
    )


class Dimensions5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    length: Optional[Length6] = None
    width: Optional[Width9] = None
    height: Optional[Height9] = None


class Pallets(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='Type of pallet on the route vendor record (e.g., Standard, Chep, Disposable). Data Dictionary Term.',
    )
    count: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ..., description='Number of pallets.'
    )


class Tarps(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of tarps required for the load (e.g., lumber, steel). Data Dictionary Term.',
    )
    count: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ..., description='Number of tarps.'
    )


class Bracing2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: List[str] = Field(..., alias='typeTerm')
    count: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ..., description='Number of braces.'
    )


class InboundTrailer(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    index_number: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ...,
        alias='indexNumber',
        description='The index number for a trailer assigned to a route.',
    )
    identifiers: Optional[Identifiers12] = Field(
        None,
        description='The trailer identifiers object.',
        title='CreateResourceAssignmentInboundTrailersIdentifiersRecord',
    )
    resource_type: ResourceType = Field(
        ...,
        alias='resourceType',
        description='Determines if the trailer resource assigned to the route is a Fleet or Carrier resource.',
    )
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The trailer type (e.g., Reefer, Van, Flatbed). Data Dictionary Term.',
    )
    dimensions: Optional[Dimensions5] = None
    pallets: Optional[Pallets] = Field(
        None,
        description='The trailer pallets object.',
        title='CreatedInboundTrailersPalletsRecord',
    )
    tarps: Optional[Tarps] = Field(
        None, description='The tarps object.', title='CreatedInboundTrailersTarpsRecord'
    )
    bracing: Optional[Bracing2] = Field(
        None,
        description='The bracing object.',
        title='CreatedInboundTrailersBracingRecord',
    )


class Dimensions6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    length: Optional[Length6] = None
    width: Optional[Width9] = None
    height: Optional[Height9] = None


class Pallets1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ..., alias='typeTerm', description='The type value of the pallets.'
    )
    count: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ..., description='The number of pallets.'
    )


class Tarps1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(..., alias='typeTerm', description='The type of tarps.')
    count: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ..., description='The number of tarps.'
    )


class LoadedTrailer(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    index_number: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ...,
        alias='indexNumber',
        description='The index number for a trailer assigned to a route.',
    )
    identifiers: Optional[Identifiers12] = Field(
        None,
        description='The trailer identifiers object.',
        title='CreateResourceAssignmentLoadedTrailersIdentifiersRecord',
    )
    resource_type: ResourceType = Field(
        ...,
        alias='resourceType',
        description='Determines if the trailer resource assigned to the route is a Fleet or Carrier resource.',
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='The trailer type (e.g., Reefer, Van, Flatbed). Data Dictionary Term.',
    )
    dimensions: Optional[Dimensions6] = Field(
        None,
        description='The trailer dimensions object.',
        title='CreatedLoadedTrailersDimensionsRecord',
    )
    pallets: Optional[Pallets1] = Field(
        None,
        description='The trailer pallets object.',
        title='CreatedLoadedTrailersPalletsRecord',
    )
    tarps: Optional[Tarps1] = Field(
        None, description='The tarps object.', title='CreatedLoadedTrailersTarpsRecord'
    )
    bracing: Optional[Bracing2] = Field(
        None,
        description='The bracing object.',
        title='CreatedLoadedTrailersBracingRecord',
    )


class Dimensions7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    length: Optional[Length6] = None
    width: Optional[Width9] = None
    height: Optional[Height9] = None


class Pallets2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: constr(min_length=1) = Field(
        ...,
        alias='typeTerm',
        description='Type of pallet on the route vendor record (e.g., Standard, Chep, Disposable). Data Dictionary Term.',
    )
    count: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ..., description='Number of pallets.'
    )


class Tarps2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: str = Field(
        ...,
        alias='typeTerm',
        description='The type of tarps required for the load (e.g., lumber, steel). Data Dictionary Term.',
    )
    count: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ..., description='Number of tarps.'
    )


class Bracing4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: List[str] = Field(..., alias='typeTerm')
    count: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ..., description='The number of braces.'
    )


class OutboundTrailer(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    index_number: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ...,
        alias='indexNumber',
        description='The index number for a trailer assigned to a route.',
    )
    identifiers: Optional[Identifiers12] = Field(
        None,
        description='The trailer identifiers object.',
        title='CreateResourceAssignmentOutboundTrailersIdentifiersRecord',
    )
    resource_type: ResourceType = Field(
        ...,
        alias='resourceType',
        description='Determines if the trailer resource assigned to the route is a Fleet or Carrier resource.',
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='The trailer type (e.g., Reefer, Van, Flatbed). Data Dictionary Term.',
    )
    dimensions: Optional[Dimensions7] = None
    pallets: Optional[Pallets2] = Field(
        None,
        description='The trailer pallets object.',
        title='CreatedOutboundTrailersPalletsRecord',
    )
    tarps: Optional[Tarps2] = Field(
        None, description='Tarps object.', title='CreatedOutboundTrailersTarpsRecord'
    )
    bracing: Optional[Bracing4] = Field(
        None,
        description='The bracing object.',
        title='CreatedOutboundTrailersBracingRecord',
    )


class RoutesRouteNumberresourceAssignmentPOST(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    booking_source_type_term: constr(min_length=1) = Field(
        ...,
        alias='bookingSourceTypeTerm',
        description='The internal or external system that was used to book the route (e.g., External API, Trucker Tools, Mobile App). Data Dictionary Term.',
    )
    executing_division_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='executingDivisionTerm',
        description='Identifies the division that will execute the route (e.g., Asset, Brokerage, Dedicated) Data Dictionary Term.',
    )
    drivers: Optional[List[Union[Drivers, Drivers1]]] = Field(
        None, description='Driver object(s) assigned to the route.'
    )
    tractor: Optional[Tractor4] = Field(None, description='The tractor object.')
    ready_location: Optional[Union[ReadyLocation, ReadyLocation1]] = Field(
        None, alias='readyLocation', description='The ready location object.'
    )
    ready_date_time: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='readyDateTime',
        description='The date and time the trailer on the route will be empty.  Unix timestamp (in milliseconds).',
    )
    ready_timezone: Optional[str] = Field(
        None,
        alias='readyTimezone',
        description='The timezone for the empty date and time.',
    )
    notes: Optional[str] = Field(
        None,
        description='The free form notes field for the driver assigned to the route.',
    )
    reload_intent_term: Optional[str] = Field(
        None,
        alias='reloadIntentTerm',
        description='Automatically creates capacity to update and reflect the latest information based on the load  (e.g., Undecided, Need next route). Data Dictionary Term.',
    )
    is_dispatched: bool = Field(
        ...,
        alias='isDispatched',
        description='Indicates if route has been dispatched to the driver.',
    )
    inbound_trailers: Optional[List[InboundTrailer]] = Field(
        None, alias='inboundTrailers'
    )
    loaded_trailers: Optional[List[LoadedTrailer]] = Field(None, alias='loadedTrailers')
    outbound_trailers: Optional[List[OutboundTrailer]] = Field(
        None, alias='outboundTrailers'
    )


class Drivers2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    sequence_number: confloat(le=8640000000000000.0) = Field(
        ...,
        alias='sequenceNumber',
        description='The sequence number for a driver assigned to a route.',
    )
    code: constr(min_length=1) = Field(
        ...,
        description='The externally defined code for the driver that can be searched throughout the TMS.',
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The internally defined driver UUID.'
    )
    bypass_reason_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='bypassReasonTerm',
        description='The list of reasons that can be sent in to override soft driver assignment validation failures (e.g. Booked Through API, Driver Variance, etc). Data Dictionary Term.',
    )
    is_bounced: Optional[bool] = Field(
        None,
        alias='isBounced',
        description='Identifies if the driver has been bounced from the assigned route.',
    )
    bounce_reason_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='bounceReasonTerm',
        description='The value that states the reason why a driver has been bounced from the assigned route (e.g., Bad Equipment, Late Driver, Wrong Driver Added). Data Dictionary Term.',
    )


class Drivers3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    sequence_number: confloat(le=8640000000000000.0) = Field(
        ...,
        alias='sequenceNumber',
        description='The sequence number for a driver assigned to a route.',
    )
    code: Optional[constr(min_length=1)] = Field(
        None,
        description='The externally defined code for the driver that can be searched throughout the TMS.',
    )
    id: constr(min_length=1) = Field(
        ..., description='The internally defined driver UUID.'
    )
    bypass_reason_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='bypassReasonTerm',
        description='The list of reasons that can be sent in to override soft driver assignment validation failures (e.g. Booked Through API, Driver Variance, etc). Data Dictionary Term.',
    )
    is_bounced: Optional[bool] = Field(
        None,
        alias='isBounced',
        description='Identifies if the driver has been bounced from the assigned route.',
    )
    bounce_reason_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='bounceReasonTerm',
        description='The value that states the reason why a driver has been bounced from the assigned route (e.g., Bad Equipment, Late Driver, Wrong Driver Added). Data Dictionary Term.',
    )


class Coordinates22(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    latitude: confloat(le=8640000000000000.0) = Field(
        ..., description='The latitude coordinate.'
    )
    longitude: confloat(le=8640000000000000.0) = Field(
        ..., description='The longitude coordinate.'
    )


class ReadyLocation2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city_state: CityState20 = Field(
        ..., alias='cityState', title='PatchedResourceAssignmentCityStateRecord'
    )
    coordinates: Optional[Coordinates22] = Field(
        None, description='The coordinates of the ready location.'
    )


class ReadyLocation3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city_state: Optional[CityState20] = Field(
        None, alias='cityState', title='PatchedResourceAssignmentCityStateRecord'
    )
    coordinates: Optional[Coordinates22] = Field(
        ..., description='The coordinates of the ready location.'
    )


class Length9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: Optional[confloat(le=8640000000000000.0)] = Field(
        None, description='The value of the length.'
    )
    unit_term: Optional[str] = Field(
        None, alias='unitTerm', description='The unit of measurement for the length.'
    )


class Width12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: Optional[confloat(le=8640000000000000.0)] = Field(
        None, description='The value of the width.'
    )
    unit_term: Optional[str] = Field(
        None, alias='unitTerm', description='The unit of measurement for the width.'
    )


class Height12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: Optional[confloat(le=8640000000000000.0)] = Field(
        None, description='The value of the height.'
    )
    unit_term: Optional[str] = Field(
        None, alias='unitTerm', description='The unit of measurement for the height.'
    )


class Dimensions8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    length: Optional[Length9] = None
    width: Optional[Width12] = None
    height: Optional[Height12] = None


class Pallets3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='Type of pallet on the route vendor record (e.g., Standard, Chep, Disposable). Data Dictionary Term.',
    )
    count: Optional[confloat(le=8640000000000000.0)] = Field(
        None, description='Number of pallets.'
    )


class Tarps3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='The type of tarps required for the load (e.g., lumber, steel). Data Dictionary Term.',
    )
    count: Optional[confloat(le=8640000000000000.0)] = Field(
        None, description='Number of tarps.'
    )


class Bracing5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: Optional[List[constr(min_length=1)]] = Field(
        None,
        alias='typeTerm',
        description='The type of bracing required for the load (e.g., Straps, Load Bars). Data Dictionary Term.',
    )
    count: Optional[confloat(le=8640000000000000.0)] = Field(
        None, description='The number of braces.'
    )


class InboundTrailer1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates whether the existing inbound trailer should be removed from the route.',
    )
    index_number: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ...,
        alias='indexNumber',
        description='The index number for a trailer assigned to a route.',
    )
    identifiers: Optional[Identifiers12] = Field(
        None,
        description='The trailer identifiers object.',
        title='PatchedResourceAssignmentInboundTrailersIdentifiersRecord',
    )
    resource_type: Optional[ResourceType] = Field(None, alias='resourceType')
    type_term: Optional[str] = Field(
        None,
        alias='typeTerm',
        description='The trailer type (e.g., Reefer, Van, Flatbed). Data Dictionary Term.',
    )
    dimensions: Optional[Dimensions8] = None
    pallets: Optional[Pallets3] = Field(
        None,
        description='The trailer pallets object.',
        title='PatchedInboundTrailersPalletsRecord',
    )
    tarps: Optional[Tarps3] = Field(
        None, description='The tarps object.', title='PatchedInboundTrailersTarpsRecord'
    )
    bracing: Optional[Bracing5] = Field(
        None,
        description='The bracing object.',
        title='PatchedInboundTrailersBracingRecord',
    )


class Dimensions9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    length: Optional[Length9] = None
    width: Optional[Width12] = None
    height: Optional[Height12] = None


class Pallets4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None, alias='typeTerm', description='The type value of the pallets.'
    )
    count: Optional[confloat(le=8640000000000000.0)] = Field(
        None, description='The number of pallets.'
    )


class Tarps4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None, alias='typeTerm', description='The type of tarps.'
    )
    count: Optional[confloat(le=8640000000000000.0)] = Field(
        None, description='The number of tarps.'
    )


class LoadedTrailer1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates whether the existing loaded trailer should be removed from the route.',
    )
    index_number: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ...,
        alias='indexNumber',
        description='The index number for a trailer assigned to a route.',
    )
    identifiers: Optional[Identifiers12] = Field(
        None,
        description='The trailer identifiers object.',
        title='PatchedResourceAssignmentLoadedTrailersIdentifiersRecord',
    )
    resource_type: Optional[ResourceType] = Field(None, alias='resourceType')
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='The trailer type (e.g., Reefer, Van, Flatbed). Data Dictionary Term.',
    )
    dimensions: Optional[Dimensions9] = None
    pallets: Optional[Pallets4] = Field(
        None,
        description='The trailer pallets object.',
        title='PatchedLoadedTrailersPalletsRecord',
    )
    tarps: Optional[Tarps4] = Field(
        None, description='The tarps object.', title='PatchedLoadedTrailersTarpsRecord'
    )
    bracing: Optional[Bracing5] = Field(
        None,
        description='The bracing object.',
        title='PatchedLoadedTrailersBracingRecord',
    )


class Dimensions10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    length: Optional[Length9] = None
    width: Optional[Width12] = None
    height: Optional[Height12] = None


class Pallets5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='Type of pallet on the route vendor record (e.g., Standard, Chep, Disposable). Data Dictionary Term.',
    )
    count: Optional[confloat(le=8640000000000000.0)] = Field(
        None, description='The number of pallets.'
    )


class Tarps5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='The type of tarps required for the load (e.g., lumber, steel). Data Dictionary Term.',
    )
    count: Optional[confloat(le=8640000000000000.0)] = Field(
        None, description='The number of tarps.'
    )


class OutboundTrailer1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates whether the existing outbound trailer should be removed from the route.',
    )
    index_number: confloat(ge=1.0, le=8640000000000000.0) = Field(
        ...,
        alias='indexNumber',
        description='The index number for a trailer assigned to a route.',
    )
    identifiers: Optional[Identifiers12] = Field(
        None,
        description='The trailer identifiers object.',
        title='PatchedResourceAssignmentOutboundTrailersIdentifiersRecord',
    )
    resource_type: Optional[ResourceType] = Field(None, alias='resourceType')
    type_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='typeTerm',
        description='The trailer type (e.g., Reefer, Van, Flatbed). Data Dictionary Term.',
    )
    dimensions: Optional[Dimensions10] = None
    pallets: Optional[Pallets5] = Field(
        None,
        description='The trailer pallets object.',
        title='PatchedOutboundTrailersPalletsRecord',
    )
    tarps: Optional[Tarps5] = Field(
        None,
        description='The tarps object.',
        title='PatchedOutboundTrailersTarpsRecord',
    )
    bracing: Optional[Bracing5] = Field(
        None,
        description='The bracing object.',
        title='PatchedOutboundTrailersBracingRecord',
    )


class RoutesRouteNumberresourceAssignmentIdPATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    executing_division_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='executingDivisionTerm',
        description='Identifies the division that will execute the route (e.g., Asset, Brokerage, Dedicated) Data Dictionary Term.',
    )
    drivers: Optional[List[Union[Drivers2, Drivers3]]] = Field(
        None, description='Driver object(s) assigned to the route.'
    )
    tractor: Optional[Tractor4] = Field(None, description='The tractor object.')
    ready_location: Optional[Union[ReadyLocation2, ReadyLocation3]] = Field(
        None, alias='readyLocation', description='The ready location object.'
    )
    ready_date_time: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='readyDateTime',
        description='The date and time the trailer on the route will be empty.  Unix timestamp (in milliseconds).',
    )
    ready_timezone: Optional[str] = Field(
        None,
        alias='readyTimezone',
        description='The timezone for the empty date and time.',
    )
    notes: Optional[str] = Field(
        None,
        description='The free form notes field for the driver assigned to the route.',
    )
    reload_intent_term: Optional[str] = Field(
        None,
        alias='reloadIntentTerm',
        description='Automatically creates capacity to update and reflect the latest information based on the load  (e.g., Undecided, Need next route). Data Dictionary Term.',
    )
    is_dispatched: Optional[bool] = Field(
        None,
        alias='isDispatched',
        description='Indicates if route has been dispatched to the driver.',
    )
    inbound_trailers: Optional[List[InboundTrailer1]] = Field(
        None, alias='inboundTrailers'
    )
    loaded_trailers: Optional[List[LoadedTrailer1]] = Field(
        None, alias='loadedTrailers'
    )
    outbound_trailers: Optional[List[OutboundTrailer1]] = Field(
        None, alias='outboundTrailers'
    )


class Facility48(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility49(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class CityState24(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    city: Optional[str] = Field(None, description='The city of the address.')
    state: Optional[constr(min_length=2, max_length=3)] = Field(
        None, description='The state of the address (e.g., AZ, AR). ISO 3166-2.'
    )
    county: Optional[str] = Field(None, description='The county of the address.')
    country: Optional[constr(min_length=3, max_length=3)] = Field(
        None,
        description='The country of the address (e.g., CAN, MEX, USA). ISO 3166-1 Alpha-3.',
    )


class Coordinates24(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    latitude: confloat(ge=-90.0, le=90.0) = Field(
        ..., description='The latitude coordinate.'
    )
    longitude: confloat(ge=-180.0, le=180.0) = Field(
        ..., description='The longitude coordinate.'
    )


class Location23(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility48, Facility49]] = Field(
        ..., description='The location of the facility.'
    )
    city_state: Optional[CityState24] = Field(
        None, alias='cityState', description='The location of the city and state.'
    )
    coordinates: Optional[Coordinates24] = Field(
        None, description='The coordinates of the location.'
    )
    facility_code: Optional[str] = Field(
        None,
        alias='facilityCode',
        description='The externally defined unique identifier for a facility record.',
    )


class Facility50(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility51(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class Location24(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility50, Facility51]] = Field(
        None, description='The location of the facility.'
    )
    city_state: Optional[CityState24] = Field(
        ..., alias='cityState', description='The location of the city and state.'
    )
    coordinates: Optional[Coordinates24] = Field(
        None, description='The coordinates of the location.'
    )
    facility_code: Optional[str] = Field(
        None,
        alias='facilityCode',
        description='The externally defined unique identifier for a facility record.',
    )


class Facility52(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility53(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class Location25(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility52, Facility53]] = Field(
        None, description='The location of the facility.'
    )
    city_state: Optional[CityState24] = Field(
        None, alias='cityState', description='The location of the city and state.'
    )
    coordinates: Optional[Coordinates24] = Field(
        ..., description='The coordinates of the location.'
    )
    facility_code: Optional[str] = Field(
        None,
        alias='facilityCode',
        description='The externally defined unique identifier for a facility record.',
    )


class Facility54(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description='The internally defined UUID referencing the facility.'
    )
    code: Optional[str] = Field(
        None, description='The externally defined code referencing the facility.'
    )


class Facility55(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Optional[str] = Field(
        None, description='The internally defined UUID referencing the facility.'
    )
    code: str = Field(
        ..., description='The externally defined code referencing the facility.'
    )


class Location26(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    facility: Optional[Union[Facility54, Facility55]] = Field(
        None, description='The location of the facility.'
    )
    city_state: Optional[CityState24] = Field(
        None, alias='cityState', description='The location of the city and state.'
    )
    coordinates: Optional[Coordinates24] = Field(
        None, description='The coordinates of the location.'
    )
    facility_code: str = Field(
        ...,
        alias='facilityCode',
        description='The externally defined unique identifier for a facility record.',
    )


class ScheduleTypeTerm8(Enum):
    appt = 'appt'
    notice = 'notice'
    open = 'open'


class Reference8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    field__is_destroy: Optional[bool] = Field(
        None,
        alias='__isDestroy',
        description='Indicates if this reference should be destroyed.',
    )
    id: Optional[str] = Field(
        None,
        description='The externally defined unique identifier for a reference record.',
    )
    value: Optional[str] = Field(
        None, description='The value amount of a reference number.'
    )
    qualifier_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='qualifierTerm',
        description='Identifies the type of reference number (e.g., BOL, PO, shipment id).',
    )


class RoutesRouteNumberstopsIdentifierValuePATCH(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    location: Optional[Union[Location23, Location24, Location25, Location26]] = Field(
        None, description='Identifies the location for a stop record.'
    )
    type_term: Optional[str] = Field(
        None, alias='typeTerm', description='The type of stop (e.g., pickup, delivery).'
    )
    available_start_date_time: Optional[confloat(ge=1.0, le=8640000000000000.0)] = (
        Field(
            None,
            alias='availableStartDateTime',
            description='The earliest available start date and time associated with a stop. Unix timestamp (in milliseconds).',
        )
    )
    available_end_date_time: Optional[confloat(ge=1.0, le=8640000000000000.0)] = Field(
        None,
        alias='availableEndDateTime',
        description='The latest available start date and time associated with a stop. Unix timestamp (in milliseconds).',
    )
    schedule_type_term: Optional[ScheduleTypeTerm8] = Field(
        None,
        alias='scheduleTypeTerm',
        description='The type of scheduling for the stop location (e.g., appointment, open).',
    )
    live_drop_term: Optional[LiveDropTerm] = Field(
        None,
        alias='liveDropTerm',
        description='Indicates the planned activity at a stop (e.g., live, drop, hook).',
    )
    work_term: Optional[WorkTerm] = Field(
        None,
        alias='workTerm',
        description='Indicates the key services at a stop (e.g., no touch, driver assist, lumper).',
    )
    unload_from_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='unloadFromTerm',
        description='Indicates how the stop will unload the trailer.',
    )
    load_from_term: Optional[constr(min_length=1)] = Field(
        None,
        alias='loadFromTerm',
        description='Indicates how the stop will load the trailer.',
    )
    notes: Optional[str] = Field(
        None, description='Notes or comments associated with a stop.'
    )
    requested_date: Optional[date] = Field(
        None, alias='requestedDate', description='The requested date of a stop.'
    )
    appointment_start_date_time: Optional[confloat(ge=1.0, le=8640000000000000.0)] = (
        Field(
            None,
            alias='appointmentStartDateTime',
            description='The earliest appointment start date and time associated with a stop. Unix timestamp (in milliseconds).',
        )
    )
    appointment_end_date_time: Optional[confloat(ge=1.0, le=8640000000000000.0)] = (
        Field(
            None,
            alias='appointmentEndDateTime',
            description='The latest appointment start date and time associated with a stop. Unix timestamp (in milliseconds).',
        )
    )
    appointment_requested_with: Optional[str] = Field(
        None,
        alias='appointmentRequestedWith',
        description='Identifies with whom the appointment was requested with.',
    )
    appointment_requested_confirm_with: Optional[str] = Field(
        None,
        alias='appointmentRequestedConfirmWith',
        description='Identifies with whom the appointment was confirmed with.',
    )
    is_confirmed_appointment: Optional[bool] = Field(
        None,
        alias='isConfirmedAppointment',
        description='Indicates if the appointment as been confirmed.',
    )
    requirement_terms: Optional[List[str]] = Field(
        None,
        alias='requirementTerms',
        description='An itemized list of special requirements associated with a stop.',
    )
    references: Optional[List[Reference8]] = Field(
        None, description='A list of reference numbers associated to a stop.'
    )
    total_pallet_count: Optional[confloat(ge=0.0, le=8640000000000000.0)] = Field(
        None,
        alias='totalPalletCount',
        description='The number of the total number of pallets for a stop record.',
    )
    seal_number: Optional[str] = Field(
        None,
        alias='sealNumber',
        description='The seal number to lock the trailer for a stop record.',
    )
    bol_number: Optional[str] = Field(
        None,
        alias='bolNumber',
        description='The bill of lading number for a stop record.',
    )
    is_order_stop: Optional[bool] = Field(
        None,
        alias='isOrderStop',
        description='Indicates if an associated stop on the route is also an order stop, meaning it is the origin or destination of the order.',
    )
